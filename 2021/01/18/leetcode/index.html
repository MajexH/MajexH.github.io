<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>leetcode - Majexh</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Majexh"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Majexh"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="leetcode 例题记录下 leetcode 值得记录的例题"><meta property="og:type" content="blog"><meta property="og:title" content="leetcode"><meta property="og:url" content="https://blog.majexh.xyz/2021/01/18/leetcode/"><meta property="og:site_name" content="Majexh"><meta property="og:description" content="leetcode 例题记录下 leetcode 值得记录的例题"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.majexh.xyz/2021/01/18/leetcode/union.png"><meta property="og:image" content="https://blog.majexh.xyz/2021/01/18/leetcode/959-1.png"><meta property="article:published_time" content="2021-01-18T08:38:31.000Z"><meta property="article:modified_time" content="2021-04-15T07:31:34.266Z"><meta property="article:author" content="Majexh"><meta property="article:tag" content="leetcode"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/2021/01/18/leetcode/union.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.majexh.xyz/2021/01/18/leetcode/"},"headline":"Majexh","image":["https://blog.majexh.xyz/2021/01/18/leetcode/union.png","https://blog.majexh.xyz/2021/01/18/leetcode/959-1.png"],"datePublished":"2021-01-18T08:38:31.000Z","dateModified":"2021-04-15T07:31:34.266Z","author":{"@type":"Person","name":"Majexh"},"description":"leetcode 例题记录下 leetcode 值得记录的例题"}</script><link rel="canonical" href="https://blog.majexh.xyz/2021/01/18/leetcode/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Majexh</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-01-18T08:38:31.000Z" title="2021-01-18T08:38:31.000Z">2021-01-18</time>发表</span><span class="level-item"><time dateTime="2021-04-15T07:31:34.266Z" title="2021-04-15T07:31:34.266Z">2021-04-15</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/code/">code</a></span><span class="level-item">2 小时读完 (大约21585个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">leetcode</h1><div class="content"><h1 id="leetcode-例题"><a href="#leetcode-例题" class="headerlink" title="leetcode 例题"></a>leetcode 例题</h1><p>记录下 leetcode 值得记录的例题</p>
<a id="more"></a>

<h2 id="kmp-算法"><a href="#kmp-算法" class="headerlink" title="kmp 算法"></a>kmp 算法</h2><p>kmp 算法的原始实现方法在另一篇里面已经写过，实际上就是通过记录模式串的相同的前后缀长度来跳过模式串重新匹配的距离。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] getNext(String pattern) &#123;</span><br><span class="line">	  <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</span><br><span class="line">		next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">		<span class="comment">// 模式串相差一进行匹配</span></span><br><span class="line">		<span class="keyword">int</span> k = -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (j &lt; pattern.length() - <span class="number">1</span>) &#123;</span><br><span class="line">			  <span class="comment">// 匹配相同的字符</span></span><br><span class="line">				<span class="keyword">if</span> (k == -<span class="number">1</span> || pattern.charAt(k) == pattern.charAt(j)) &#123;</span><br><span class="line">					  k++;</span><br><span class="line">						j++;</span><br><span class="line">						next[j] = k;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						k = next[k];</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(String s, String pattern)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span>[] next = getNext(pattern);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; j &lt; pattern.length()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (s.charAt(i) == pattern.charAt(j)) &#123;</span><br><span class="line">          i++;</span><br><span class="line">          j++;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 失配 重新定位</span></span><br><span class="line">          j = next[j];</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (j == pattern.length()) &#123;</span><br><span class="line">     <span class="keyword">return</span> i - j;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">// 没有找到</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短回文串"><a href="#最短回文串" class="headerlink" title="最短回文串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/shortest-palindrome/">最短回文串</a></h3><p>给定一个字符串，问在字符串<strong>左边</strong>添加一些字母后，形成一个回文串，问形成的回文串中，最短的回文串什么。</p>
<ul>
<li>超时解法</li>
</ul>
<p>最开始的暴力思维，想得就是遍历这个字符串，找到中间可以作为分隔线的地方（因为回文串其实可以看成在一个分隔点的左右镜像），然后遍历所有的分割线，比较生成的最短回文串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 只能在字符串前面添加</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String min = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 作为 palindrome 的中心点 进行遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= s.length() / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            String odd = odd(i, s);</span><br><span class="line">            String even = even(i, s);</span><br><span class="line">            String tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (odd.equals(<span class="string">&quot;&quot;</span>) &amp;&amp; even.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (odd.equals(<span class="string">&quot;&quot;</span>)) tmp = even;</span><br><span class="line">            <span class="keyword">if</span> (even.equals(<span class="string">&quot;&quot;</span>)) tmp = odd;</span><br><span class="line">            <span class="keyword">if</span> (!odd.equals(<span class="string">&quot;&quot;</span>) &amp;&amp; !even.equals(<span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                tmp = even.length() &gt; odd.length() ? odd: even;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (min == <span class="keyword">null</span>) min = tmp;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (min.length() &gt; tmp.length()) &#123;</span><br><span class="line">                min = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">odd</span><span class="params">(<span class="keyword">int</span> i, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 考虑最后的 palindrome 是奇数长度情况</span></span><br><span class="line">        <span class="keyword">boolean</span> canPalindrome = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="comment">// 不能形成</span></span><br><span class="line">                canPalindrome = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        String tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!canPalindrome) <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边为 -1 说明右边长要把右边的加载左边</span></span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) &#123;</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder(s.substring(right));</span><br><span class="line"></span><br><span class="line">            tmp = builder.reverse().toString() + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">even</span><span class="params">(<span class="keyword">int</span> i, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = i - <span class="number">1</span>, right = i;</span><br><span class="line">        <span class="comment">// 考虑最后的 palindrome 是奇数长度情况</span></span><br><span class="line">        <span class="keyword">boolean</span> canPalindrome = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(left) != s.charAt(right)) &#123;</span><br><span class="line">                <span class="comment">// 不能形成</span></span><br><span class="line">                canPalindrome = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left--;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        String tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!canPalindrome) <span class="keyword">return</span> tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左边为 -1 说明右边长要把右边的加载左边</span></span><br><span class="line">        <span class="keyword">if</span> (left == -<span class="number">1</span>) &#123;</span><br><span class="line">            StringBuilder builder = <span class="keyword">new</span> StringBuilder(s.substring(right));</span><br><span class="line"></span><br><span class="line">            tmp = builder.reverse().toString() + s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>前后缀思维</li>
</ul>
<p>其实考虑一个最长的回文串的，肯定是把输入串的逆向输入串拼接到原始字符串的左边。</p>
<p>那么，如果这个逆向的字符串有一部分跟输入串的前一部分是重合的就可以缩短整个长度。</p>
<p>比如</p>
<ul>
<li><span style="color: red">a</span>baaa 与其逆 aaab<span style="color: red">a</span> 在红色的地方重合<ul>
<li>即 abaaa 的前缀 a 与 aaaba 的后缀 a 重合</li>
</ul>
</li>
</ul>
<p>所以 只需要遍历得到这个相同的前后缀即可。</p>
<p>下述算法，由于需要判断 equals 因此其执行效率趋近 o(n^2)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">	  String reverse = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 因为从后向前 可以直接返回 找到的第一个 一定是最长的相同前后缀</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = s.length(); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">			  <span class="comment">// 前缀等于后缀</span></span><br><span class="line">				<span class="keyword">if</span> (s.subString(<span class="number">0</span>, i).equals(reverse.subString(s.length() - i))) &#123;</span><br><span class="line">					<span class="comment">// 这个时候只需要加上 reverse 去除后缀的部分</span></span><br><span class="line">					<span class="keyword">return</span> reverse.subString(<span class="number">0</span>, s.length() - i) + s;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>kmp 思维</li>
</ul>
<p>上面采用前后缀的方式其实已经接近了 kmp 的思维方式，不过是比较朴素的解法，因为这个时候还可以进一步得到，实际上就是求原串的最长回文前缀，因为这样逆串，反转过来后，与其回文前缀相等的部分，可以直接消去。</p>
<p>那么可以直接拼接成一个最长的字符串，即 <code>s + &quot;#&quot; + reverse</code> 那么只需要找到这个字符串<code>结尾的部分相等的前后缀长度</code>，即可以在返回结果的时候删除重复的部分。所以可用 kmp 的 next 数组求法找到最长的前后缀，既可以将时间复杂度进一步降低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShortestPalindromeNew_214</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keep 春招就考的这个</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shortestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String reverse = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line"></span><br><span class="line">        String addedStr = s + <span class="string">&quot;#&quot;</span> + reverse;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = getMaxMatchLen(addedStr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverse.substring(<span class="number">0</span>, reverse.length() - len) + s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到从末尾开始的前后缀的最长匹配长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaxMatchLen</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[s.length() + <span class="number">1</span>];</span><br><span class="line">        next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = -<span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; s.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (k == -<span class="number">1</span> || s.charAt(k) == s.charAt(j)) &#123;</span><br><span class="line">                k++;</span><br><span class="line">                j++;</span><br><span class="line">                next[j] = k;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k = next[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><h3 id="找出最具竞争力的子序列"><a href="#找出最具竞争力的子序列" class="headerlink" title="找出最具竞争力的子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-the-most-competitive-subsequence/">找出最具竞争力的子序列</a></h3><p>找到其中的一个子序列，满足其字符串比较是最小的结果。</p>
<ul>
<li>brute-force </li>
</ul>
<p>其实查看题意的话，最主要的就是不停的找到最小的数字</p>
<ul>
<li>如果最小的数字 右侧的数字数量大于等于剩下要找的数量，说明继续向右侧寻找最小数</li>
<li>如果小于要找的数量，说明现在最小的数及其右侧所有的数字已经组成答案的一部分，因为这个最小数字形成的这个子序列一定是当前这个最小的</li>
<li>重复寻找上述过程，直到所有的数字被填充</li>
</ul>
<p>因此上述过程是一个递归的过程（递归超时，实际上如果能够保存 i -&gt; j 的最小值的位置的话，就不用在递归中每次寻找了，应该能节约很多时间）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同一个位置上的数字更小的 int[] 更具竞争力</span></span><br><span class="line"><span class="comment">// 问长度为 k 的 int[] 的最有竞争力的结果是什么</span></span><br><span class="line"><span class="comment">// 找到最小的 看后面的数 是否满足剩下的大小 不然就往前找 找到剩下的最小的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mostCompetitiveBruteForce(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k &gt; nums.length) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">		<span class="keyword">if</span> (k == nums.length) <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"></span><br><span class="line">		recursion(nums, res, <span class="number">0</span>, nums.length - <span class="number">1</span>, <span class="number">0</span>, res.length - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接使用递归 每次找到 i-&gt;j 的最小值 然后判断去什么其他地方填充即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] res, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span>;</span><br><span class="line">		<span class="keyword">int</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (nums[k] &lt; nums[min]) min = k;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 剩下的数字不足以填满 m</span></span><br><span class="line">		<span class="keyword">if</span> (j - min + <span class="number">1</span> &lt;= m - n + <span class="number">1</span>) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &gt;= min; k--) &#123;</span><br><span class="line">						res[m--] = nums[k];</span><br><span class="line">				&#125;</span><br><span class="line">				recursion(nums, res, i, min - <span class="number">1</span>, n, m);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 还足够填满 从剩下的里面取较小的数字 然后填满</span></span><br><span class="line">		res[n++] = nums[min];</span><br><span class="line">		recursion(nums, res, min + <span class="number">1</span>, j, n, m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>单调栈</li>
</ul>
<p>实际上题目寻找的是最小的数字形成的结果，那么可以用一个单调栈来保存前面的访问的数组，如果当前访问的数字比之前的数字小的话，说明应该从这个数字之后开始寻找，其结果也就是把之前的数组弹出栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] mostCompetitive(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">	<span class="keyword">if</span> (k &gt; nums.length) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">	<span class="keyword">if</span> (k == nums.length) <span class="keyword">return</span> nums;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">	<span class="comment">// 单调栈</span></span><br><span class="line">	Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> num = nums[i];</span><br><span class="line">			<span class="comment">// 如果当前数字比 stack 里面的要小 说明概要弹出</span></span><br><span class="line">			<span class="comment">// 或者num 后剩下的长度不够了就不能弹出了</span></span><br><span class="line">			<span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peekLast() &gt; num &amp;&amp; k - stack.size() &lt; nums.length - i) &#123;</span><br><span class="line">					stack.removeLast();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (stack.size() &lt; k) &#123;</span><br><span class="line">					stack.addLast(num);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	k--;</span><br><span class="line">	<span class="keyword">while</span> (k &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">			res[k] = stack.removeLast();</span><br><span class="line">			k--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="下一个更大元素-II"><a href="#下一个更大元素-II" class="headerlink" title="下一个更大元素 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/next-greater-element-ii/">下一个更大元素 II</a></h3><pre>
示例
输入: [1,2,1]
输出: [2,-1,2]
解释: 第一个 1 的下一个更大的数是 2；
数字 2 找不到下一个更大的数； 
第二个 1 的下一个最大的数需要循环搜索，结果也是 2。
</pre>

<p>用单调栈来保存之前遍历过的路径，之后访问的数字如果比路径上的数字大的话，说明对于栈中保存的路径上的数字下一个更大的数是当前访问的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">		<span class="comment">// 优化循环</span></span><br><span class="line">		<span class="keyword">int</span> n = nums.length;</span><br><span class="line">		<span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="comment">// 添加的默认值</span></span><br><span class="line">		Arrays.fill(res, -<span class="number">1</span>);</span><br><span class="line">		<span class="comment">// 单调栈保存 nums 中的下标</span></span><br><span class="line">		Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="comment">// 因为是循环数组 所以遍历到最后一个的时候 还要看其左侧的</span></span><br><span class="line">		<span class="comment">// 所以相当于是两倍长度</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				<span class="comment">// stack 里面放置的都是比 nums[i % n] 小的数 在其被弹出的时候 说明之后第一个比他大的数 就是访问的 nums[i % n]</span></span><br><span class="line">				<span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums[i % n] &gt; nums[stack.peek()]) &#123;</span><br><span class="line">						res[stack.pop()] = nums[i % n];</span><br><span class="line">				&#125;</span><br><span class="line">				stack.push(i % n);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="移调-k-位数字"><a href="#移调-k-位数字" class="headerlink" title="移调 k 位数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-k-digits/">移调 k 位数字</a></h3><blockquote>
<p>问如果在原始字符串中，移掉 k 位数字，最后形成的最小字符串是什么</p>
</blockquote>
<ol>
<li>如果 k 大于等于原来字符串的长度，那么就相当于删除了所有的数字，直接返回 “0” 即可</li>
<li>考虑 k 小于的情况<ul>
<li>既然要删除数字，先考虑删除一个数字的情况，如 45 中删除一个数字，那么结果就是<strong>删除5 保留4</strong>，考虑 54 也是<strong>删除5 保留4</strong></li>
<li>那既然如此，也就是说，从字符串中删除一个数字的话相当于<code>删除的数字之前的一个数替代当前这位数</code>，那么要使结果更小，<code>替代的这个数一定要小于之前的删除的那个数</code>，即 Dk &lt; D(k-1) 删除 Dk</li>
</ul>
</li>
</ol>
<ul>
<li>每次遍历删除一个数字</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeKdigitsDeleteOne</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 移除所有的数字</span></span><br><span class="line">		<span class="keyword">if</span> (k &gt;= num.length()) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">		<span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				num = deleteOne(num);</span><br><span class="line">				k--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 去除前导 0</span></span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; num.length()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (num.charAt(i) != <span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">				i++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; num.length()) &#123;</span><br><span class="line">				builder.append(num.charAt(i++));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> builder.length() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : builder.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">deleteOne</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num.length(); i++) &#123;</span><br><span class="line">				<span class="comment">// 现在可以删除 i - 1 这个位置的数了</span></span><br><span class="line">				<span class="keyword">if</span> (num.charAt(i) &lt; num.charAt(i - <span class="number">1</span>)) <span class="keyword">return</span> num.substring(<span class="number">0</span>, i - <span class="number">1</span>) + num.substring(i);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 删除最后一个数字</span></span><br><span class="line">		<span class="keyword">return</span> num.substring(<span class="number">0</span>, num.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>单调栈</li>
</ul>
<p>每次去删除的一个数字的时间效率太低，因此可以考虑用一个单调栈来保存<code>小于当前数的数字</code>，当遍历到的下标大于单调栈的尾时，说明前面的数字该删除了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">removeKdigits</span><span class="params">(String num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 移除所有的数字</span></span><br><span class="line">		<span class="keyword">if</span> (k &gt;= num.length()) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">		<span class="comment">// 删除数字的话 一定要删除的是 前面一个数字 大于 后面一个数字的地方</span></span><br><span class="line">		<span class="comment">// 因为这样才能在删除后保证剩下的形成更小的结果</span></span><br><span class="line">		Deque&lt;Character&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">char</span> c : num.toCharArray()) &#123;</span><br><span class="line">				<span class="comment">// 单调栈中保存之前的结果</span></span><br><span class="line">				<span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peekLast() &gt; c &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">						queue.removeLast();</span><br><span class="line">						k--;</span><br><span class="line">				&#125;</span><br><span class="line">				queue.add(c);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 剩下的 一定是一个从小到大的序列</span></span><br><span class="line">		<span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				k--;</span><br><span class="line">				queue.removeLast();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (queue.peekFirst() == <span class="string">&#x27;0&#x27;</span>) queue.removeFirst();</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">				builder.append(queue.removeFirst());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> builder.length() == <span class="number">0</span> ? <span class="string">&quot;0&quot;</span> : builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></h3><p>滑动窗口</p>
<ul>
<li>当前遍历的字符串没有包含所有字符的时候，右移右游标</li>
<li>然后左移左游标，直到不再包含该字符串</li>
<li>在移动窗口的时候不听比较即可</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkEqualMap</span><span class="params">(mapForT, window <span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> mapForT &#123;</span><br><span class="line">		<span class="keyword">if</span> count, ok := window[k]; !ok || count &lt; v &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minWindow</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	res := <span class="string">&quot;&quot;</span></span><br><span class="line">	mapForT := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, char := <span class="keyword">range</span> t &#123;</span><br><span class="line">		mapForT[char]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	window := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int32</span>]<span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j &lt; <span class="built_in">len</span>(s) || i &lt; j &#123;</span><br><span class="line">		<span class="keyword">for</span> j &lt; <span class="built_in">len</span>(s) &amp;&amp; !checkEqualMap(mapForT, window) &#123;</span><br><span class="line">			window[<span class="keyword">int32</span>(s[j])]++</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> checkEqualMap(mapForT, window) &amp;&amp; (res == <span class="string">&quot;&quot;</span> || <span class="built_in">len</span>(res) &gt; j-i) &#123;</span><br><span class="line">			res = s[i:j]</span><br><span class="line">		&#125;</span><br><span class="line">		window[<span class="keyword">int32</span>(s[i])]--</span><br><span class="line">		i++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回true 说明里面已经包含了一个完整的 t 字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkMap</span><span class="params">(HashMap&lt;Character, Integer&gt; mapForT, HashMap&lt;Character, Integer&gt; mapForS)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Character key : mapForT.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mapForS.containsKey(key) || mapForS.get(key) &lt; mapForT.get(key)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这都是不存在的</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || t == <span class="keyword">null</span> || s.length() &lt; t.length()) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String minStr = <span class="keyword">null</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; mapForT = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> character : t.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mapForT.containsKey(character)) &#123;</span><br><span class="line">                mapForT.put(character, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mapForT.put(character, mapForT.get(character) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character, Integer&gt; mapForS = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">            Character character = s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!mapForS.containsKey(character)) &#123;</span><br><span class="line">                mapForS.put(character, <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mapForS.put(character, mapForS.get(character) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 滑动窗口大小</span></span><br><span class="line">        <span class="keyword">int</span> left  = <span class="number">0</span>, right = t.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (checkMap(mapForT, mapForS) &amp;&amp; right - left + <span class="number">1</span> &gt;= t.length()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minStr == <span class="keyword">null</span> || minStr.length() &gt; right - left + <span class="number">1</span>) &#123;</span><br><span class="line">                    minStr = s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mapForS.put(s.charAt(left), mapForS.get(s.charAt(left)) - <span class="number">1</span>);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span> (right &gt;= s.length()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (!mapForS.containsKey(s.charAt(right))) &#123;</span><br><span class="line">                mapForS.put(s.charAt(right), <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mapForS.put(s.charAt(right), mapForS.get(s.charAt(right)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (right &lt;= s.length() - <span class="number">1</span> &amp;&amp; right - left + <span class="number">1</span> &gt; t.length());</span><br><span class="line">        <span class="keyword">return</span> minStr == <span class="keyword">null</span> ? <span class="string">&quot;&quot;</span> : minStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="K-个不同整数的子数组"><a href="#K-个不同整数的子数组" class="headerlink" title="K 个不同整数的子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/subarrays-with-k-different-integers/">K 个不同整数的子数组</a></h3><p>找到 A 里面的连续子数组，其中子数组里面的数据的 distinct 只有 K 个</p>
<p>这个题目一想就是滑动窗口</p>
<p>但是 很不好计算 等于 K 的时候 数组有多少个</p>
<p>但是计算 小于等于 K 的比较好计算，可以依据以下规则</p>
<p>以 [1,2,1,2,3] 为例，左边界固定的时候，恰好存在 2 个不同整数的子区间为 [1,2],[1,2,1],[1,2,1,2]，总数为 3。其值为下标 3 - 1 + 1，即区间 [1..3] 的长度。</p>
<p>因为，left, right 同时圈定了一组满足 &lt;= k 的题意的长度范围</p>
<p>那么，包含 left 的子数组数量肯定是 right - left + 1，因为相当于每次给数组里面添加一个数([1,2] [1,2,1] [1,2,1,2]) 所以 right 比 left 多几个数 就能形成几个子数组</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subarraysWithKDistinct</span><span class="params">(A []<span class="keyword">int</span>, K <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> atMostK(A, K) - atMostK(A, K<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为求解 恰好K 不好弄 求解 最大K 比较好弄</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">atMostK</span><span class="params">(A []<span class="keyword">int</span>, K <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="comment">// 作为一个 set 保存窗口内的所有 distinct 数据</span></span><br><span class="line">	window := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">int</span>)</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> j &lt; <span class="built_in">len</span>(A) &#123;</span><br><span class="line">		window[A[j]]++</span><br><span class="line">		j++</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(window) &gt; K &#123;</span><br><span class="line">			window[A[i]]--</span><br><span class="line">			<span class="keyword">if</span> window[A[i]] == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="built_in">delete</span>(window, A[i])</span><br><span class="line">			&#125;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		res += j - i + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubarraysWithKDistinct_992</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 A 里面</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subarraysWithKDistinct</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> subArraysDistinctAtMostK(A, K) - subArraysDistinctAtMostK(A, K - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算最多的有多少个的话 可以固定左边界 然后计算</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">subArraysDistinctAtMostK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; window = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; array.length) &#123;</span><br><span class="line">            <span class="comment">// 固定左边界 移动右边界</span></span><br><span class="line">            window.put(array[right], window.getOrDefault(array[right], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 这边已经需要减除了</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right &amp;&amp; window.size() &gt; k) &#123;</span><br><span class="line">                window.put(array[left], window.get(array[left]) - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (window.get(array[left]) == <span class="number">0</span>) window.remove(array[left]);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这个地方是因为右边界到左边之间的数字 一定是小于等于 K 个不同的数字的</span></span><br><span class="line">            <span class="comment">// 那么能够以左边界形成的 一定是中的一个子数组 如</span></span><br><span class="line">            <span class="comment">// 以 [1,2,1,2,3] 为例，左边界固定的时候，恰好存在 2 个不同整数的子区间为 [1,2],[1,2,1],[1,2,1,2]，总数为 3。其值为下标 3 - 1 + 1，即区间 [1..3] 的长度。</span></span><br><span class="line">            res += right - left;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SubarraysWithKDistinct_992().subarraysWithKDistinct(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, <span class="number">2</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> SubarraysWithKDistinct_992().subarraysWithKDistinct(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大连续-1-的个数-III"><a href="#最大连续-1-的个数-III" class="headerlink" title="最大连续 1 的个数 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/">最大连续 1 的个数 III</a></h3><p>最大连续 1 的个数，A 中只有 0 和 1，其中可以变换最多 K 个 0 成为 1，问最长的连续 1 的长度为多少</p>
<p>滑动窗口，窗口中最多含有 K 个 0 即可</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestOnes</span><span class="params">(A []<span class="keyword">int</span>, K <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 返回值</span></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	zeros := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> right &lt; <span class="built_in">len</span>(A) &#123;</span><br><span class="line">		<span class="comment">// 用外层循环带动 right 移动</span></span><br><span class="line">		<span class="keyword">if</span> A[right] == <span class="number">0</span> &#123;</span><br><span class="line">			zeros++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这个时候要移动左侧的 left 保障 zeros 小</span></span><br><span class="line">		<span class="keyword">for</span> zeros &gt; K &#123;</span><br><span class="line">			<span class="keyword">if</span> A[left] == <span class="number">0</span> &#123;</span><br><span class="line">				zeros--</span><br><span class="line">			&#125;</span><br><span class="line">			left++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 每轮都去比较即可</span></span><br><span class="line">		res = max(res, right - left + <span class="number">1</span>)</span><br><span class="line">		right++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="绝对差不超过限制的最长连续子数组"><a href="#绝对差不超过限制的最长连续子数组" class="headerlink" title="绝对差不超过限制的最长连续子数组"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/">绝对差不超过限制的最长连续子数组</a></h3><blockquote>
<p>给定一个数组 nums 和 limit，找到最长的连续数组，其中任意两个数的差值不超过 limit</p>
</blockquote>
<p>上面这句话换个说法说的就是 最大值和最小值 之差不超过 limit，因此如果能够 o(1) 的拿到窗口的 最大最小值，那么就比较方便</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classic</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MaxMinQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	stack1 MaxMinStack</span><br><span class="line">	stack2 MaxMinStack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *MaxMinQueue)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	queue.stack1.Push(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *MaxMinQueue)</span> <span class="title">Shift</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> queue.stack2.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> queue.stack1.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			queue.stack2.Push(queue.stack1.Pop())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> queue.stack2.Pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *MaxMinQueue)</span> <span class="title">Max</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> queue.stack1.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> queue.stack2.Max()</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> queue.stack2.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> queue.stack1.Max()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max(queue.stack2.Max(), queue.stack1.Max())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *MaxMinQueue)</span> <span class="title">Min</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> queue.stack1.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> queue.stack2.Min()</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> queue.stack2.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> queue.stack1.Min()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> min(queue.stack2.Min(), queue.stack1.Min())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *MaxMinQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> queue.stack1.Len() + queue.stack2.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MaxMinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 这两个不用 slice 用 list 之类的链表 可能会快一点儿</span></span><br><span class="line">	data  []<span class="keyword">int</span></span><br><span class="line">	maxes []<span class="keyword">int</span></span><br><span class="line">	mins  []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *MaxMinStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	ms.data = <span class="built_in">append</span>(ms.data, val)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ms.maxes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		ms.maxes = <span class="built_in">append</span>(ms.maxes, max(ms.maxes[<span class="built_in">len</span>(ms.maxes)<span class="number">-1</span>], val))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ms.maxes = <span class="built_in">append</span>(ms.maxes, val)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ms.mins) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		ms.mins = <span class="built_in">append</span>(ms.mins, min(ms.mins[<span class="built_in">len</span>(ms.mins)<span class="number">-1</span>], val))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ms.mins = <span class="built_in">append</span>(ms.mins, val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *MaxMinStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := ms.data[<span class="built_in">len</span>(ms.data)<span class="number">-1</span>]</span><br><span class="line">	ms.data = ms.data[:<span class="built_in">len</span>(ms.data)<span class="number">-1</span>]</span><br><span class="line">	ms.maxes = ms.maxes[:<span class="built_in">len</span>(ms.maxes)<span class="number">-1</span>]</span><br><span class="line">	ms.mins = ms.mins[:<span class="built_in">len</span>(ms.mins)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *MaxMinStack)</span> <span class="title">Max</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ms.maxes[<span class="built_in">len</span>(ms.maxes)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *MaxMinStack)</span> <span class="title">Min</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ms.mins[<span class="built_in">len</span>(ms.mins)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *MaxMinStack)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(ms.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到一个最长的连续子数组 其任意两个元素之间的差值 小于等于 limit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">longestSubarray</span><span class="params">(nums []<span class="keyword">int</span>, limit <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 就是维护一个 queue 为了方便 应该在 o(1) 的时间内获得其 最大最小值</span></span><br><span class="line">	left, right := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	window := &amp;MaxMinQueue&#123;stack1: MaxMinStack&#123;&#125;, stack2: MaxMinStack&#123;&#125;&#125;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> right &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		window.Push(nums[right])</span><br><span class="line">		<span class="keyword">if</span> window.Len() &gt; <span class="number">0</span> &amp;&amp; window.Max() - window.Min() &lt;= limit &#123;</span><br><span class="line">			res = max(res, right - left + <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> window.Len() &gt; <span class="number">0</span> &amp;&amp; window.Max() - window.Min() &gt; limit &#123;</span><br><span class="line">			window.Shift()</span><br><span class="line">			left++</span><br><span class="line">		&#125;</span><br><span class="line">		right++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="爱生气的书店老板"><a href="#爱生气的书店老板" class="headerlink" title="爱生气的书店老板"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/grumpy-bookstore-owner/">爱生气的书店老板</a></h3><p>给定一个 grumpy 以及 custormers 在 grumpy == 0 的时候 可以加上 custormers 的对应值，问如果有连续的 X 个 gurmpy 可以为 0 最大 customers 的和为多少</p>
<ul>
<li>自己的做法</li>
</ul>
<p>维护一个前缀和数组 sum，表示前 i 个的和为多少，那么就可以用滑动窗口将数组分为三段</p>
<p>[0-&gt;l](可以用 sum 数组求得) [l-&gt;r](全部变为 0 所以是直接求和的) [r-&gt;len](可以用 sum 数组求得)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSatisfiedWithSumArray</span><span class="params">(<span class="keyword">int</span>[] customers, <span class="keyword">int</span>[] grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// sum[i] 保存 customers[i] 之前的所有满足要求的和</span></span><br><span class="line">		<span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[customers.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= customers.length; i++) &#123;</span><br><span class="line">				sum[i] = sum[i - <span class="number">1</span>];</span><br><span class="line">				<span class="keyword">if</span> (grumpy[i - <span class="number">1</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">						sum[i] += customers[i - <span class="number">1</span>];</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 结果</span></span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 维护一个窗口 这个窗口长度为 X 全部认为是可以加的</span></span><br><span class="line">		<span class="keyword">int</span> windowSum = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; i++) &#123;</span><br><span class="line">				windowSum += customers[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = X; i &lt; customers.length; i++) &#123;</span><br><span class="line">				res = Math.max(res, sum[i-X] + windowSum + sum[customers.length] - sum[i]);</span><br><span class="line">				windowSum = windowSum - customers[i - X] + customers[i];</span><br><span class="line">		&#125;</span><br><span class="line">		res = Math.max(res, sum[customers.length-X] + windowSum);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>题解</li>
</ul>
<p>题解更进一步，将 customers 数组根据 grumpy 的取值分为两类，一类是 grumpy 等于 1 那么是可以直接加上的，一类是 grumpy == 0，可以在长度为 X 的滑动窗口中 increase 到 第一类的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSatisfied</span><span class="params">(<span class="keyword">int</span>[] customers, <span class="keyword">int</span>[] grumpy, <span class="keyword">int</span> X)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 分两步计算 一个计算满足要求的所有和 total 另一个窗口可以额外增加的值</span></span><br><span class="line">		<span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; customers.length; i++) &#123;</span><br><span class="line">				<span class="comment">// grumpy[i] == 0 的时候 才加上</span></span><br><span class="line">				total += (<span class="number">1</span> - grumpy[i]) * customers[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历可以增加的值 找到最大的</span></span><br><span class="line">		<span class="keyword">int</span> window = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 窗口遍历可以增加的值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; X; i++) &#123;</span><br><span class="line">				<span class="comment">// 窗口可以增加的值 是 grumpy[i] == 1</span></span><br><span class="line">				window += grumpy[i] * customers[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> res = window;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = X; i &lt; customers.length; i++) &#123;</span><br><span class="line">				window = window - grumpy[i-X] * customers[i-X] + grumpy[i] * customers[i];</span><br><span class="line">				res = Math.max(res, window);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> total + res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="二进制题目"><a href="#二进制题目" class="headerlink" title="二进制题目"></a>二进制题目</h2><h3 id="连接连续二进制数字"><a href="#连接连续二进制数字" class="headerlink" title="连接连续二进制数字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/concatenation-of-consecutive-binary-numbers/">连接连续二进制数字</a></h3><p>题目要求的是将 1 -&gt; n 的二进制的字符拼接起来表示一个超大的二进制数，然后将 二进制 数转换成为 十进制 数，并模上 1000000007。</p>
<p>如果直接把每个数字转换成为二进制数，然后拼接转换，因为会超时，因为 n 的返回达到了 10^5。</p>
<p>所以考虑在遍历的时候直接对每一位数进行处理。</p>
<p>观察事例，可以看到其实相当于 1(1) &lt;&lt; 4 位数 10(2) &lt;&lt; 2 11(3) 不变，所以只需要在每个数字遍历的时候，<code>将上一个数字形成的结果左移当前数字对应的二进制的位数的长度，加上该数即可</code></p>
<pre>
n = 3, res = 27
二进制表示为 1 -> <span style="color: red">1</span>, 2 -> <span style="color: blue">10</span>, 3 -> <span style="color: green">11</span>
27 二进制表示为 <span style="color: red">1</span><span style="color: blue">10</span><span style="color: green">11</span>
</pre>

<p>计算二进制数的长度的时候，可以简单的采用遍历的方式进行。</p>
<ul>
<li>[1] 一位数长度</li>
<li>[2,3] 二位数长度</li>
<li>[4,……,7] 三位数长度</li>
<li>[8,……,15] 四位数长度</li>
</ul>
<p>也就是说，长度也是一个可以从上一个长度推断来的，每次需要新增长度的时候，都是形成 2 的幂 的形成，可以用 i &amp; (i - 1) 来快速的判断 2 的幂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只需要知道遍历的 n 的位数的长度即可</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">concatenatedBinary</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> shift = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 因为要返回的是 1 - n 的数字的二进制的组合形成的大数字的十进制数</span></span><br><span class="line">		<span class="comment">// 比如 1 2 3 组成的 1 10 11 返回 27</span></span><br><span class="line">		<span class="comment">// 相当于 首先访问 1 结果为 1</span></span><br><span class="line">		<span class="comment">// 访问 2 然后 1 左移两位 再加上 2</span></span><br><span class="line">		<span class="comment">// 访问 3 上一步的结果 再左移两位 加上 3</span></span><br><span class="line">		<span class="comment">// 所以对于每一个数字来说 实际上只需要让上一次的结果 不停的左移它的二进制的位数长度即可</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				<span class="comment">// 因为二的幂次方为 1000 的形式</span></span><br><span class="line">				<span class="comment">// 所以一旦知道现在的 i 为 2 的幂次方 就需要 shift++</span></span><br><span class="line">				<span class="keyword">if</span> ((i &amp; (i - <span class="number">1</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">						shift++;</span><br><span class="line">				&#125;</span><br><span class="line">				res = ((res &lt;&lt; shift) + i) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">int</span>) res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模拟除法"><a href="#模拟除法" class="headerlink" title="模拟除法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/divide-two-integers/">模拟除法</a></h3><p>不能使用<strong>乘法、除法和 mod 运算符</strong>。</p>
<p>除法的本质，以 10 / 3 为例</p>
<p>10 / 3 = 3 …… 1 (即为 3 个 3 相乘 余 1)</p>
<p>即为 10 - (3 _ 2) - (3 _ 1) = 1 其结果为 2 + 1 为 3</p>
<p>也就是说任意一种除法可以用一组除数的 2 的次方的乘积的结果来表示。</p>
<p>如 100 / 15 = 6</p>
<p>100 - (15 _ 4) - (15 _ 2)</p>
<p>所以可以采用二进制的方法来做，每次用被除数减去最大的一个除数的 2 次方的乘积，循环，直到剩下余数或者 0</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">divide</span><span class="params">(dividend <span class="keyword">int</span>, divisor <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> divisor == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span> - <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	minus := <span class="number">-1</span></span><br><span class="line">	<span class="keyword">if</span> (dividend &lt; <span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>) || (dividend &gt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		minus = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	absDividend, absDivisor := <span class="keyword">int64</span>(math.Abs(<span class="keyword">float64</span>(dividend))), <span class="keyword">int64</span>(math.Abs(<span class="keyword">float64</span>(divisor)))</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> absDividend &gt;= absDivisor &#123;</span><br><span class="line">		tmp, multi := absDivisor, <span class="number">1</span></span><br><span class="line">		<span class="keyword">for</span> (tmp &lt;&lt; <span class="number">1</span>) &lt; absDividend &#123;</span><br><span class="line">			tmp &lt;&lt;= <span class="number">1</span></span><br><span class="line">			multi &lt;&lt;= <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		absDividend -= tmp</span><br><span class="line">		res += multi</span><br><span class="line">		<span class="keyword">if</span> minus &gt; <span class="number">0</span> &amp;&amp; res &gt;= math.MaxInt32 &#123;</span><br><span class="line">			<span class="keyword">return</span> math.MaxInt32</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> minus &lt; <span class="number">0</span> &amp;&amp; minus * res &lt;= math.MinInt32 &#123;</span><br><span class="line">			<span class="keyword">return</span>  math.MinInt32</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> minus * res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">divide</span><span class="params">(<span class="keyword">int</span> dividend, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(divisor == <span class="number">0</span> || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>)) <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sign;</span><br><span class="line">        <span class="keyword">if</span> ((dividend &gt; <span class="number">0</span> &amp;&amp; divisor &gt; <span class="number">0</span>) || (dividend &lt; <span class="number">0</span> &amp;&amp; divisor &lt; <span class="number">0</span>)) sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> sign = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> dvd=Math.abs((<span class="keyword">long</span>)dividend);</span><br><span class="line">        <span class="keyword">long</span> dvs=Math.abs((<span class="keyword">long</span>)divisor);</span><br><span class="line">        <span class="keyword">while</span> (dvd &gt;= dvs) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> temp = dvs, m = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (temp &lt;&lt; <span class="number">1</span> &lt; dvd) &#123;</span><br><span class="line">                temp &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">                m &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            res += m;</span><br><span class="line">            dvd -= temp;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只出现一次的数字-II"><a href="#只出现一次的数字-II" class="headerlink" title="只出现一次的数字 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-ii/">只出现一次的数字 II</a></h3><p>数组中的数组只有出现 1 次（一个数字）的和 3 次的数字，找到只出现一次的那个数字</p>
<p>其实就是计算每一位数字出现的次数 % 3</p>
<p>注意 goland 默认的 int 可能值得是 int64 所以强制指定为 32 为长度的 int32 不然没办法处理负数的情况</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> res <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> count <span class="keyword">int32</span></span><br><span class="line">		<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">			count += (<span class="keyword">int32</span>(num )&gt;&gt; i) &amp; <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		res += (count % <span class="number">3</span>) &lt;&lt; i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">int</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="只出现一次的数字-III"><a href="#只出现一次的数字-III" class="headerlink" title="只出现一次的数字 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/single-number-iii/">只出现一次的数字 III</a></h3><p>一组数字 其中只有两个数字 出现一次 其余出现两次</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumberIII</span><span class="params">(nums []<span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果两个出现一次的数 不同 肯定不为 0</span></span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		sum ^= num</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 那么根据 sum 的某一个不为 0 的位数来分离两类数</span></span><br><span class="line">	counter := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> sum &amp; <span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">		sum &gt;&gt;= <span class="number">1</span></span><br><span class="line">		counter &lt;&lt;= <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找到了这个位数 根据 位数 分成两组即可</span></span><br><span class="line">	num1, num2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="comment">// 根据位数分离两类数</span></span><br><span class="line">		<span class="keyword">if</span> num &amp; counter == <span class="number">0</span> &#123;</span><br><span class="line">			num1 ^= num</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			num2 ^= num</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="keyword">int</span>&#123;num1, num2&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数字按位与"><a href="#数字按位与" class="headerlink" title="数字按位与"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/submissions/">数字按位与</a></h3><p>要求求 m -&gt; n 的范围内的所有数字的 按位与 的结果，因为范围比较大，直接 &amp; 会超时</p>
<p>考虑 3 -&gt; 11 这个范围的数字，红色的 就是相同的二进制前缀部分 实际上就是找到这部分前缀</p>
<pre>
<span style="color: red">00</span>1011      11
<span style="color: red">00</span>1010      10
<span style="color: red">00</span>1001      09
<span style="color: red">00</span>1000      08
<span style="color: red">00</span>0111      07
<span style="color: red">00</span>0110      06
<span style="color: red">00</span>0101      05
<span style="color: red">00</span>0100      04
<span style="color: red">00</span>0011      03
</pre>

<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rangeBitwiseAnd</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> m == n &#123;</span><br><span class="line">		<span class="keyword">return</span> m</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 考虑 [5,6,7] 三个数 &amp; 起来的话 实际上是 考虑 最大值 和 最小值的 左侧相等的部分是多少</span></span><br><span class="line">	<span class="comment">// mov 记录移位了多少次 然后再移动回来</span></span><br><span class="line">	mov := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> m != n &#123;</span><br><span class="line">		m &gt;&gt;= <span class="number">1</span></span><br><span class="line">		n &gt;&gt;= <span class="number">1</span></span><br><span class="line">		mov++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> m &lt;&lt; mov</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="最后一块石头的重量-II"><a href="#最后一块石头的重量-II" class="headerlink" title="最后一块石头的重量 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/explore/interview/card/2020-top-interview-questions/280/array/1255/">最后一块石头的重量 II</a></h3><p>其实就是问是否能够形成相等的两部分, 用一个 dp[i][j] 表示前 i 个的能否形成和为 j 的数值，在遍历的时候就可以找到最大的和为多少，之后就减去最大的和即可</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classic</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这道题题干 要求 stones 两两相撞 剩下一块儿 为剩下的石头 最小能形成的重量</span></span><br><span class="line"><span class="comment">// 其实就是问是否能够形成相等的两部分 因为相等的话 最后形成的石头 为 0</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastStoneWeightII</span><span class="params">(stones []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	sum := getStonesSum(stones)</span><br><span class="line">	<span class="comment">// dp[i][j] 表示前 i 个能否形成 何为 j</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="keyword">bool</span>, <span class="built_in">len</span>(stones)+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="keyword">bool</span>, sum/<span class="number">2</span>+<span class="number">1</span>)</span><br><span class="line">		<span class="comment">// 合为0一定可以</span></span><br><span class="line">		dp[i][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	maxSum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(stones); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= sum/<span class="number">2</span>; j++ &#123;</span><br><span class="line">			<span class="comment">// 因为表示的前 i 能不能形成 j 所以 i-1 能形成的话 也是可以的</span></span><br><span class="line">			dp[i][j] = dp[i][j] || dp[i<span class="number">-1</span>][j]</span><br><span class="line">			<span class="keyword">if</span> j &gt;= stones[i<span class="number">-1</span>] &#123;</span><br><span class="line">				dp[i][j] = dp[i][j] || dp[i<span class="number">-1</span>][j-stones[i<span class="number">-1</span>]]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> dp[i][j] &#123;</span><br><span class="line">				maxSum = max(maxSum, j)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum - <span class="number">2</span> * maxSum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getStonesSum</span><span class="params">(stones []<span class="keyword">int</span>)</span> <span class="params">(sum <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> _, w := <span class="keyword">range</span> stones &#123;</span><br><span class="line">		sum += w</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最长子序列套题"><a href="#最长子序列套题" class="headerlink" title="最长子序列套题"></a>最长子序列套题</h3><h4 id="最长上升子序列"><a href="#最长上升子序列" class="headerlink" title="最长上升子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">最长上升子序列</a></h4><p>找到非连续的递增子序列，那么我就只需要知道 在我之前的小于我的数字的上升子序列长度为多少</p>
<p>即实际上只需要在访问数组的时候 0 ≤ i &lt; j &lt; nums.length，只需要知道 i 下标对应的最长的子序列是<strong>多少即可。</strong></p>
<p>这样就变成了一个 dp 问题，小问题就是解决的以 nums[i] 结尾的最长的上升子序列的长度</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLIS</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// dp[i] 表示 nums[i] 结尾的最长的递增子序列长度为多少</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	<span class="comment">// 初始化 一个数字肯定是递增的</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> num &gt; nums[j] &#123;</span><br><span class="line">				dp[i] = max(dp[i], dp[j]+<span class="number">1</span>)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		res = max(res, dp[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最长上升子序列数量"><a href="#最长上升子序列数量" class="headerlink" title="最长上升子序列数量"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/">最长上升子序列数量</a></h4><p>与上面那个类似 也是一个 dp 问题 只是需要在 dp 遍历的时候 知道 对应最长长度 对应的 LIS 有多少个</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 LIS 对应的长度的子序列有多少个</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNumberOfLIS</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 保存 nums[i] 结尾的 LIS 的长度</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	<span class="comment">// 保存 nums[i] 结尾的 LIS 的最长 LIS 的长度</span></span><br><span class="line">	counts := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span></span><br><span class="line">		counts[i] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maxLen := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">			<span class="comment">// 形成 递增</span></span><br><span class="line">			<span class="keyword">if</span> nums[j] &lt; nums[i] &#123;</span><br><span class="line">				<span class="keyword">if</span> dp[i] &lt;= dp[j] &#123;</span><br><span class="line">					<span class="comment">// 说明 j 的长度比这个长</span></span><br><span class="line">					dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">					counts[i] = counts[j]</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> dp[j]+<span class="number">1</span> == dp[i] &#123;</span><br><span class="line">					<span class="comment">// 长度相差 1 说明这个时候 counts 要 + 上 j 的</span></span><br><span class="line">					counts[i] += counts[j]</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		maxLen = max(maxLen, dp[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, count := <span class="keyword">range</span> counts &#123;</span><br><span class="line">		<span class="keyword">if</span> maxLen == dp[i] &#123;</span><br><span class="line">			res += count</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="摆动序列"><a href="#摆动序列" class="headerlink" title="摆动序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/wiggle-subsequence/">摆动序列</a></h3><p>找到摆动序列（摆动序列是一升一降的序列，即前后相减为一正一负）参考注释即可 (这个题目不要求连续 所以还需要不停的保存前一个状态 不用初始化)</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个数组分别代表上升和下降序列的最大长度</span></span><br><span class="line"><span class="comment">// 因为 wiggle 的数组 是一升一降 的 up[i] 表示 最后一个 nums[i] 是上升的趋势的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wiggleMaxLengthWithoutMemo</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// up[i] down[i] 分别代表上升和下降序列(最后一个是上升或者下降)的 在 index = i 时的最长长度</span></span><br><span class="line">	ups, downs := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)), <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	<span class="comment">// 初始化</span></span><br><span class="line">	ups[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	downs[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			<span class="comment">// 如果 nums i 是上升趋势 说明那么 之前前一个是下降的趋势的话 可以 加一</span></span><br><span class="line">			<span class="comment">// 同时 也可以不考虑这个 上升趋势 跟前一个比较</span></span><br><span class="line">			ups[i] = max(downs[i<span class="number">-1</span>]+<span class="number">1</span>, ups[i<span class="number">-1</span>])</span><br><span class="line">			<span class="comment">// 此时由于是上升的 所以没有下降的趋势 状态直接转移</span></span><br><span class="line">			downs[i] = downs[i<span class="number">-1</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] &lt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			downs[i] = max(ups[i<span class="number">-1</span>]+<span class="number">1</span>, downs[i<span class="number">-1</span>])</span><br><span class="line">			ups[i] = ups[i<span class="number">-1</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 相等的情况下是不变的</span></span><br><span class="line">			ups[i] = ups[i<span class="number">-1</span>]</span><br><span class="line">			downs[i] = downs[i<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max(ups[<span class="built_in">len</span>(ups)<span class="number">-1</span>], downs[<span class="built_in">len</span>(downs)<span class="number">-1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为只依赖前一个状态 因此可以压缩状态</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个数组分别代表上升和下降序列的最大长度</span></span><br><span class="line"><span class="comment">// 因为 wiggle 的数组 是一升一降 的 up[i] 表示 最后一个 nums[i] 是上升的趋势的最大值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">wiggleMaxLength</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	up, down := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		preDown, PreUp := down, up</span><br><span class="line">		<span class="keyword">if</span> nums[i] &gt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			up = max(down+<span class="number">1</span>, up)</span><br><span class="line">			down = preDown</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i] &lt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">			down = max(up+<span class="number">1</span>, down)</span><br><span class="line">			up = PreUp</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			up = PreUp</span><br><span class="line">			down = preDown</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max(up, down)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类似摆动序列的题目-978-最长湍流子数组"><a href="#类似摆动序列的题目-978-最长湍流子数组" class="headerlink" title="类似摆动序列的题目 978. 最长湍流子数组"></a>类似摆动序列的题目 <a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/longest-turbulent-subarray/">978. 最长湍流子数组</a></h3><p>找到一个<code>连续的子数组</code>能够满足</p>
<p>当 A  的子数组  A[i], A[i+1], …, A[j]  满足下列条件时，我们称其为湍流子数组：</p>
<p>若  i &lt;= k &lt; j，当 k  为奇数时， A[k] &gt; A[k+1]，且当 k 为偶数时，A[k] &lt; A[k+1]；<br>或 若  i &lt;= k &lt; j，当 k 为偶数时，A[k] &gt; A[k+1] ，且当 k  为奇数时， A[k] &lt; A[k+1]。<br>也就是说，如果<strong>比较符号在子数组中的每个相邻元素对之间翻转</strong>，则该子数组是湍流子数组。</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxTurbulenceSize</span><span class="params">(arr []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 仍然是一升一降 才能使符号反号</span></span><br><span class="line"></span><br><span class="line">	up, down := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">	res := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &gt; arr[i<span class="number">-1</span>] &#123;</span><br><span class="line">			up = down+<span class="number">1</span></span><br><span class="line">			<span class="comment">// 因为是要连续的 一升一降 所以这个地方需要重新初始化为 1</span></span><br><span class="line">			down = <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> arr[i] &lt; arr[i<span class="number">-1</span>] &#123;</span><br><span class="line">			down = up + <span class="number">1</span></span><br><span class="line">			up = <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			up, down = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为重新初始化 所以需要对每一个状态进行比较保存</span></span><br><span class="line">		res = max(res, max(up, down))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="俄罗斯套娃信封问题"><a href="#俄罗斯套娃信封问题" class="headerlink" title="俄罗斯套娃信封问题"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/russian-doll-envelopes/">俄罗斯套娃信封问题</a></h3><p>根据信封的宽度和高度 判断能够装下的信封的最大长度有多少</p>
<p>高度和宽度均小于另外一个信封的 可以装进去</p>
<p>实际上是一个 找到最长递增序列的问题</p>
<ul>
<li>按照宽度进行排序，这样从一个维度上看 所有的信封都是宽度有序的</li>
<li>再次基础上 如果要前一个信封能够装在后一个信封里面 说明长度是一个逆序的</li>
<li>最后只需要在这个排序的数组里面 找到长度的一个最长递增序列即可</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxEnvelopes</span><span class="params">(envelopes [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// envelopes[0] 相等 说明宽度相等 这个时候 只需要更长的排在后面即可</span></span><br><span class="line">	<span class="comment">// envelopes[0] 不等 说明宽度不等 这个时候 只需要只需要根据长度大小从大到小排序即可</span></span><br><span class="line">	sort.Slice(envelopes, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> envelopes[i][<span class="number">0</span>] == envelopes[j][<span class="number">0</span>] &#123;</span><br><span class="line">			<span class="keyword">return</span> envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> envelopes[i][<span class="number">0</span>] &lt; envelopes[j][<span class="number">0</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为现在这样排序之后 信封的宽度 一定是满足顺序的 那么只需要判断长度 能够形成的最长的递增子序列是多长</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(envelopes))</span><br><span class="line">	<span class="comment">// 1 个数字也能有一个长度</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">		dp[i] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(dp); i++ &#123;</span><br><span class="line">		tmp := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> envelopes[i][<span class="number">1</span>] &gt; envelopes[j][<span class="number">1</span>] &#123;</span><br><span class="line">				tmp = max(tmp, dp[j])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		dp[i] = tmp + <span class="number">1</span></span><br><span class="line">		res = max(res, dp[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解码方法"><a href="#解码方法" class="headerlink" title="解码方法"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/decode-ways/">解码方法</a></h3><p>这道题是入门的动态规划 只要知道 前一个和前前个的状态，就可以转移到下一个状态</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDecodings</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// dp[i] 表示 s[0:i] 不包括i能生成的数量</span></span><br><span class="line">	<span class="comment">// dp[i] = dp[i-1]+dp[i-2]</span></span><br><span class="line">	<span class="comment">// 因为只要当前的这个 sting 能够被 decoding 说明只要加上前面的数量即可</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(s) + <span class="number">1</span>)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	<span class="comment">// 表示的每次遍历的string的尾部</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := max(i - <span class="number">2</span>, <span class="number">0</span>); j &lt; i; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> canDecoding(s[j:i]) &#123;</span><br><span class="line">				dp[i] += dp[j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="built_in">len</span>(s)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canDecoding</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">1</span> &amp;&amp; s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> num, err := strconv.Atoi(s); err != <span class="literal">nil</span> || num &gt; <span class="number">26</span> || num &lt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h3><h4 id="不同的子序列"><a href="#不同的子序列" class="headerlink" title="不同的子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/distinct-subsequences/">不同的子序列</a></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numDistinct</span><span class="params">(s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// dp[i][j] 表示 s[i-1] 和 t[j-1] 之间有多少组合</span></span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(t)+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 初始化 只要 t 是空 那么一定可以 在 s 中找到</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="built_in">len</span>(t); j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> s[i<span class="number">-1</span>] == t[j<span class="number">-1</span>] &#123;</span><br><span class="line">				<span class="comment">// 分为两个部分 因为可以不算当前的 s 串的最后一个 也可以算上</span></span><br><span class="line">				<span class="comment">// 因为 s 串的前面部分 可能已经匹配到了</span></span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + dp[i<span class="number">-1</span>][j]</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				dp[i][j] = dp[i<span class="number">-1</span>][j]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> dp[<span class="built_in">len</span>(s)][<span class="built_in">len</span>(t)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="打家劫舍系列题"><a href="#打家劫舍系列题" class="headerlink" title="打家劫舍系列题"></a>打家劫舍系列题</h3><h4 id="打家劫舍-I"><a href="#打家劫舍-I" class="headerlink" title="打家劫舍 I"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber/">打家劫舍 I</a></h4><p>这道题是经典的 dp 问题。题目要求的是不能抢劫相邻的位置，那么这种条件下的最大和是多少。</p>
<ul>
<li>一个位置会有两个状态，拿当前这个地方的值 或者 不拿</li>
<li>下个位置的状态就会由上一个位置决定<ul>
<li>如果当前位置拿了值的话，上一个位置只能不拿</li>
<li>如果当前位置没有拿，上一个位置只需要取拿 or 不拿的 较大值</li>
</ul>
</li>
</ul>
<p>优化下 dp 数组 其实可以用一对值表示前面一个循环中拿了的最大值即可</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 优化的目的在于去掉数组 因为现在直接最大的就是</span></span><br><span class="line">	notRob, rob := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		rm := rob</span><br><span class="line">		rob = notRob + num</span><br><span class="line">		notRob = max(notRob, rm)</span><br><span class="line">		res = max(notRob, rob)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打家劫舍-II"><a href="#打家劫舍-II" class="headerlink" title="打家劫舍 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-ii/">打家劫舍 II</a></h4><p>这个是打劫的循环数组，因为 rob 了第一个 就不能 rob 最后一个</p>
<p>所以分别访问从 [1:len(nums)] 和 [0:len(nums)-1] 然后比较大小即可</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 因为是首尾相连的</span></span><br><span class="line">	robFirst := getMaxRob(nums[:<span class="built_in">len</span>(nums)<span class="number">-1</span>])</span><br><span class="line">	notRobFirst := getMaxRob(nums[<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">return</span> max(robFirst, notRobFirst)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getMaxRob</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	notRob, rob := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		rem := rob</span><br><span class="line">		rob = notRob + num</span><br><span class="line">		notRob = max(rem, notRob)</span><br><span class="line">		res = max(res, max(rob, notRob))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="打家劫舍-III"><a href="#打家劫舍-III" class="headerlink" title="打家劫舍 III"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/house-robber-iii/submissions/">打家劫舍 III</a></h4><p>这次是树，实际上还是要知道子节点上的话 rob 和 notRob 的状态即可，然后递推到当前的状态</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(root *TreeNode)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> res <span class="keyword">int</span></span><br><span class="line">	recursionRobTree(root, &amp;res)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recursionRobTree 返回值是 rob 当前这个 root 还不 不 rob 的值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursionRobTree</span><span class="params">(root *TreeNode, res *<span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	leftRob, leftNotRob := recursionRobTree(root.Left, res)</span><br><span class="line">	rightRob, rightNotRob := recursionRobTree(root.Right, res)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果 rob 当前这个root 节点的话 意味着 两个节点都不可以rob</span></span><br><span class="line">	rob := leftNotRob + rightNotRob + root.Val</span><br><span class="line">	<span class="comment">// 如果 不 rob 这个节点的话 子节点可以 rob 也可以不 rob</span></span><br><span class="line">	notRob := getArrayMax(leftRob + rightRob, rightRob + leftNotRob, rightNotRob + leftRob, rightNotRob + leftNotRob)</span><br><span class="line">	*res = max(*res, rob)</span><br><span class="line">	*res = max(*res, notRob)</span><br><span class="line">	<span class="keyword">return</span> rob, notRob</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getArrayMax</span><span class="params">(nums ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	res := nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		res = max(res, num)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><h3 id="转换罗马字"><a href="#转换罗马字" class="headerlink" title="转换罗马字"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/roman-to-integer/">转换罗马字</a></h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classic</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	memo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">	keys []<span class="keyword">int</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	memo[<span class="number">1</span>] = <span class="string">&quot;I&quot;</span></span><br><span class="line">	memo[<span class="number">4</span>] = <span class="string">&quot;IV&quot;</span></span><br><span class="line">	memo[<span class="number">5</span>] = <span class="string">&quot;V&quot;</span></span><br><span class="line">	memo[<span class="number">9</span>] = <span class="string">&quot;IX&quot;</span></span><br><span class="line">	memo[<span class="number">10</span>] = <span class="string">&quot;X&quot;</span></span><br><span class="line">	memo[<span class="number">40</span>] = <span class="string">&quot;XL&quot;</span></span><br><span class="line">	memo[<span class="number">50</span>] = <span class="string">&quot;L&quot;</span></span><br><span class="line">	memo[<span class="number">90</span>] = <span class="string">&quot;XC&quot;</span></span><br><span class="line">	memo[<span class="number">100</span>] = <span class="string">&quot;C&quot;</span></span><br><span class="line">	memo[<span class="number">400</span>] = <span class="string">&quot;CD&quot;</span></span><br><span class="line">	memo[<span class="number">500</span>] = <span class="string">&quot;D&quot;</span></span><br><span class="line">	memo[<span class="number">900</span>] = <span class="string">&quot;CM&quot;</span></span><br><span class="line">	memo[<span class="number">1000</span>] = <span class="string">&quot;M&quot;</span></span><br><span class="line"></span><br><span class="line">	keys = []<span class="keyword">int</span>&#123;<span class="number">1000</span>,<span class="number">900</span>,<span class="number">500</span>,<span class="number">400</span>,<span class="number">100</span>,<span class="number">90</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">10</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intToRoman</span><span class="params">(num <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	res := strings.Builder&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">		<span class="keyword">for</span> num &gt;= key &#123;</span><br><span class="line">			res.WriteString(memo[key])</span><br><span class="line">			num -= key</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jumpGame"><a href="#jumpGame" class="headerlink" title="jumpGame"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">jumpGame</a></h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canJump</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	rightMost := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="comment">// 如果当前的下标大于 rightMost 说明这个点是无法到达的 直接返回 false 即可</span></span><br><span class="line">		<span class="keyword">if</span> i &gt; rightMost &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 维护一个能够到达的最远距离</span></span><br><span class="line">		rightMost = max(rightMost, i + num)</span><br><span class="line">		<span class="comment">// 最远距离大于长度 即可知道能够达到</span></span><br><span class="line">		<span class="keyword">if</span> rightMost &gt;= <span class="built_in">len</span>(nums) - <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="执行乘法运算的最大分数"><a href="#执行乘法运算的最大分数" class="headerlink" title="执行乘法运算的最大分数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-score-from-performing-multiplication-operations/">执行乘法运算的最大分数</a></h3><blockquote>
<p>给你两个长度分别 n 和 m 的整数数组 nums 和 multipliers ，其中 n &gt;= m ，数组下标 从 1 开始 计数。<br>初始时，你的分数为 0 。你需要执行恰好 m 步操作。在第 i 步操作（从 1 开始 计数）中，需要：<br>选择数组 nums 开头处或者末尾处 的整数 x 。<br>你获得 multipliers[i] * x 分，并累加到你的分数中。<br>将 x 从数组 nums 中移除。<br>在执行 m 步操作后，返回 最大 分数。</p>
</blockquote>
<ul>
<li>暴力解法</li>
</ul>
<p>暴力解法就是直接根据每次取的不同字符生成一颗二叉树，然后在二叉树上进行遍历得到结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] multipliers)</span> </span>&#123;</span><br><span class="line">        Deque&lt;Integer&gt; num = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t : nums) &#123;</span><br><span class="line">            num.addLast(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> recursion(<span class="number">0</span>, multipliers, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] multipliers, Deque&lt;Integer&gt; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= multipliers.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Deque&lt;Integer&gt; tmp = <span class="keyword">new</span> LinkedList&lt;&gt;(nums);</span><br><span class="line">        <span class="keyword">return</span> Math.max(multipliers[index] * nums.removeFirst() + recursion(index + <span class="number">1</span>, multipliers, nums),</span><br><span class="line">                multipliers[index] * tmp.removeLast() + recursion(index + <span class="number">1</span>, multipliers, tmp));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>带 memo</li>
</ul>
<p>观察上述的结果的话，可以首先进行的优化是去除 dequeue 的使用，直接使用一个范围框定 nums 的选取</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] multipliers)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> recursion(<span class="number">0</span>, multipliers, nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] multipliers, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (index &gt;= multipliers.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> l = nums[left] * multipliers[index] + recursion(index + <span class="number">1</span>, multipliers, nums, left + <span class="number">1</span>, right, memo);</span><br><span class="line">		<span class="keyword">int</span> r = nums[right] * multipliers[index] + recursion(index + <span class="number">1</span>, multipliers, nums, left, right - <span class="number">1</span>, memo);</span><br><span class="line">		<span class="keyword">return</span> Math.max(l, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是上述的方法仍然超时，因为遍历这颗形成的二叉树的时候，会有重复的访问情况，可以观察到的是 <code>left + n - 1 - right == index</code>，因为从左边选取的数字数量和右边选取的数字的数量，肯定是 multipliers 选取的数量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumScore</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span>[] multipliers)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 上面的 left、right、index 其实可以用任意两个来表示即可</span></span><br><span class="line">		<span class="comment">// 因为可以根据公式互换，所以这样选择的 memo 是最小的</span></span><br><span class="line">		<span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[multipliers.length][multipliers.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; multipliers.length; i++) &#123;</span><br><span class="line">				Arrays.fill(memo[i], Integer.MAX_VALUE);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> recursion(<span class="number">0</span>, multipliers, nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为 left + n - 1 - right == index</span></span><br><span class="line"><span class="comment">// 因为其结果代表的是 左边选取 left 个 右边选取 n - 1 - right 个</span></span><br><span class="line"><span class="comment">// 而取出的结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span>[] multipliers, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>[][] memo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (index &gt;= multipliers.length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (memo[left][index] != Integer.MAX_VALUE) <span class="keyword">return</span> memo[left][index];</span><br><span class="line">		<span class="keyword">int</span> l = nums[left] * multipliers[index] + recursion(index + <span class="number">1</span>, multipliers, nums, left + <span class="number">1</span>, right, memo);</span><br><span class="line">		<span class="keyword">int</span> r = nums[right] * multipliers[index] + recursion(index + <span class="number">1</span>, multipliers, nums, left, right - <span class="number">1</span>, memo);</span><br><span class="line">		memo[left][index] = Math.max(l, r);</span><br><span class="line">		<span class="keyword">return</span> memo[left][index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/generate-parentheses/">括号生成</a></h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// generateParenthesis 入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateParenthesis</span><span class="params">(n <span class="keyword">int</span>)</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">	recursionGenerate(&amp;res, <span class="string">&quot;&quot;</span>, n, n)</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归生成</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursionGenerate</span><span class="params">(res *[]<span class="keyword">string</span>, tmp <span class="keyword">string</span>, left, right <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span> &#123;</span><br><span class="line">		*res = <span class="built_in">append</span>(*res, tmp)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 由于左括号可以直接放到结果上，因此左括号不用判断其他的</span></span><br><span class="line">	<span class="keyword">if</span> left &gt; <span class="number">0</span> &#123;</span><br><span class="line">		recursionGenerate(res, tmp+<span class="string">&quot;(&quot;</span>, left<span class="number">-1</span>, right)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 而有括号需要跟左括号匹配，所以有括号遍历的时候 必须已经有左括号被放到了结果中</span></span><br><span class="line">  <span class="comment">// 所以需要判断一下 right &gt; left</span></span><br><span class="line">	<span class="keyword">if</span> right &gt; left &#123;</span><br><span class="line">		recursionGenerate(res, tmp+<span class="string">&quot;)&quot;</span>, left, right<span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    recursion(res, n, n, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(List&lt;String&gt; res, <span class="keyword">int</span> left, <span class="keyword">int</span> right, String tmp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">        res.add(tmp);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        recursion(res, left - <span class="number">1</span>, right, tmp + <span class="string">&quot;(&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">        recursion(res, left, right - <span class="number">1</span>, tmp + <span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="正则表达式匹配"><a href="#正则表达式匹配" class="headerlink" title="正则表达式匹配"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regular-expression-matching/">正则表达式匹配</a></h3><p>这道题可以用递归的思想去做，也可以采用 dp 的方法。实际上递归就是从上向下的 dp</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="keyword">string</span>, p <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> recursionIsMatch(s, p, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recursionIsMatch</span><span class="params">(s, p <span class="keyword">string</span>, sIndex, pIndex <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 完全匹配</span></span><br><span class="line">	<span class="keyword">if</span> sIndex == <span class="built_in">len</span>(s) &amp;&amp; pIndex == <span class="built_in">len</span>(p) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 越界 pattern 匹配完了一定有问题</span></span><br><span class="line">	<span class="keyword">if</span> pIndex == <span class="built_in">len</span>(p) &amp;&amp; sIndex != <span class="built_in">len</span>(s) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> pIndex &lt; <span class="built_in">len</span>(p)<span class="number">-1</span> &amp;&amp; p[pIndex+<span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">		<span class="comment">// 匹配</span></span><br><span class="line">		<span class="keyword">if</span> pIndex &lt; <span class="built_in">len</span>(p) &amp;&amp; sIndex &lt; <span class="built_in">len</span>(s) &amp;&amp; (p[pIndex] == s[sIndex] || p[pIndex] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> recursionIsMatch(s, p, sIndex, pIndex+<span class="number">2</span>) || <span class="comment">// 匹配0次 因为 * 代表 0 -&gt; 多次</span></span><br><span class="line">				recursionIsMatch(s, p, sIndex+<span class="number">1</span>, pIndex+<span class="number">2</span>) || <span class="comment">// 匹配1次</span></span><br><span class="line">				recursionIsMatch(s, p, sIndex+<span class="number">1</span>, pIndex) <span class="comment">// 匹配多次</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 如果不匹配 则跳过</span></span><br><span class="line">			<span class="keyword">return</span> recursionIsMatch(s, p, sIndex, pIndex+<span class="number">2</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 现在的字符是匹配的</span></span><br><span class="line">	<span class="keyword">if</span> pIndex &lt; <span class="built_in">len</span>(p) &amp;&amp; sIndex &lt; <span class="built_in">len</span>(s) &amp;&amp; (p[pIndex] == s[sIndex] || p[pIndex] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> recursionIsMatch(s, p, sIndex+<span class="number">1</span>, pIndex+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recursion(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">recursion</span><span class="params">(String s, String p, <span class="keyword">int</span> sIndex, <span class="keyword">int</span> pIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pIndex == p.length() &amp;&amp; sIndex != s.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sIndex == s.length() &amp;&amp; pIndex == p.length()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pIndex &lt; p.length() - <span class="number">1</span> &amp;&amp; p.charAt(pIndex + <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sIndex &lt; s.length() &amp;&amp; (p.charAt(pIndex) == <span class="string">&#x27;.&#x27;</span> || p.charAt(pIndex) == s.charAt(sIndex))) &#123;</span><br><span class="line">            <span class="keyword">return</span> recursion(s, p, sIndex, pIndex + <span class="number">2</span>) || <span class="comment">// 匹配0次</span></span><br><span class="line">                    recursion(s, p, sIndex + <span class="number">1</span>, pIndex + <span class="number">2</span>) || <span class="comment">// 匹配1次</span></span><br><span class="line">                    recursion(s, p, sIndex + <span class="number">1</span>, pIndex); <span class="comment">// 匹配多次</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> recursion(s, p, sIndex, pIndex + <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sIndex &lt; s.length() &amp;&amp; pIndex &lt; p.length() &amp;&amp; (p.charAt(pIndex) == <span class="string">&#x27;.&#x27;</span> || p.charAt(pIndex) == s.charAt(sIndex))) &#123;</span><br><span class="line">        <span class="keyword">return</span> recursion(s, p, sIndex + <span class="number">1</span>, pIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><h4 id="队列-滑动窗口的最大值"><a href="#队列-滑动窗口的最大值" class="headerlink" title="队列-滑动窗口的最大值"></a>队列-<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口的最大值</a></h4><p>最大 queue 的队列</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	stack1 MaxStack</span><br><span class="line">	stack2 MaxStack</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *MaxQueue)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	queue.stack1.Push(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *MaxQueue)</span> <span class="title">shift</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> queue.stack2.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> queue.stack1.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			queue.stack2.Push(queue.stack1.Pop())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> queue.stack2.Pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *MaxQueue)</span> <span class="title">Max</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> queue.stack1.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> queue.stack2.Max()</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> queue.stack2.Len() == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> queue.stack1.Max()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> max(queue.stack2.Max(), queue.stack1.Max())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *MaxQueue)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> queue.stack1.Len() + queue.stack2.Len()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MaxStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 这两个不用 slice 用 list 之类的链表 可能会快一点儿</span></span><br><span class="line">	data  []<span class="keyword">int</span></span><br><span class="line">	maxes []<span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *MaxStack)</span> <span class="title">Push</span><span class="params">(val <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	ms.data = <span class="built_in">append</span>(ms.data, val)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(ms.maxes) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		ms.maxes = <span class="built_in">append</span>(ms.maxes, max(ms.maxes[<span class="built_in">len</span>(ms.maxes)<span class="number">-1</span>], val))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ms.maxes = <span class="built_in">append</span>(ms.maxes, val)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *MaxStack)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := ms.data[<span class="built_in">len</span>(ms.data)<span class="number">-1</span>]</span><br><span class="line">	ms.data = ms.data[:<span class="built_in">len</span>(ms.data)<span class="number">-1</span>]</span><br><span class="line">	ms.maxes = ms.maxes[:<span class="built_in">len</span>(ms.maxes)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *MaxStack)</span> <span class="title">Max</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> ms.maxes[<span class="built_in">len</span>(ms.maxes)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ms *MaxStack)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(ms.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用代码</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	queue := MaxQueue&#123;</span><br><span class="line">		stack1: MaxStack&#123;&#125;,</span><br><span class="line">		stack2: MaxStack&#123;&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		queue.Push(nums[i])</span><br><span class="line">	&#125;</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		res = <span class="built_in">append</span>(res, queue.Max())</span><br><span class="line">		queue.shift()</span><br><span class="line">		queue.Push(nums[i])</span><br><span class="line">	&#125;</span><br><span class="line">	res = <span class="built_in">append</span>(res, queue.Max())</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="栈-计算器"><a href="#栈-计算器" class="headerlink" title="栈-计算器"></a>栈-<a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator-ii/">计算器</a></h4><p>中值表达式转波兰表达式（实际上是）</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="删除倒数的第-N-个节点"><a href="#删除倒数的第-N-个节点" class="headerlink" title="删除倒数的第 N 个节点"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">删除倒数的第 N 个节点</a></h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">	<span class="comment">// 因为可能删除头结点 所有加了一个</span></span><br><span class="line">	newHead := <span class="built_in">new</span>(ListNode)</span><br><span class="line">	newHead.Next = head</span><br><span class="line">	<span class="comment">// fast 是先走的一个节点 pre 是后走的</span></span><br><span class="line">	pre, fast := newHead, head</span><br><span class="line">	<span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 有问题 数量不够</span></span><br><span class="line">		<span class="keyword">if</span> fast == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		fast = fast.Next</span><br><span class="line">		n--</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 两个指针开始走</span></span><br><span class="line">	<span class="keyword">for</span> fast != <span class="literal">nil</span> &#123;</span><br><span class="line">		fast = fast.Next</span><br><span class="line">		pre = pre.Next</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pre.Next = pre.Next.Next</span><br><span class="line">	<span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="合并-k-个已经排序的链表"><a href="#合并-k-个已经排序的链表" class="headerlink" title="合并 k 个已经排序的链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">合并 k 个已经排序的链表</a></h4><p>类似归并排序</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classic</span><br><span class="line"></span><br><span class="line"><span class="comment">// mergeKLists 合并k个已经按照升序排列的数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> merge(lists,<span class="number">0</span>, <span class="built_in">len</span>(lists) - <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">merge</span><span class="params">(lists []*ListNode, start, end <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> start &gt; end &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> start == end &#123;</span><br><span class="line">		<span class="keyword">return</span> lists[start]</span><br><span class="line">	&#125;</span><br><span class="line">	mid := (start + end) / <span class="number">2</span></span><br><span class="line">	left, right := merge(lists, start, mid), merge(lists, mid + <span class="number">1</span>, end)</span><br><span class="line">	<span class="keyword">return</span> mergeTwoList(left, right)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoList</span><span class="params">(list1 *ListNode, list2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">new</span>(ListNode)</span><br><span class="line">	rem := res</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> list1 != <span class="literal">nil</span> &amp;&amp; list2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> list1.Val &gt; list2.Val &#123;</span><br><span class="line">			res.Next = list2</span><br><span class="line">			list2 = list2.Next</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			res.Next = list1</span><br><span class="line">			list1 = list1.Next</span><br><span class="line">		&#125;</span><br><span class="line">		res = res.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> list1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		res.Next = list1</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> list2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		res.Next = list2</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rem.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="翻转链表一系列"><a href="#翻转链表一系列" class="headerlink" title="翻转链表一系列"></a>翻转链表一系列</h4><h5 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></h5><p>最简单的反转链表的思路肯定是直接用一个 stack，FILO 的机制来反转，而不采用额外的空间可以用一下的方法</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 反转后的头节点</span></span><br><span class="line">	<span class="keyword">var</span> pre *ListNode = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 用一个 局部变量 来保存下一个节点</span></span><br><span class="line">        next := head.Next</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反转当前遍历的 head 节点，指向已经反转完毕的头结点</span></span><br><span class="line">		head.Next = pre</span><br><span class="line">        pre = head</span><br><span class="line">        <span class="comment">// 重新设置 head 头</span></span><br><span class="line">		head = next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="反转链表-II"><a href="#反转链表-II" class="headerlink" title="反转链表 II"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">反转链表 II</a></h5><p>反转链表 II 是反转链表下表从 m -&gt; n 的一个链表，实际上采用上述的反转的操作，即可反转 m -&gt; n 之间的节点</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="comment">// 添加一个新的头结点，保障原来的头结点被反转时的结果</span></span><br><span class="line">	newHead := <span class="built_in">new</span>(ListNode)</span><br><span class="line">	newHead.Next = head</span><br><span class="line">    cp := newHead</span><br><span class="line">    <span class="comment">// 分别保存需要反转的节点之前的一个节点以及最后需要反转的一个节点</span></span><br><span class="line">	<span class="keyword">var</span> preStartNode, endNode *ListNode = <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; cp != <span class="literal">nil</span>; cp, i = cp.Next, i + <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> i == m - <span class="number">1</span> &#123;</span><br><span class="line">			preStartNode = cp</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i == n &#123;</span><br><span class="line">			endNode = cp</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存反转完毕后的链表需要连接到的下一个节点</span></span><br><span class="line">	afterEndNode := endNode.Next</span><br><span class="line">	reverseHead, reverseEnd := reverseBetweenNodes(preStartNode.Next, afterEndNode)</span><br><span class="line">	preStartNode.Next = reverseHead</span><br><span class="line">	reverseEnd.Next = afterEndNode</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reverseBetweenNodes reverse两个node之间的链表</span></span><br><span class="line"><span class="comment">// 其中 startNode 为开始翻转的节点 endNodeNext 为结束翻转的节点的后一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetweenNodes</span><span class="params">(startNode, endNodeNext *ListNode)</span> <span class="params">(*ListNode, *ListNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newHead *ListNode = <span class="literal">nil</span></span><br><span class="line">	newEndNode := startNode</span><br><span class="line">	<span class="keyword">for</span> startNode != endNode &#123;</span><br><span class="line">		next := startNode.Next</span><br><span class="line">		startNode.Next = newHead</span><br><span class="line">		newHead = startNode</span><br><span class="line">		startNode = next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newHead, newEndNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="reverse-K-group"><a href="#reverse-K-group" class="headerlink" title="reverse K group"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">reverse K group</a></h5><p>reverse K group 的更进一步，在上面一题的基础上，每 K 个节点反转一次</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// reverseKGroup k个一组翻转</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">	newHead := <span class="built_in">new</span>(ListNode)</span><br><span class="line">	newHead.Next = head</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> preStartNode, endNode *ListNode = newHead, <span class="literal">nil</span></span><br><span class="line">	counter := <span class="number">0</span></span><br><span class="line">	mov := newHead</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> mov != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> counter == k &#123;</span><br><span class="line">			endNode = mov</span><br><span class="line">            afterEnd := endNode.Next</span><br><span class="line">            <span class="comment">// 调用二题中所述的函数进行反转</span></span><br><span class="line">			reverseHead, reverseEnd := reverseBetweenNodes(preStartNode.Next, endNode.Next)</span><br><span class="line">			preStartNode.Next = reverseHead</span><br><span class="line">			reverseEnd.Next = afterEnd</span><br><span class="line">            <span class="comment">// 因为反转之后要重新记录 preStartNode</span></span><br><span class="line">            counter = <span class="number">0</span></span><br><span class="line">            <span class="comment">// 反转之后的需要再次反转的头是上次反转的尾结点</span></span><br><span class="line">			preStartNode = reverseEnd</span><br><span class="line">			<span class="comment">// 重新定位移标</span></span><br><span class="line">			mov = reverseEnd</span><br><span class="line">		&#125;</span><br><span class="line">		mov = mov.Next</span><br><span class="line">		counter++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> newHead.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reverseBetweenNodes reverse两个node之间的链表</span></span><br><span class="line"><span class="comment">// 其中 startNode 为开始翻转的节点 endNodeNext 为结束翻转的节点的后一个节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetweenNodes</span><span class="params">(startNode, endNodeNext *ListNode)</span> <span class="params">(*ListNode, *ListNode)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> newHead *ListNode = <span class="literal">nil</span></span><br><span class="line">	newEndNode := startNode</span><br><span class="line">	<span class="keyword">for</span> startNode != endNodeNext &#123;</span><br><span class="line">		next := startNode.Next</span><br><span class="line">		startNode.Next = newHead</span><br><span class="line">		newHead = startNode</span><br><span class="line">		startNode = next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> newHead, newEndNode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">树的遍历</a></h4><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">中序遍历</a></h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	stack := list.New()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> root != <span class="literal">nil</span> || stack.Len() != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">			stack.PushBack(root)</span><br><span class="line">			root = root.Left</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			root = stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">			res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">			root = root.Right</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">前序遍历</a></h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classic</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	stack := list.New()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> root != <span class="literal">nil</span> || stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">			res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">			stack.PushBack(root)</span><br><span class="line">			root = root.Left</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			root = stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">			root = root.Right</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">后序遍历</a></h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span> []<span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	stack := list.New()</span><br><span class="line">	<span class="comment">// 标识这个node是不是第二次访问</span></span><br><span class="line">	stackForFlag := list.New()</span><br><span class="line">	<span class="keyword">for</span> root != <span class="literal">nil</span> || stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">			stack.PushBack(root)</span><br><span class="line">			stackForFlag.PushBack(<span class="literal">false</span>)</span><br><span class="line">			root = root.Left</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> stack.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">			root = stack.Remove(stack.Back()).(*TreeNode)</span><br><span class="line">			flag := stackForFlag.Remove(stackForFlag.Back()).(<span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 说明是第二次访问 这个时候要访问父亲节点</span></span><br><span class="line">			<span class="keyword">if</span> flag &#123;</span><br><span class="line">				res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">				root = <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">// 第一次访问</span></span><br><span class="line">				stack.PushBack(root)</span><br><span class="line">				stackForFlag.PushBack(<span class="literal">true</span>)</span><br><span class="line">				root = root.Right</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a><a href="">层次遍历</a></h5><ol>
<li>普通层次遍历</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	tmp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	queue := list.New()</span><br><span class="line">	queue.PushBack(root)</span><br><span class="line">	queue.PushBack(<span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		node := queue.Remove(queue.Front())</span><br><span class="line">		<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">			cp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(tmp))</span><br><span class="line">			<span class="built_in">copy</span>(cp, tmp)</span><br><span class="line">			res = <span class="built_in">append</span>(res, cp)</span><br><span class="line">            <span class="keyword">if</span> queue.Len() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			queue.PushBack(<span class="literal">nil</span>)</span><br><span class="line">			tmp = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		top := node.(*TreeNode)</span><br><span class="line">		<span class="keyword">if</span> top.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue.PushBack(top.Left)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> top.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue.PushBack(top.Right)</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = <span class="built_in">append</span>(tmp, top.Val)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>zigzag 的层次遍历</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classic</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/list&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zigzagLevelOrder</span><span class="params">(root *TreeNode)</span> [][]<span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	res := <span class="built_in">make</span>([][]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> res</span><br><span class="line">	&#125;</span><br><span class="line">	isLeft := <span class="literal">true</span></span><br><span class="line">	tmp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	queue := list.New()</span><br><span class="line"></span><br><span class="line">	queue.PushBack(root)</span><br><span class="line">	queue.PushBack(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> queue.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		top := queue.Remove(queue.Front())</span><br><span class="line">		<span class="keyword">if</span> top == <span class="literal">nil</span> &#123;</span><br><span class="line">			cp := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(tmp))</span><br><span class="line">			<span class="built_in">copy</span>(cp, tmp)</span><br><span class="line">			res = <span class="built_in">append</span>(res, cp)</span><br><span class="line">			<span class="keyword">if</span> queue.Len() == <span class="number">0</span> &#123;</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			isLeft = !isLeft</span><br><span class="line">			tmp = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">			queue.PushBack(<span class="literal">nil</span>)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		node := top.(*TreeNode)</span><br><span class="line">		<span class="keyword">if</span> node.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue.PushBack(node.Left)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> node.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue.PushBack(node.Right)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这个地方可以这样加入 就不用再 top == nil 中重新反转数组</span></span><br><span class="line">		<span class="keyword">if</span> isLeft &#123;</span><br><span class="line">			tmp = <span class="built_in">append</span>(tmp, node.Val)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			tmp = <span class="built_in">append</span>([]<span class="keyword">int</span>&#123;node.Val&#125;, tmp...)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/implement-trie-prefix-tree/">前缀树</a></h5><p>实现用字符串的前缀来索引的结构树</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trie 之间通过 字符 关联 上一个 trie 会通过字符作为边连接下一个节点</span></span><br><span class="line"><span class="keyword">type</span> Trie <span class="keyword">struct</span> &#123;</span><br><span class="line">	data  []*Trie <span class="comment">// 存储索引结构的数 因为只包含 a-z 的字母 索引直接数组即可 不然用 map 会更好</span></span><br><span class="line">	isEnd <span class="keyword">bool</span>    <span class="comment">// 是否结束节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span> <span class="title">Trie</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> Trie&#123;</span><br><span class="line">		data:  <span class="built_in">make</span>([]*Trie, <span class="number">26</span>),</span><br><span class="line">		isEnd: <span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Insert</span><span class="params">(word <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	tmp := this</span><br><span class="line">	<span class="keyword">for</span> _, char := <span class="keyword">range</span> word &#123;</span><br><span class="line">		<span class="keyword">if</span> tmp.data[char-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">			tmp.data[char-<span class="string">&#x27;a&#x27;</span>] = &amp;Trie&#123;</span><br><span class="line">				data:  <span class="built_in">make</span>([]*Trie, <span class="number">26</span>),</span><br><span class="line">				isEnd: <span class="literal">false</span>,</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		tmp = tmp.data[char-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	tmp.isEnd = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">Search</span><span class="params">(word <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	tmp := this</span><br><span class="line">	<span class="keyword">for</span> _, char := <span class="keyword">range</span> word &#123;</span><br><span class="line">		<span class="keyword">if</span> tmp.data[char-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		tmp = tmp.data[char-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> tmp.isEnd</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Trie)</span> <span class="title">StartsWith</span><span class="params">(prefix <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	tmp := this</span><br><span class="line">	<span class="keyword">for</span> _, char := <span class="keyword">range</span> prefix &#123;</span><br><span class="line">		<span class="keyword">if</span> tmp.data[char-<span class="string">&#x27;a&#x27;</span>] == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		tmp = tmp.data[char-<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="并查集的数据结构"><a href="#并查集的数据结构" class="headerlink" title="并查集的数据结构"></a>并查集的数据结构</h4><p>并查集，表示的是一个树形的结构</p>
<img src="/2021/01/18/leetcode/union.png" class="" title="并查集示意">

<p>如图所示，针对图的一个极大连通分量，会形成一个对应的树结构（并查集只关注一个连通分量有多少连接点，不关注内部的其他的细节）</p>
<p>所以针对查找连通分量有哪些，以及连同量间的关系有作用</p>
<h5 id="并查集存储数据的结构"><a href="#并查集存储数据的结构" class="headerlink" title="并查集存储数据的结构"></a>并查集存储数据的结构</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Union struct &#123;</span><br><span class="line">	parents []int &#x2F;&#x2F; 存储树的数据结构 parents[i] 表示连接到该节点的父节点的索引 如果不能用 int 来表示 可以考虑 map 类的数据结构</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="并查集的操作"><a href="#并查集的操作" class="headerlink" title="并查集的操作"></a>并查集的操作</h5><ul>
<li>union (联合，关联两个点)</li>
<li>find (查找，找到当前点的最终的父节点)</li>
</ul>
<p>所以，实际上 如果 r1 r2 之间有连接线的话，要关联 r1 r2 的操作就是。</p>
<ul>
<li>就是通过 <code>find</code> 找到分别的根节点 r1Root r2Root</li>
<li>在通过 <code>union</code> 方法关联两个根节点，实际上就是将 r2Root 作为一个子节点，挂载到 r1Root 下</li>
</ul>
<p>所以整体的数据结构为</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> unionFind <span class="keyword">struct</span> &#123;</span><br><span class="line">	Parents []<span class="keyword">int</span></span><br><span class="line">	Count   <span class="keyword">int</span>     <span class="comment">// 表示连通分量的多少</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewUnionFind</span><span class="params">(size <span class="keyword">int</span>)</span> *<span class="title">unionFind</span></span> &#123;</span><br><span class="line">	res := &amp;unionFind&#123;</span><br><span class="line">		Parents: <span class="built_in">make</span>([]<span class="keyword">int</span>, size),</span><br><span class="line">		Count:   size,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 初始化并查集中的每个元素的父节点都是自己</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; size; i++ &#123;</span><br><span class="line">		res.Parents[i] = i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *unionFind)</span> <span class="title">union</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	iRoot := u.find(i)</span><br><span class="line">	jRoot := u.find(j)</span><br><span class="line">	<span class="keyword">if</span> iRoot != jRoot &#123;</span><br><span class="line">		u.Parents[jRoot] = iRoot</span><br><span class="line">		<span class="comment">// 每次连接一个之后 最大连通分量就要 --</span></span><br><span class="line">		u.Count--</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *unionFind)</span> <span class="title">find</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> u.Parents[i] == i &#123;</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> u.find(u.Parents[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *unionFind)</span> <span class="title">GetCount</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> u.Count</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="执行交换操作后的最小汉明距离"><a href="#执行交换操作后的最小汉明距离" class="headerlink" title="执行交换操作后的最小汉明距离"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimize-hamming-distance-after-swap-operations/">执行交换操作后的最小汉明距离</a></h4><p>这道题实际上是找连通分量，对比两个数组中相应的连通区域不等的部分，所以可以用<code>无向图连通分量 dfs</code> or <code>并查集</code> 得到连通分量后进行处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MinimumHammingDistance_1722</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span>[] union, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = getParent(union, i);</span><br><span class="line">        <span class="keyword">int</span> y = getParent(union, j);</span><br><span class="line">        <span class="keyword">if</span> (x != y) &#123;</span><br><span class="line">            union[y] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getParent</span><span class="params">(<span class="keyword">int</span>[] union, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (union[i] == -<span class="number">1</span>) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">return</span> getParent(union, union[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeUnion</span><span class="params">(<span class="keyword">int</span>[] union)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span>[] memo = <span class="keyword">new</span> <span class="keyword">boolean</span>[union.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; union.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!memo[i]) &#123;</span><br><span class="line">                recursion(union, memo, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更该 union 到root</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span>[] union, <span class="keyword">boolean</span>[] memo, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo[i]) <span class="keyword">return</span> union[i];</span><br><span class="line">        memo[i] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (union[i] == -<span class="number">1</span> || union[i] == i) &#123;</span><br><span class="line">            union[i] = i;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> root = recursion(union, memo, union[i]);</span><br><span class="line">        union[i] = root;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连通图问题 在连通分量里面找到不等的数字</span></span><br><span class="line">    <span class="comment">// 无向图的连通分量</span></span><br><span class="line">    <span class="comment">// 可以使用 dfs 得到无向图的连通分量 or 使用 union 的算法得到连通分量</span></span><br><span class="line">    <span class="comment">// 但是 union 算法如果直接在算法执行图中去更改所有的 root 值 会慢一点儿 所以在执行完毕后去更改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumHammingDistance</span><span class="params">(<span class="keyword">int</span>[] source, <span class="keyword">int</span>[] target, <span class="keyword">int</span>[][] allowedSwaps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] union = <span class="keyword">new</span> <span class="keyword">int</span>[source.length];</span><br><span class="line">        Arrays.fill(union, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] allowSwap : allowedSwaps) &#123;</span><br><span class="line">            union(union, allowSwap[<span class="number">0</span>], allowSwap[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 修改连通分量标识 到根节点</span></span><br><span class="line">        changeUnion(union);</span><br><span class="line">        <span class="comment">// 现在每个中对应的都是一个连通分量的根节点的下标，那么就需要知道 一个连通分量里面有多少个不等的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存root中的数字每个出现了几次</span></span><br><span class="line">        Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; sMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; union.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = union[i];</span><br><span class="line">            <span class="keyword">if</span> (!sMap.containsKey(root)) sMap.put(root, <span class="keyword">new</span> HashMap&lt;&gt;());</span><br><span class="line">            Map&lt;Integer, Integer&gt; tmp = sMap.get(root);</span><br><span class="line">            tmp.put(source[i], tmp.getOrDefault(source[i], <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; union.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> root = union[i];</span><br><span class="line">            Map&lt;Integer, Integer&gt; tmp = sMap.get(root);</span><br><span class="line">            <span class="keyword">if</span> (!tmp.containsKey(target[i]) || tmp.get(target[i]) == <span class="number">0</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tmp.put(target[i], tmp.get(target[i]) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> MinimumHammingDistance_1722().minimumHammingDistance(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">49</span>, <span class="number">21</span>, <span class="number">79</span>, <span class="number">79</span>, <span class="number">6</span>, <span class="number">67</span>, <span class="number">78</span>, <span class="number">9</span>, <span class="number">91</span>, <span class="number">39</span>, <span class="number">49</span>, <span class="number">32</span>, <span class="number">53</span>, <span class="number">29</span>, <span class="number">97</span>, <span class="number">50</span>, <span class="number">82</span>, <span class="number">55</span>, <span class="number">13</span>, <span class="number">83</span>, <span class="number">63</span>, <span class="number">99</span>, <span class="number">41</span>, <span class="number">6</span>, <span class="number">51</span>, <span class="number">46</span>, <span class="number">31</span>, <span class="number">26</span>, <span class="number">58</span>, <span class="number">18</span>, <span class="number">32</span>, <span class="number">51</span>, <span class="number">44</span>, <span class="number">66</span>, <span class="number">40</span>, <span class="number">35</span>, <span class="number">96</span>, <span class="number">20</span>, <span class="number">35</span>, <span class="number">43</span>, <span class="number">64</span>, <span class="number">96</span>, <span class="number">99</span>, <span class="number">76</span>, <span class="number">11</span>, <span class="number">35</span>, <span class="number">86</span>, <span class="number">96</span>, <span class="number">10</span>, <span class="number">19</span>, <span class="number">70</span>, <span class="number">29</span>, <span class="number">19</span>, <span class="number">47</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">33</span>, <span class="number">22</span>, <span class="number">32</span>, <span class="number">71</span>, <span class="number">66</span>, <span class="number">90</span>, <span class="number">78</span>, <span class="number">67</span>, <span class="number">74</span>, <span class="number">76</span>, <span class="number">84</span>, <span class="number">32</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">57</span>, <span class="number">7</span>, <span class="number">90</span>, <span class="number">95</span>, <span class="number">33</span>, <span class="number">79</span>, <span class="number">54</span>, <span class="number">99</span>, <span class="number">42</span>, <span class="number">6</span>, <span class="number">32</span>, <span class="number">55</span>, <span class="number">31</span>, <span class="number">14</span>, <span class="number">58</span>, <span class="number">67</span>, <span class="number">48</span>, <span class="number">59</span>, <span class="number">7</span>, <span class="number">50</span>, <span class="number">5</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">97</span>, <span class="number">94</span>, <span class="number">14</span>, <span class="number">53</span>, <span class="number">75</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">82</span>, <span class="number">74</span>, <span class="number">86</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">77</span>, <span class="number">70</span>, <span class="number">29</span>, <span class="number">65</span>, <span class="number">15</span>&#125;, <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">40</span>, <span class="number">41</span>&#125;, &#123;<span class="number">41</span>, <span class="number">35</span>&#125;, &#123;<span class="number">18</span>, <span class="number">19</span>&#125;, &#123;<span class="number">9</span>, <span class="number">51</span>&#125;, &#123;<span class="number">48</span>, <span class="number">2</span>&#125;, &#123;<span class="number">45</span>, <span class="number">13</span>&#125;, &#123;<span class="number">27</span>, <span class="number">45</span>&#125;, &#123;<span class="number">16</span>, <span class="number">22</span>&#125;, &#123;<span class="number">23</span>, <span class="number">25</span>&#125;, &#123;<span class="number">2</span>, <span class="number">6</span>&#125;, &#123;<span class="number">5</span>, <span class="number">11</span>&#125;, &#123;<span class="number">37</span>, <span class="number">38</span>&#125;, &#123;<span class="number">22</span>, <span class="number">48</span>&#125;, &#123;<span class="number">13</span>, <span class="number">48</span>&#125;, &#123;<span class="number">51</span>, <span class="number">37</span>&#125;, &#123;<span class="number">24</span>, <span class="number">19</span>&#125;, &#123;<span class="number">2</span>, <span class="number">32</span>&#125;, &#123;<span class="number">38</span>, <span class="number">23</span>&#125;, &#123;<span class="number">33</span>, <span class="number">34</span>&#125;, &#123;<span class="number">37</span>, <span class="number">44</span>&#125;, &#123;<span class="number">31</span>, <span class="number">8</span>&#125;, &#123;<span class="number">4</span>, <span class="number">26</span>&#125;, &#123;<span class="number">34</span>, <span class="number">35</span>&#125;, &#123;<span class="number">37</span>, <span class="number">28</span>&#125;, &#123;<span class="number">48</span>, <span class="number">34</span>&#125;, &#123;<span class="number">27</span>, <span class="number">0</span>&#125;, &#123;<span class="number">23</span>, <span class="number">37</span>&#125;, &#123;<span class="number">17</span>, <span class="number">29</span>&#125;, &#123;<span class="number">38</span>, <span class="number">7</span>&#125;, &#123;<span class="number">37</span>, <span class="number">31</span>&#125;, &#123;<span class="number">34</span>, <span class="number">42</span>&#125;, &#123;<span class="number">26</span>, <span class="number">20</span>&#125;, &#123;<span class="number">22</span>, <span class="number">45</span>&#125;, &#123;<span class="number">26</span>, <span class="number">29</span>&#125;, &#123;<span class="number">40</span>, <span class="number">42</span>&#125;, &#123;<span class="number">48</span>, <span class="number">30</span>&#125;, &#123;<span class="number">46</span>, <span class="number">49</span>&#125;, &#123;<span class="number">12</span>, <span class="number">52</span>&#125;, &#123;<span class="number">49</span>, <span class="number">28</span>&#125;, &#123;<span class="number">39</span>, <span class="number">14</span>&#125;, &#123;<span class="number">23</span>, <span class="number">34</span>&#125;, &#123;<span class="number">6</span>, <span class="number">30</span>&#125;, &#123;<span class="number">18</span>, <span class="number">12</span>&#125;, &#123;<span class="number">52</span>, <span class="number">49</span>&#125;, &#123;<span class="number">21</span>, <span class="number">18</span>&#125;, &#123;<span class="number">11</span>, <span class="number">4</span>&#125;, &#123;<span class="number">2</span>, <span class="number">7</span>&#125;, &#123;<span class="number">4</span>, <span class="number">17</span>&#125;, &#123;<span class="number">19</span>, <span class="number">27</span>&#125;, &#123;<span class="number">33</span>, <span class="number">5</span>&#125;, &#123;<span class="number">44</span>, <span class="number">28</span>&#125;, &#123;<span class="number">38</span>, <span class="number">9</span>&#125;, &#123;<span class="number">34</span>, <span class="number">7</span>&#125;, &#123;<span class="number">7</span>, <span class="number">47</span>&#125;, &#123;<span class="number">37</span>, <span class="number">13</span>&#125;, &#123;<span class="number">51</span>, <span class="number">12</span>&#125;, &#123;<span class="number">42</span>, <span class="number">53</span>&#125;, &#123;<span class="number">42</span>, <span class="number">21</span>&#125;, &#123;<span class="number">18</span>, <span class="number">9</span>&#125;, &#123;<span class="number">21</span>, <span class="number">39</span>&#125;, &#123;<span class="number">4</span>, <span class="number">33</span>&#125;, &#123;<span class="number">29</span>, <span class="number">39</span>&#125;, &#123;<span class="number">47</span>, <span class="number">41</span>&#125;, &#123;<span class="number">25</span>, <span class="number">13</span>&#125;, &#123;<span class="number">50</span>, <span class="number">0</span>&#125;, &#123;<span class="number">21</span>, <span class="number">48</span>&#125;, &#123;<span class="number">32</span>, <span class="number">27</span>&#125;, &#123;<span class="number">33</span>, <span class="number">53</span>&#125;, &#123;<span class="number">39</span>, <span class="number">5</span>&#125;, &#123;<span class="number">12</span>, <span class="number">25</span>&#125;, &#123;<span class="number">52</span>, <span class="number">6</span>&#125;, &#123;<span class="number">17</span>, <span class="number">44</span>&#125;, &#123;<span class="number">16</span>, <span class="number">52</span>&#125;, &#123;<span class="number">0</span>, <span class="number">34</span>&#125;, &#123;<span class="number">14</span>, <span class="number">29</span>&#125;, &#123;<span class="number">0</span>, <span class="number">19</span>&#125;, &#123;<span class="number">13</span>, <span class="number">7</span>&#125;, &#123;<span class="number">29</span>, <span class="number">21</span>&#125;, &#123;<span class="number">9</span>, <span class="number">22</span>&#125;, &#123;<span class="number">28</span>, <span class="number">45</span>&#125;, &#123;<span class="number">1</span>, <span class="number">29</span>&#125;, &#123;<span class="number">37</span>, <span class="number">17</span>&#125;, &#123;<span class="number">38</span>, <span class="number">36</span>&#125;, &#123;<span class="number">4</span>, <span class="number">23</span>&#125;, &#123;<span class="number">38</span>, <span class="number">21</span>&#125;, &#123;<span class="number">35</span>, <span class="number">5</span>&#125;, &#123;<span class="number">2</span>, <span class="number">16</span>&#125;, &#123;<span class="number">34</span>, <span class="number">30</span>&#125;, &#123;<span class="number">37</span>, <span class="number">16</span>&#125;, &#123;<span class="number">40</span>, <span class="number">53</span>&#125;, &#123;<span class="number">51</span>, <span class="number">47</span>&#125;, &#123;<span class="number">20</span>, <span class="number">32</span>&#125;, &#123;<span class="number">7</span>, <span class="number">9</span>&#125;, &#123;<span class="number">12</span>, <span class="number">15</span>&#125;, &#123;<span class="number">26</span>, <span class="number">0</span>&#125;, &#123;<span class="number">14</span>, <span class="number">44</span>&#125;, &#123;<span class="number">53</span>, <span class="number">11</span>&#125;, &#123;<span class="number">48</span>, <span class="number">17</span>&#125;&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="连通网络的操作次数"><a href="#连通网络的操作次数" class="headerlink" title="连通网络的操作次数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-operations-to-make-network-connected/">连通网络的操作次数</a></h4><p>题目所述，给定一个图，找到将其所有最大连通分量连通所需更改的最少的边的数量为多少。</p>
<blockquote>
<p>图的所有最小连通为一个树，即需要 n 个节点有 n - 1 条边。</p>
</blockquote>
<p>所以题目其实是要找到这个图里面有多少独立的连通分量，然后判断其是否可以连接</p>
<ul>
<li>第一种思路就是直接 dfs 遍历，找到所有的连通分量。首先判断边的数量是否足够 n - 1 这个时候，如果有多个连通分量，说明某个连通分量一定有多的边，随意选取其中的边即可</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classic</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeConnected 方法查看</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeConnected</span><span class="params">(n <span class="keyword">int</span>, connections [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// 最短的话肯定是形成一棵树 才能联通所有</span></span><br><span class="line">	<span class="comment">// 所以 边 至少要达到 n - 1 的数量</span></span><br><span class="line">	<span class="comment">// 这个时候不能连通</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(connections) &lt; n<span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// map 的邻接表表示</span></span><br><span class="line">	cMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">for</span> _, connection := <span class="keyword">range</span> connections &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := cMap[connection[<span class="number">0</span>]]; !ok &#123;</span><br><span class="line">			cMap[connection[<span class="number">0</span>]] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		cMap[connection[<span class="number">0</span>]] = <span class="built_in">append</span>(cMap[connection[<span class="number">0</span>]], connection[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> _, ok := cMap[connection[<span class="number">1</span>]]; !ok &#123;</span><br><span class="line">			cMap[connection[<span class="number">1</span>]] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		cMap[connection[<span class="number">1</span>]] = <span class="built_in">append</span>(cMap[connection[<span class="number">1</span>]], connection[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 到这里的时候 由于边的数量够 所以一定是可以连通的</span></span><br><span class="line">	<span class="comment">// 这个时候 只需要知道有 m 块是不相连的 然后就知道需要连接的次数就为 m - 1</span></span><br><span class="line">	memo := <span class="built_in">make</span>([]<span class="keyword">bool</span>, n)</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> !memo[i] &#123;</span><br><span class="line">			res++</span><br><span class="line">			dfs(memo, cMap, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfs</span><span class="params">(memo []<span class="keyword">bool</span>, cMap <span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">int</span>, start <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	memo[start] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> _, next := <span class="keyword">range</span> cMap[start] &#123;</span><br><span class="line">		<span class="keyword">if</span> !memo[next] &#123;</span><br><span class="line">			dfs(memo, cMap, next)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>并查集，找到每个群组的数据的一个代表点</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// findRoot 找到根节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRoot</span><span class="params">(parents []<span class="keyword">int</span>, index <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> parents[index] == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> index</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> findRoot(parents, parents[index])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// makeConnected 并查集</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeConnected</span><span class="params">(n <span class="keyword">int</span>, connections [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(connections) &lt; n - <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 并查集的 parents 数组，标识 当前索引的 节点的父节点的索引是谁</span></span><br><span class="line">	<span class="comment">// 相同的数最后均能找到同样的父节点</span></span><br><span class="line">	parents := <span class="built_in">make</span>([]<span class="keyword">int</span>, n)</span><br><span class="line">	<span class="comment">// 初始化所有的为 -1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		parents[i] = <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 执行 union 的操作</span></span><br><span class="line">	<span class="keyword">for</span> _, connection := <span class="keyword">range</span> connections &#123;</span><br><span class="line">		sRoot := findRoot(parents, connection[<span class="number">0</span>])</span><br><span class="line">		eRoot := findRoot(parents, connection[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 两个点上有连接线 但是现在还没有连接起来</span></span><br><span class="line">		<span class="comment">// 让其根节点相连</span></span><br><span class="line">		<span class="keyword">if</span> sRoot != eRoot &#123;</span><br><span class="line">			<span class="comment">// 将 e 节点连接到 s 上</span></span><br><span class="line">			parents[eRoot] = sRoot</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 剩下的还是 -1 的就一定是整个群里面的代表节点</span></span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, val := <span class="keyword">range</span> parents &#123;</span><br><span class="line">		<span class="keyword">if</span> val == <span class="number">-1</span> &#123;</span><br><span class="line">			res++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="由斜杠划分区域"><a href="#由斜杠划分区域" class="headerlink" title="由斜杠划分区域"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/regions-cut-by-slashes/">由斜杠划分区域</a></h4><p>采用并查集，但是这道题有特殊的地方。</p>
<p>题目中所示，针对一个方格有 <strong>/</strong> 和 <strong>\</strong> 两种，如下</p>
<pre>
----    ----
|\ |    | /|
| \|    |/ |
----    ----
</pre>

<p>总之，针对一个 方格 ，可以把他看成四个部分</p>
<img src="/2021/01/18/leetcode/959-1.png" class="" title="一个单元格分块">

<p>那么，也就是说，</p>
<ul>
<li>如果当前 char == ‘ ‘ 表示 0 1 2 3 都是联通的</li>
<li>如果 char == ‘\‘ 表示 01 23 分别连通</li>
<li>char == ‘/‘ 表示 03 12 分别连通</li>
</ul>
<p>内部的连通完毕后，</p>
<ul>
<li>还可以知道 1 一定跟下一个 3 连通</li>
<li>2 一定跟下一行的 0 连通</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// regionsBySlashes 通过斜杠划分</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">regionsBySlashes</span><span class="params">(grid []<span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="comment">// n * n 的矩阵的长度</span></span><br><span class="line">	length := <span class="built_in">len</span>(grid)</span><br><span class="line">	<span class="comment">// 为了使用 并查集 将一个1*1 的正方形，即 一个 grid[i] 标识的区域分成 四个地方</span></span><br><span class="line">	<span class="comment">// 然后再根据 / \\ 两个符号的位置进行合并 最后看有几个节点</span></span><br><span class="line">	unionSize := <span class="number">4</span> * length * length</span><br><span class="line">	u := NewUnionFind(unionSize)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, str := <span class="keyword">range</span> grid &#123;</span><br><span class="line">		<span class="keyword">for</span> j, char := <span class="keyword">range</span> str &#123;</span><br><span class="line">			<span class="comment">// 0 号位置</span></span><br><span class="line">			uIndex := <span class="number">4</span> * (i*length + j)</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 同一个单元格里面的连接起来</span></span><br><span class="line">			<span class="keyword">switch</span> char &#123;</span><br><span class="line">			<span class="comment">// 0 1 2 3 都要连接起来</span></span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">				u.union(uIndex, uIndex + <span class="number">1</span>)</span><br><span class="line">				u.union(uIndex + <span class="number">1</span>, uIndex + <span class="number">2</span>)</span><br><span class="line">				u.union(uIndex + <span class="number">2</span>, uIndex + <span class="number">3</span>)</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;\\&#x27;</span>:</span><br><span class="line">				<span class="comment">// 反斜杠的话 01 23 分别连接</span></span><br><span class="line">				u.union(uIndex, uIndex + <span class="number">1</span>)</span><br><span class="line">				u.union(uIndex + <span class="number">2</span>, uIndex + <span class="number">3</span>)</span><br><span class="line">			<span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">				<span class="comment">// 斜杠的话 03 12 分贝连接</span></span><br><span class="line">				u.union(uIndex, uIndex + <span class="number">3</span>)</span><br><span class="line">				u.union(uIndex + <span class="number">1</span>, uIndex + <span class="number">2</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 单元格外面的连接起来</span></span><br><span class="line">			<span class="comment">// 不管是 \\ 还是 / 这个区域的1一定可以和右边下一个区域( j+ 1)的 3 连接</span></span><br><span class="line">			<span class="comment">// 这个区域的 2 一定可以和下边(i + 1)下一个区域的 0 连接</span></span><br><span class="line">			<span class="keyword">if</span> j + <span class="number">1</span> &lt; length &#123;</span><br><span class="line">				u.union(uIndex+<span class="number">1</span>, <span class="number">4</span>*(i*length+j+<span class="number">1</span>)+<span class="number">3</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> i + <span class="number">1</span> &lt; length &#123;</span><br><span class="line">				u.union(uIndex+<span class="number">2</span>, <span class="number">4</span>*((i+<span class="number">1</span>)*length+j))</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> u.GetCount()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="水位上升的泳池中游泳"><a href="#水位上升的泳池中游泳" class="headerlink" title="水位上升的泳池中游泳"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/swim-in-rising-water/">水位上升的泳池中游泳</a></h4><p>这道题没想明白最开始，肯定是明白要知道到什么时候 [0,0] 跟 [n - 1, n - 1] 的右下角相连</p>
<p>相连的判断可以通过<code>并查集</code>实现</p>
<p>那么就要解决几个问题：</p>
<ul>
<li>怎么遍历</li>
<li>并查集连接的条件是什么</li>
<li>怎么把二维数组的位置抽象到一维</li>
</ul>
<p>从以下几个方面入手</p>
<ul>
<li>题目中所述 grid 中的数值从 [0, n<em>n-1] 的唯一数值，也就是说每个格子的高度都是独立的，因此只需要遍历高度，在遍历高度中如果 [0, n</em>n-1] 相连，即完成连接</li>
<li>由于题目中 当遍历的位置达到一个高度的时候，他可以直接和<strong>上下左右</strong>上的相连，也就是说遍历到高度更高的地方能够直接比高度更低的地方连接</li>
<li>而题目中的 grid 的棋盘的二维数组可以通过简单的 <code>n*x+y</code> 抽象到一维</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classic</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">union</span><span class="params">(parents []<span class="keyword">int</span>, i, j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">	iRoot, jRoot := findRootOfParents(parents, i), findRootOfParents(parents, j)</span><br><span class="line">	<span class="keyword">if</span> iRoot != jRoot &#123;</span><br><span class="line">		parents[jRoot] = iRoot</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRootOfParents</span><span class="params">(parents []<span class="keyword">int</span>, i <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> parents[i] == i &#123;</span><br><span class="line">		<span class="keyword">return</span> i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> findRootOfParents(parents, parents[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isConnectedParents</span><span class="params">(parents []<span class="keyword">int</span>, i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> findRootOfParents(parents, i) == findRootOfParents(parents, j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 表示上下左右四个方向</span></span><br><span class="line">	DIRECTIONS = [][]<span class="keyword">int</span>&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swimInWater</span><span class="params">(grid [][]<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> grid == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	n := <span class="built_in">len</span>(grid)</span><br><span class="line"></span><br><span class="line">	index := <span class="built_in">make</span>([]<span class="keyword">int</span>, n*n)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">			<span class="comment">// 因为题目中所述，grid 里面的数值从 0 -&gt; n * n - 1</span></span><br><span class="line">			<span class="comment">// 所以让高度作为下标索引 方便下面遍历</span></span><br><span class="line">			index[grid[i][j]] = n*i + j</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// grid 的二位数组 可以转为 n * i + j 的一维坐标</span></span><br><span class="line">	parents := <span class="built_in">make</span>([]<span class="keyword">int</span>, n*n)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n*n; i++ &#123;</span><br><span class="line">		parents[i] = i</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n*n; i++ &#123;</span><br><span class="line">		x, y := index[i]/n, index[i]%n</span><br><span class="line">		<span class="keyword">for</span> _, direction := <span class="keyword">range</span> DIRECTIONS &#123;</span><br><span class="line">			newX, newY := x+direction[<span class="number">0</span>], y+direction[<span class="number">1</span>]</span><br><span class="line">			<span class="comment">// 因为这个是从高度相距只有1的地方开始的 所以可以直接关联</span></span><br><span class="line">			<span class="comment">// 这样当 0 n - 1 连接到一起的时候 说明已经达到的最小的高度</span></span><br><span class="line">			<span class="comment">// 只有新的节点的高度 小于 当前的高度 才是可以游过去的！！！</span></span><br><span class="line">			<span class="keyword">if</span> !(newX &lt; <span class="number">0</span> || newX &gt;= n || newY &lt; <span class="number">0</span> || newY &gt;= n) &amp;&amp; grid[newX][newY] &lt;= i &#123;</span><br><span class="line">				<span class="comment">// index 的索引用在这个地方</span></span><br><span class="line">				union(parents, index[i], newX*n+newY)</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> isConnectedParents(parents, <span class="number">0</span>, n*n<span class="number">-1</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> i</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><ul>
<li>逆后续排列</li>
<li>遍历出度为 0 的点</li>
</ul>
<h4 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/course-schedule/">课程表</a></h4><p>这道题本质上就是拓扑排序</p>
<p>简单的做法就是用 dfs 去判断是否成环</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="comment">// 有向图</span></span><br><span class="line">	mapOfCourses := <span class="built_in">make</span>([][]<span class="keyword">int</span>, numCourses)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">		mapOfCourses[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, prerequisite := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">		mapOfCourses[prerequisite[<span class="number">1</span>]] = <span class="built_in">append</span>(mapOfCourses[prerequisite[<span class="number">1</span>]], prerequisite[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 保存已经访问过的节点 这样可以避免重复访问</span></span><br><span class="line">	totalMemo := <span class="built_in">make</span>([]<span class="keyword">bool</span>, numCourses)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> !dfsCanFinish(mapOfCourses, <span class="built_in">make</span>([]<span class="keyword">bool</span>, numCourses), totalMemo, i) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 dfs 的方法判断是否成环</span></span><br><span class="line"><span class="comment">// 用 memo 来记录一次循环中访问的节点</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dfsCanFinish</span><span class="params">(mapOfCourses [][]<span class="keyword">int</span>, memo, totalMemo []<span class="keyword">bool</span>, start <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> totalMemo[start] &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	totalMemo[start] = <span class="literal">true</span></span><br><span class="line">	memo[start] = <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> _, adj := <span class="keyword">range</span> mapOfCourses[start] &#123;</span><br><span class="line">		<span class="keyword">if</span> !memo[adj] &#123;</span><br><span class="line">			<span class="comment">// 截断 有环直接返回</span></span><br><span class="line">			<span class="keyword">if</span> !dfsCanFinish(mapOfCourses, memo, totalMemo, adj) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 这个地方就是找到了环</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	memo[start] = <span class="literal">false</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拓扑排序 遍历入度为 0 的点</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">canFinish</span><span class="params">(numCourses <span class="keyword">int</span>, prerequisites [][]<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 入度为 0 的点为起点</span></span><br><span class="line">	inDegree := <span class="built_in">make</span>([]<span class="keyword">int</span>, numCourses)</span><br><span class="line">	<span class="keyword">for</span> _, prerequisite := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">		<span class="comment">// 让有向图的接受线的一端 入度++</span></span><br><span class="line">		inDegree[prerequisite[<span class="number">0</span>]]++</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 保存入度为 0 的点</span></span><br><span class="line">	inDegreeEqualZero := list.New()</span><br><span class="line">	<span class="keyword">for</span> i, in := <span class="keyword">range</span> inDegree &#123;</span><br><span class="line">		<span class="keyword">if</span> in == <span class="number">0</span> &#123;</span><br><span class="line">			inDegreeEqualZero.PushBack(i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历入度为 0 的点</span></span><br><span class="line">	<span class="comment">// 每次删除一条边 判断下一个点 是否入度为0 入度为 0 加入到 map 中 不停的遍历 直到没有点</span></span><br><span class="line">	<span class="keyword">for</span> inDegreeEqualZero.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		node := inDegreeEqualZero.Remove(inDegreeEqualZero.Front()).(<span class="keyword">int</span>)</span><br><span class="line">		<span class="keyword">for</span> _, prerequisite := <span class="keyword">range</span> prerequisites &#123;</span><br><span class="line">			<span class="keyword">if</span> node == prerequisite[<span class="number">1</span>] &#123;</span><br><span class="line">				inDegree[prerequisite[<span class="number">0</span>]]--</span><br><span class="line">				<span class="keyword">if</span> inDegree[prerequisite[<span class="number">0</span>]] == <span class="number">0</span> &#123;</span><br><span class="line">					inDegreeEqualZero.PushBack(prerequisite[<span class="number">0</span>])</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; numCourses; i++ &#123;</span><br><span class="line">		<span class="comment">// 这个地方说明还有点相连，因此是无法完成的</span></span><br><span class="line">		<span class="keyword">if</span> inDegree[i] != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="地图分析"><a href="#地图分析" class="headerlink" title="地图分析"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/as-far-from-land-as-possible/">地图分析</a></h4><p>找到多源最短路，改造了一下 dijkstra 算法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 考虑使用 dijkstra 算法</span></span><br><span class="line">		<span class="comment">// dijkstra 算法是找单源最短路经的</span></span><br><span class="line">		<span class="comment">// 因此在这儿要改造一下</span></span><br><span class="line">		<span class="comment">// 虚拟出一个超级节点 连接所有的起始节点 那样就可以找出从这个超级节点到 另外一个集合的最短距离</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> n = grid.length;</span><br><span class="line">		<span class="keyword">int</span>[][] dst = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">		<span class="comment">// 无向图 为了防止重复访问 需要 memo</span></span><br><span class="line">		<span class="keyword">boolean</span>[][] memo = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">		PriorityQueue&lt;Node&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">						dst[i][j] = Integer.MAX_VALUE;</span><br><span class="line">						<span class="comment">// 连接到超级节点的 dst 为 0</span></span><br><span class="line">						<span class="comment">// 从 岸开始遍历 那么 岸到任意一个海的最短距离就会保存到 海节点上</span></span><br><span class="line">						<span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">								dst[i][j] = <span class="number">0</span>;</span><br><span class="line">								pq.add(<span class="keyword">new</span> Node(i, j, <span class="number">0</span>));</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这样就可以吧时间复杂度降下来</span></span><br><span class="line">		<span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">				Node top = pq.poll();</span><br><span class="line">				memo[top.x][top.y] = <span class="keyword">true</span>;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span>[] direction : directions) &#123;</span><br><span class="line">						<span class="keyword">int</span> newX = top.x + direction[<span class="number">0</span>], newY = top.y + direction[<span class="number">1</span>];</span><br><span class="line">						<span class="comment">// 越界</span></span><br><span class="line">						<span class="keyword">if</span> (newX &gt;= n || newX &lt; <span class="number">0</span> || newY &gt;= n || newY &lt; <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">						<span class="keyword">if</span> (memo[newX][newY]) <span class="keyword">continue</span>;</span><br><span class="line">						<span class="comment">// relax</span></span><br><span class="line">						<span class="keyword">if</span> (dst[newX][newY] &gt; dst[top.x][top.y] + <span class="number">1</span>) &#123;</span><br><span class="line">								dst[newX][newY] = dst[top.x][top.y] + <span class="number">1</span>;</span><br><span class="line">								<span class="comment">// 更新 pq 里面的最短距离</span></span><br><span class="line">								pq.removeIf((node) -&gt; node.x == newX &amp;&amp; node.y == newY);</span><br><span class="line">								pq.add(<span class="keyword">new</span> Node(newX, newY, dst[newX][newY]));</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">						<span class="comment">// 因为结果保存在 海洋单元格内</span></span><br><span class="line">						<span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>) res = Math.max(res, dst[i][j]);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res == Integer.MAX_VALUE ? -<span class="number">1</span> : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Node</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> dst;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">this</span>.x = x;</span><br><span class="line">				<span class="keyword">this</span>.y = y;</span><br><span class="line">				<span class="comment">// 还没有找到</span></span><br><span class="line">				<span class="keyword">this</span>.dst = Integer.MAX_VALUE;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> dst)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">this</span>.x = x;</span><br><span class="line">				<span class="keyword">this</span>.y = y;</span><br><span class="line">				<span class="keyword">this</span>.dst = dst;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Node o)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">this</span>.dst - o.dst;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] directions = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="1786-从第一个节点出发到最后一个节点的受限路径数"><a href="#1786-从第一个节点出发到最后一个节点的受限路径数" class="headerlink" title="1786. 从第一个节点出发到最后一个节点的受限路径数"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node/">1786. 从第一个节点出发到最后一个节点的受限路径数</a></h3><p>说实话 我是看不懂受限路径到底是什么意思，所以看了下他们的思路，自己实现了一下。现在贴上原题</p>
<blockquote>
<p>现有一个加权无向连通图。给你一个正整数 n ，表示图中有 n 个节点，并按从 1 到 n 给节点编号；另给你一个数组 edges ，其中每个 edges[i] = [ui, vi, weighti] 表示存在一条位于节点 ui 和 vi 之间的边，这条边的权重为 weighti 。<br/><br/><br>从节点 start 出发到节点 end 的路径是一个形如 [z0, z1, z2, …, zk] 的节点序列，满足 z0 = start 、zk = end 且在所有符合 0 &lt;= i &lt;= k-1 的节点 zi 和 zi+1 之间存在一条边。<br/><br/><br>路径的距离定义为这条路径上所有边的权重总和。用 distanceToLastNode(x) 表示节点 n 和 x 之间路径的最短距离。受限路径 为满足 distanceToLastNode(zi) &gt; distanceToLastNode(zi+1) 的一条路径，其中 0 &lt;= i &lt;= k-1 。<br/><br/><br>返回从节点 1 出发到节点 n 的 受限路径数 。由于数字可能很大，请返回对 109 + 7 取余 的结果。</p>
</blockquote>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-restricted-paths-from-first-to-last-node/solution/xiang-jie-dui-you-hua-dijkstra-dong-tai-i6j0d/">参考的解法</a></p>
</li>
<li><p>模仿的解法</p>
</li>
</ul>
<p>超时，怀疑是 构建图 花费太多时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> microsoft.PlusOne;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountRestrictedPaths_1786</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> from, to;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.from = from;</span><br><span class="line">            <span class="keyword">this</span>.to = to;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOther</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (node == from) <span class="keyword">return</span> to;</span><br><span class="line">            <span class="keyword">return</span> from;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Map</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Edge&gt;&gt; map;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> capacity;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Map</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">            <span class="keyword">this</span>.map = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.capacity; i++) &#123;</span><br><span class="line">                <span class="keyword">this</span>.map.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            Edge e = <span class="keyword">new</span> Edge(from, to, weight);</span><br><span class="line">            <span class="keyword">this</span>.map.get(from).add(e);</span><br><span class="line">            <span class="keyword">this</span>.map.get(to).add(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Edge&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.map.get(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Pair</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> node;</span><br><span class="line">        <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Pair o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> weight - o.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 dp 结果</span></span><br><span class="line">    <span class="comment">// 这个题目说的意思是 只要从尾结点开始遍历 并且到下一个点的距离 大于 当前点的距离 就是逆序的</span></span><br><span class="line">    <span class="comment">// 按照题解的描述</span></span><br><span class="line">    <span class="comment">// 这条路径的搜索过程可以看做，从结尾（第 5 个点）出发，逆着走，每次选择一个点（例如 a）之后，</span></span><br><span class="line">    <span class="comment">// 再选择下一个点（例如 b）时就必须满足最短路距离比上一个点（点 a）要远，如果最终能选到起点（第一个点），说明统计出一条有效路径。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dijkstra(Map map, <span class="keyword">int</span> start) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] dstTo = <span class="keyword">new</span> <span class="keyword">int</span>[map.capacity];</span><br><span class="line">        Arrays.fill(dstTo, Integer.MAX_VALUE);</span><br><span class="line">        dstTo[start] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Pair&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        queue.add(<span class="keyword">new</span> Pair(start, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 无向图 防止重复</span></span><br><span class="line">        <span class="keyword">boolean</span>[] memo = <span class="keyword">new</span> <span class="keyword">boolean</span>[map.capacity];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Pair top = queue.poll();</span><br><span class="line">            memo[top.node] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (Edge e : map.adj(top.node)) &#123;</span><br><span class="line">                <span class="keyword">int</span> other = e.getOther(top.node);</span><br><span class="line">                <span class="keyword">if</span> (!memo[other] &amp;&amp; dstTo[other] &gt; dstTo[top.node] + e.weight) &#123;</span><br><span class="line">                    dstTo[other] = dstTo[top.node] + e.weight;</span><br><span class="line">                    queue.removeIf((p) -&gt; p.node == other);</span><br><span class="line">                    queue.add(<span class="keyword">new</span> Pair(other, dstTo[other]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dstTo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRestrictedPaths</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        Map map = <span class="keyword">new</span> Map(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">            map.addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回节点的数据</span></span><br><span class="line">        <span class="keyword">int</span>[] dstTo = dijkstra(map, n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到了dist数组，可以得到递推关系，dp[u] += dp[v], when v links to v and  dist[u] &gt; dist[v]</span></span><br><span class="line">        <span class="comment">//        因此先算dist小的，才可以算dp，需要dist从小到大排序, 然后依次计算。</span></span><br><span class="line">        <span class="comment">// 保存到某个点 以及对应的 dst 距离</span></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; pairs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; dstTo.length; i++) &#123;</span><br><span class="line">            pairs.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, dstTo[i]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        pairs.sort(Comparator.comparingInt(a -&gt; a[<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[n] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] p : pairs) &#123;</span><br><span class="line">            <span class="keyword">int</span> node = p[<span class="number">0</span>], cur = p[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (Edge adj : map.adj(node)) &#123;</span><br><span class="line">                <span class="keyword">int</span> other = adj.getOther(node);</span><br><span class="line">                <span class="keyword">if</span> (cur &gt; dstTo[other]) &#123;</span><br><span class="line">                    dp[node] = (dp[node] + dp[other]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> CountRestrictedPaths_1786().countRestrictedPaths(<span class="number">5</span>, <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">10</span>&#125;</span><br><span class="line">        &#125;));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> CountRestrictedPaths_1786().countRestrictedPaths(<span class="number">7</span>, <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                &#123;<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span>&#125;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="博弈问题"><a href="#博弈问题" class="headerlink" title="博弈问题"></a>博弈问题</h2><h3 id="预测赢家"><a href="#预测赢家" class="headerlink" title="预测赢家"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/predict-the-winner/">预测赢家</a></h3><p>分别从数组的两端取值，问最后谁获胜。</p>
<p>模拟取值的过程即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">PredictTheWinner</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[][] memo = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length][nums.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span>[] ints : memo) &#123;</span><br><span class="line">				Arrays.fill(ints, -<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> recursionMemo(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, memo) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursionMemo</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span>[][] memo)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (i &gt; j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (i == j) <span class="keyword">return</span> nums[i];</span><br><span class="line">		<span class="keyword">if</span> (memo[i][j] != -<span class="number">1</span>) <span class="keyword">return</span> memo[i][j];</span><br><span class="line">		<span class="comment">// 分别选取左边和右边的值进行比较</span></span><br><span class="line">		<span class="keyword">int</span> left = nums[i] - recursionMemo(nums, i + <span class="number">1</span>, j, memo);</span><br><span class="line">		<span class="keyword">int</span> right = nums[j] - recursionMemo(nums, i, j - <span class="number">1</span>, memo);</span><br><span class="line">		memo[i][j] = Math.max(left, right);</span><br><span class="line">		<span class="keyword">return</span> memo[i][j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="石子游戏"><a href="#石子游戏" class="headerlink" title="石子游戏"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/stone-game/">石子游戏</a></h3><h3 id="石子游戏-VII"><a href="#石子游戏-VII" class="headerlink" title="石子游戏 VII"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/stone-game-vii/">石子游戏 VII</a></h3><h2 id="杂题"><a href="#杂题" class="headerlink" title="杂题"></a>杂题</h2><h3 id="递增的三元子序列"><a href="#递增的三元子序列" class="headerlink" title="递增的三元子序列"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">递增的三元子序列</a></h3><ul>
<li>首先想到嘛，用两个数组分别存储从左到右的最小值和最右到左的最大值，那么如果 nums 中一个数 num 大于这个最小值小于这个最大值，是一定可以的</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">increasingTriplet</span><span class="params">(nums []<span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	mins, maxes := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums)), <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	mins[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		mins[i] = min(mins[i<span class="number">-1</span>], nums[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	maxes[<span class="built_in">len</span>(nums)<span class="number">-1</span>] = nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(nums) - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		maxes[i] = max(maxes[i+<span class="number">1</span>], nums[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">if</span> num &gt; mins[i] &amp;&amp; num &lt; maxes[i] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>还可以进一步优化</li>
</ul>
<p>他实际上是找这么一组 3 个数 num1 &lt; num2 &lt; num3</p>
<p>那么如果我在 num3 之前找到了这两个数字 num1 num2 即可</p>
<p>所以用 一个 min mid 来记录之前找到的 num1 num2。</p>
<p>其中 min 保存之前遇到的最小值, mid 保存之前 大于 min 的最小值，那么 如果碰到 同时大于 min、mid 的数 就可以直接返回 true 了。</p>
<p>但是可能遇到这种情况，在访问找到 num3 的时候，min 对应的数字的下标在 mid 之后。</p>
<p>但是考虑这种情况的话，一定有一个小于 mid 的 历史 min 值在 mid 之前，所以其实还是一个完整的三元组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE, mid = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &lt;= min) &#123;</span><br><span class="line">                min = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt;= mid) &#123;</span><br><span class="line">                mid = num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><h4 id="袋子里最少数目的球"><a href="#袋子里最少数目的球" class="headerlink" title="袋子里最少数目的球"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-limit-of-balls-in-a-bag/">袋子里最少数目的球</a></h4><blockquote>
<p>给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。<br/><br>你可以进行如下操作至多 maxOperations 次：<br/><br>选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。<br/><br>比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。<br/><br>你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。<br/><br>请你返回进行上述操作后的最小开销。</p>
</blockquote>
<ul>
<li>bruteforce</li>
</ul>
<p>直接的做法就是不停的找到数组中最大的数，然后在 maxOperations 的次数限制内进行分隔，找到分隔中最小的数据。</p>
<p>为了 o(1) 的找到最大的数，所以使用的 pq 来保存中间数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bruteforce 模拟的方法 通过对递归的方法对最大数进行不停的分隔 得到最后的结果</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSizeBruteForce</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">		PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">				pq.add(num);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> recursion(pq, maxOperations);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursion</span><span class="params">(PriorityQueue&lt;Integer&gt; pq, <span class="keyword">int</span> operations)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">assert</span> !pq.isEmpty();</span><br><span class="line">		<span class="keyword">if</span> (operations == <span class="number">0</span>) <span class="keyword">return</span> pq.peek();</span><br><span class="line">		<span class="keyword">int</span> max = pq.poll();</span><br><span class="line">		<span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max / <span class="number">2</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">int</span> other = max - i;</span><br><span class="line">				pq.add(i);</span><br><span class="line">				pq.add(other);</span><br><span class="line">				res = Math.min(res, recursion(pq, operations - <span class="number">1</span>));</span><br><span class="line">				pq.remove(i);</span><br><span class="line">				pq.remove(other);</span><br><span class="line">		&#125;</span><br><span class="line">		pq.add(max);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>二分查找</li>
</ul>
<p>二分查找可以用于<code>查找最小的最大值，最大的最小值等情况</code>。</p>
<p>那么可以以结果作为区间，每次判断这个最小开销是否能够实现，就可以去缩短遍历的范围。</p>
<p>但是需要知道如何找到能否实现这个函数：</p>
<ul>
<li>当用 mid 去规定最小开销的时候，意味着所有大于 mid 的数字都需要被拆分到最小开销中</li>
<li>拆分的时候，如 num = 8, mid = 4, 那么只需要拆分一次即可，如 num = 17, mid = 7，那么需要拆分成[7,7,3] 需要拆分两次。所以拆分的代价是 num / mid，在 num % mid == 0 时要减一</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找 二分的范围是返回的最小结果</span></span><br><span class="line"><span class="comment">// 即最小代价</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minimumSize</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// nums 中最大的数为 j 的大小</span></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">1000000000</span>;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">				<span class="keyword">int</span> mid = i + (j - i) / <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">if</span> (check(nums, mid, maxOperations)) &#123;</span><br><span class="line">						j = mid - <span class="number">1</span>;</span><br><span class="line">						res = mid;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						i = mid + <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查当前遍历到的 mid 的状态 能不能在 maxOperations 的限制下达到</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> mid, <span class="keyword">int</span> maxOperations)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">				<span class="keyword">if</span> (num % mid == <span class="number">0</span>) &#123;</span><br><span class="line">						res += num / mid - <span class="number">1</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						res += num / mid;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res &lt;= maxOperations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="找出第-k-小的距离对"><a href="#找出第-k-小的距离对" class="headerlink" title="找出第 k 小的距离对"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/find-k-th-smallest-pair-distance/">找出第 k 小的距离对</a></h4><p>距离差定义为 数组中 任意一对数之间的差的绝对值</p>
<ul>
<li>因此找到第 K 个最小距离，一个直观的解法就是，遍历所有的差，放入到只有 k 个数的大顶堆中，那么堆顶都是结果。（memory 爆了）</li>
</ul>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap []<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i] &gt; h[j] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">	<span class="comment">// Push and Pop use pointer receivers because they modify the slice&#x27;s length,</span></span><br><span class="line">	<span class="comment">// not just its contents.</span></span><br><span class="line">	*h = <span class="built_in">append</span>(*h, x.(<span class="keyword">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到 nums 中第k小一对数之间的最短距离（距离为两数之差）</span></span><br><span class="line"><span class="comment">// heap outOfMemory</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">smallestDistancePairWithHeap</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	hp := &amp;IntHeap&#123;&#125;</span><br><span class="line">	heap.Init(hp)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := i + <span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">			heap.Push(hp, <span class="keyword">int</span>(math.Abs(<span class="keyword">float64</span>(nums[i]-nums[j]))))</span><br><span class="line">			<span class="keyword">if</span> hp.Len() &gt; k &#123;</span><br><span class="line">				heap.Pop(hp)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (*hp)[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>另外一个想法就是二分</li>
</ul>
<ol>
<li>二分的范围是从差值的范围出发，即 0 -&gt; max(nums) - min(nums)，那么 max min 可以直接排序取首尾即可</li>
<li>但是如何统计，二分中小于 mid 的差值的数量 以 [1,2,2,3,4] 为例，固定右边界为 4 的时候 1 -&gt; 4 中间可能小于 k 的数字组合为 [1,4] [2,4] [2,4] [3,4] 其结果为 j - i = 4 - 0 (4 的下标 4 1 的下标 1)</li>
</ol>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">smallestDistancePair</span><span class="params">(nums []<span class="keyword">int</span>, k <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	<span class="comment">// i, j 表示的是 nums 中的 数据差 的范围</span></span><br><span class="line">	i, j := <span class="number">0</span>, nums[<span class="built_in">len</span>(nums)<span class="number">-1</span>] - nums[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i &lt; j &#123;</span><br><span class="line">		<span class="comment">// mid 表示的是中间的差值</span></span><br><span class="line">		mid := i + (j - i) / <span class="number">2</span></span><br><span class="line">		<span class="comment">// 找到小于等于 mid 的数值差的数量</span></span><br><span class="line">		count := findDistancePair(nums, mid)</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> count &gt; k &#123;</span><br><span class="line">			j = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> count &lt; k &#123;</span><br><span class="line">			i = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 因为是小于等于 所以可能 mid 是解 也可以是在左边</span></span><br><span class="line">			j = mid</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findDistancePair</span><span class="params">(nums []<span class="keyword">int</span>, distance <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	res := <span class="number">0</span></span><br><span class="line">	<span class="comment">// 固定右边界</span></span><br><span class="line">	i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> j &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">		<span class="comment">// 统计出来的是小于等于 distance 的数量</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; j &amp;&amp; nums[j] - nums[i] &gt; distance &#123;</span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 因为是递增的 如果这个时候 1,2,2,3,4 相当于固定右边界 那么排序完的数组 左边能够形成的满足条件的数对 应该是 j - i 个</span></span><br><span class="line">		res += j - i</span><br><span class="line">		j++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字典树"><a href="#字典树" class="headerlink" title="字典树"></a>字典树</h3><h4 id="猜字谜"><a href="#猜字谜" class="headerlink" title="猜字谜"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/number-of-valid-words-for-each-puzzle/">猜字谜</a></h4><p>暴力解法，用 word 去匹配 puzzle 的 set 超时了。</p>
<p>而原题目中 words 的数量比 puzzles 的数量高一个数量级，因此可以使用 字典树 压缩 word 的数量，用 puzzle 进行比较</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieTree</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> currency;</span><br><span class="line">		TrieTree[] child;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">TrieTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">this</span>.currency = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">// 因为只包含小写字母</span></span><br><span class="line">				<span class="keyword">this</span>.child = <span class="keyword">new</span> TrieTree[<span class="number">26</span>];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span>[] word)</span> </span>&#123;</span><br><span class="line">				TrieTree cur = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">char</span> c : word) &#123;</span><br><span class="line">						<span class="keyword">if</span> (cur.child[c - <span class="string">&#x27;a&#x27;</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">								cur.child[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> TrieTree();</span><br><span class="line">						&#125;</span><br><span class="line">						cur = cur.child[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// currency 表示有一个 word 到达了这个底</span></span><br><span class="line">				cur.currency++;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findNumOfValidWords</span><span class="params">(String[] words, String[] puzzles)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 因为实际上并不在意 word 的顺序 而且根据题目要求 word 不定长 而且比 puzzle 大 因为 puzzle 是 7 为固定长度</span></span><br><span class="line">		<span class="comment">// 所以固定 word 为 字符树</span></span><br><span class="line"></span><br><span class="line">		TrieTree root = <span class="keyword">new</span> TrieTree();</span><br><span class="line">		<span class="comment">// 加入字典树中相当于 压缩了 words</span></span><br><span class="line">		<span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">				<span class="comment">// 排序去重加入 因为这样才能统计 currency 并进行压缩</span></span><br><span class="line">				root.add(getCharArray(word));</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;(puzzles.length);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; puzzles.length; i++) &#123;</span><br><span class="line">				res.add(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 比较 puzzle 与 字典树</span></span><br><span class="line">		<span class="comment">// puzzle 最大深度为 7</span></span><br><span class="line">		<span class="comment">// 最后只需要加上 currency 即可</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; puzzles.length; i++) &#123;</span><br><span class="line">				<span class="keyword">char</span>[] puzzleArray = getCharArray(puzzles[i]);</span><br><span class="line">				<span class="keyword">char</span> required = puzzles[i].charAt(<span class="number">0</span>);</span><br><span class="line">				res.set(i, recursionSearch(root, puzzleArray, <span class="number">0</span>, required));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// puzzle 去匹配字典树 找到一个 节点 返回其 currency 即对应的 word 数量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">recursionSearch</span><span class="params">(TrieTree node, <span class="keyword">char</span>[] puzzleArray, <span class="keyword">int</span> pos, <span class="keyword">char</span> required)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// puzzle 最深就打到这儿</span></span><br><span class="line">		<span class="keyword">if</span> (pos == puzzleArray.length) &#123;</span><br><span class="line">				<span class="keyword">return</span> node.currency;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 可以选择用当前 pos 这个位置来匹配 然后都 ++</span></span><br><span class="line">		<span class="keyword">int</span> res = recursionSearch(node.child[puzzleArray[pos] - <span class="string">&#x27;a&#x27;</span>], puzzleArray, pos + <span class="number">1</span>, required);</span><br><span class="line">		<span class="comment">// 因为去重了 所以 required 等于的时候 一定要匹配</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 不等于的时候，可以维持 node 引用 然后不匹配 跳过 puzzle 的这个字符 继续往下走</span></span><br><span class="line">		<span class="keyword">if</span> (puzzleArray[pos] != required) &#123;</span><br><span class="line">				<span class="comment">// + 是因为 可以用多条路走 实际上就是要或者不要</span></span><br><span class="line">				res += recursionSearch(node, puzzleArray, pos + <span class="number">1</span>, required);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] getCharArray(String word) &#123;</span><br><span class="line">		<span class="keyword">char</span>[] tmp = word.toCharArray();</span><br><span class="line">		Arrays.sort(tmp);</span><br><span class="line">		<span class="keyword">int</span> newIndex = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (r &lt; tmp.length) &#123;</span><br><span class="line">				<span class="keyword">while</span> (r &lt; tmp.length &amp;&amp; tmp[r] == tmp[l]) &#123;</span><br><span class="line">						r++;</span><br><span class="line">				&#125;</span><br><span class="line">				tmp[newIndex++] = tmp[l];</span><br><span class="line">				l = r;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[newIndex];</span><br><span class="line">		System.arraycopy(tmp, <span class="number">0</span>, res, <span class="number">0</span>, newIndex);</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h3><h4 id="基本计算器"><a href="#基本计算器" class="headerlink" title="基本计算器"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/basic-calculator/">基本计算器</a></h4><p>其本质是一个 中值表达式 求值。实际上只需要注意 符号的 优先级即可。（PS：·· 好多细节没注意到 就会 gg）</p>
<p>TODO: 中值表达式 转成 逆波兰表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicCalculator_224</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">char</span> operator, <span class="keyword">int</span> n1, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (operator) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> n1 + n2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> n2 - n1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符的优先级！！！ <span class="doctag">TODO:</span> 中值表达式 转 逆波兰表达式</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中缀转后缀</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 只有 数字 + - ( )</span></span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; number = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Deque&lt;Character&gt; operators = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (s.length() &gt; <span class="number">0</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            s = <span class="string">&#x27;0&#x27;</span> + s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        s = s.replaceAll(<span class="string">&quot;\\(\\+&quot;</span>, <span class="string">&quot;(0+&quot;</span>);</span><br><span class="line">        s = s.replaceAll(<span class="string">&quot;\\(-&quot;</span>, <span class="string">&quot;(0-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); ) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 需要弹出栈 直到优先级相等 因为只有 - + 所以需要一直弹出到 -</span></span><br><span class="line">                <span class="keyword">while</span> (operators.size() &gt; <span class="number">0</span> &amp;&amp; operators.peekLast() != <span class="string">&#x27;+&#x27;</span> &amp;&amp; operators.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> first = number.removeLast();</span><br><span class="line">                    <span class="keyword">int</span> second = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!number.isEmpty()) second = number.removeLast();</span><br><span class="line">                    number.add(operate(operators.removeLast(), first, second));</span><br><span class="line">                &#125;</span><br><span class="line">                operators.add(c);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (operators.size() &gt; <span class="number">0</span> &amp;&amp; operators.peekLast() == <span class="string">&#x27;-&#x27;</span> &amp;&amp; operators.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> first = number.removeLast();</span><br><span class="line">                    <span class="keyword">int</span> second = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!number.isEmpty()) second = number.removeLast();</span><br><span class="line">                    number.add(operate(operators.removeLast(), first, second));</span><br><span class="line">                &#125;</span><br><span class="line">                operators.add(c);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                operators.add(c);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 弹栈</span></span><br><span class="line">                <span class="keyword">while</span> (operators.size() &gt; <span class="number">0</span> &amp;&amp; operators.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> first = number.removeLast();</span><br><span class="line">                    <span class="keyword">int</span> second = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (!number.isEmpty()) second = number.removeLast();</span><br><span class="line">                    number.add(operate(operators.removeLast(), first, second));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 去掉 (</span></span><br><span class="line">                operators.removeLast();</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 数字</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.length() &amp;&amp; s.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">                    num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                number.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!operators.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> first = number.removeLast();</span><br><span class="line">            <span class="keyword">int</span> second = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!number.isEmpty()) second = number.removeLast();</span><br><span class="line">            number.add(operate(operators.removeLast(), first, second));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> number.getLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BasicCalculator_224().calculate( <span class="string">&quot;(6)-(8)-(7)+(1+(6))&quot;</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BasicCalculator_224().calculate( <span class="string">&quot;1 + 1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BasicCalculator_224().calculate( <span class="string">&quot; 2-1 + 2 &quot;</span>));</span><br><span class="line">        System.out.println(<span class="keyword">new</span> BasicCalculator_224().calculate( <span class="string">&quot;(1+(4+5+2)-3)+(6+8)&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="数学问题"><a href="#数学问题" class="headerlink" title="数学问题"></a>数学问题</h3><h4 id="1802-有界数组中指定下标处的最大值"><a href="#1802-有界数组中指定下标处的最大值" class="headerlink" title="1802. 有界数组中指定下标处的最大值"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-value-at-a-given-index-in-a-bounded-array/">1802. 有界数组中指定下标处的最大值</a></h4><blockquote>
<p>给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：<br>nums.length == n<br>nums[i] 是 正整数 ，其中 0 &lt;= i &lt; n<br>abs(nums[i] - nums[i+1]) &lt;= 1 ，其中 0 &lt;= i &lt; n-1<br>nums 中所有元素之和不超过 maxSum<br>nums[index] 的值被 最大化<br>返回你所构造的数组中的 nums[index] 。</p>
</blockquote>
<p>这个问题就是说构建一个只有正整数的数组，且相邻数字之间差值不能超过 1，问 如何构建才能使 index 下标位置的数最大。</p>
<p>其实偏向于贪心的策略，既然要 index 最大，那么每次遍历的时候，我都在 index 上 +1，看在没有打到 maxSum 的时候能够给这个地方添加几次。最后其实际的生长过程可以看做下面的一个过程。</p>
<blockquote>
<p>例输入：n = 4, index = 2, maxSum = 6</p>
</blockquote>
<ol>
<li>构建基础数组，因为要求每个数字都为正整数，因此最小为 1</li>
</ol>
<pre>
1 1 1 1
    _
    |
  index 
</pre>

<ol start="2">
<li>从 index 开始生长</li>
</ol>
<pre>
    2 

1 1 1 1
    _
    |
  index 
</pre>

<p>这个时候 已经不能再加 1 了 所以直接返回 2</p>
<p>所以其实就是构建一个题型的台状结构，每层比下一层只会高 1 个，最后到 index 的位置最高即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> index, <span class="keyword">int</span> maxSum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为是正整数 所以相当于每个数字至少要填上1</span></span><br><span class="line">        <span class="keyword">int</span> remain = maxSum - n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在 index 位置填入的是 1</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 然后根据剩下的数字 从 index 开始增加</span></span><br><span class="line">        <span class="keyword">int</span> l = index, r = index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &gt; <span class="number">0</span> || r &lt; n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 在 l 到 r 之间的数字 加 1</span></span><br><span class="line">            <span class="keyword">int</span> len = r - l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (remain &gt;= len) &#123;</span><br><span class="line">                <span class="comment">// index 对应位置的数字 一定是在 l,r 之间的</span></span><br><span class="line">                res += <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 因为相邻不能相差 1 所以 每次 l、r 向外增加 1 位长度</span></span><br><span class="line">                l = Math.max(<span class="number">0</span>, l - <span class="number">1</span>);</span><br><span class="line">                r = Math.min(r + <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">                remain -= len;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还剩下 全部加一</span></span><br><span class="line">        res += remain / n;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="132-模式"><a href="#132-模式" class="headerlink" title="132 模式"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/132-pattern/submissions/">132 模式</a></h3><p>在一个数组中找到下标 i &lt; j &lt; k 满足 nums[i] &lt; nums[k] &lt; nums[j] 也就是说 j 对应的数值 是三个中最大的 k 次之，最小的是 i</p>
<p>那么很容易知道 i 的值其实需要越小越好，越小的话，后面 k、j 的条件就最好满足，因此第一步就是求出从左向右的最小值数组</p>
<ul>
<li>brute force 的方法(o(n^2))</li>
</ul>
<p>既然已经知道 i 取从左向右的最小值，那么只想就需要确定 j &lt; k 且 nums[i] &lt; nums[k] &lt; nums[j]，也就是在后续的数组中找到一对逆序的数组，那么 o(n^2) 的算法就很好写了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 1 3 2 模式</span></span><br><span class="line"><span class="comment">// bruteforce 的方法 因为要找到 i &lt; j &lt; k 满足 nums[i] &lt; nums[k] &lt; nums[j] 的格式</span></span><br><span class="line"><span class="comment">// 即中间的数是最大 那么 nums[i] 一定是最小 所以先维护一个 leftMin 表示从左侧开始的最小值</span></span><br><span class="line"><span class="comment">// 然后开始遍历数组 找到一个 逆序数对 且逆序数对中的最小值 大于 leftMin 的值 即可找到</span></span><br><span class="line"><span class="comment">// 所以是 o(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132patternBruteForce</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>[] leftMin = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">		leftMin[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">				leftMin[i] = Math.min(leftMin[i - <span class="number">1</span>], nums[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 先固定一个最小值</span></span><br><span class="line">		<span class="comment">// 然后在找到一个逆序的点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (nums[j] &gt; leftMin[i] &amp;&amp; nums[i] &gt; nums[j]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化的算法（o(n)）</li>
</ul>
<p>之前的算法寻找逆序的时候，是在确定了 j 值 的情况下从前向后寻找 k 值，如果能够知道之前访问的过的 j 值，作为当前 k 值，那么就可以进一步的降低复杂度。</p>
<p>因为，在满足 nums[j] &gt; leftMin[j] (即 nums[i]) 时，如果 k 值正好取到小于 nums[j] 的值 且 大于 nums[i] 时满足条件。所以 nums[k] 的值 在取小于 nums[j] 的值的时候 越大越好，因为这样才可能更大程度的满足 nums[k] &gt; nums[i] 的条件。</p>
<p>所以使用一个单调栈来保存 j 之后遍历的历史情况，越靠近栈底的值越大，只需要取到栈中需要的满足小于 nums[j] 的最大值即可。</p>
<p>这样 栈中还保存着较大的值，之后再遍历的时候，还以用这个比 nums[j] 大的值，与 j 之前更大的值匹配成 132 组合。 而 j 之后的较小值，如何满足题设条件，会在第一次访问的时候就返回了，所以也不会存在漏的结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>[] leftMin = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">		leftMin[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">				leftMin[i] = Math.min(leftMin[i - <span class="number">1</span>], nums[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从后向前找 因为要找的是 j &lt; k nums[j] &gt; nums[k] 的结果</span></span><br><span class="line">		<span class="comment">// 那么只需要保存遍历的 j 之后的比 nums[j] 小 且比 leftMin 大的最大值 这样就可以满足要求了</span></span><br><span class="line">		<span class="comment">// 所以 stack 中保存的是 j 之后的 较大的值 如果能够在其中找到一个小于 nums[j] 的值 就证明可行</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="comment">// 必须要比左侧最小的大 才能比较</span></span><br><span class="line">				<span class="keyword">if</span> (nums[j] &gt; leftMin[j]) &#123;</span><br><span class="line">						<span class="comment">// 因为要在 j 右边找一个更小的 nums[k] 所以 比 nums[j] 小的 都出栈</span></span><br><span class="line">						<span class="comment">// 比较其中的最大值与 leftMin 的大小既可以知道</span></span><br><span class="line">						<span class="keyword">int</span> remove = Integer.MIN_VALUE;</span><br><span class="line">						<span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peekLast() &lt; nums[j]) &#123;</span><br><span class="line">								remove = stack.removeLast();</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (remove &gt; leftMin[j]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">						stack.addLast(nums[j]);</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大子序和"><a href="#最大子序和" class="headerlink" title="最大子序和"></a>最大子序和</h3><h4 id="简单的题型"><a href="#简单的题型" class="headerlink" title="简单的题型"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray/">简单的题型</a></h4><p>简单的题型如 剑指offer 上所述，只需要用一个数组保存以当前结尾的最大子序和即可。转移的时候，如果之前的最大子序和小于 0，说明应该重新开始计数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || dp[i - <span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除一次得到子数组最大和"><a href="#删除一次得到子数组最大和" class="headerlink" title="删除一次得到子数组最大和"></a><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/maximum-subarray-sum-with-one-deletion/">删除一次得到子数组最大和</a></h4><ul>
<li>直觉想法</li>
</ul>
<p>拿到这个题目的第一个直觉就是跟上面那个基本一致，但是需要删除一个数字，那么删除的这个数字一定存在这样的性质。</p>
<blockquote>
<p>删除这个数字后，有可能左右的最大子序和加起来更大，所以这个数字一定是负数。</p>
</blockquote>
<p>那么，只需要知道这个数字左边和右边的分别的最大子序和即可，那么就可以用两次上面的算法，得到以 i 结尾的从左向右最大子序和 和 以 i 结尾的从右想左的最大子序和即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大子序和的变种 如果中间可以删除一个数字 问能够形成的最大子序和为多少</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumSumWithTwoDirection</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (arr.length == <span class="number">1</span>) <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 因此要删除一个的话 只需要遍历被删除的项即可，然后将以 arr[i] 结尾的左右的最大子序和累加起来即可</span></span><br><span class="line">		<span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">		<span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (left[i] &lt; <span class="number">0</span>) left[i + <span class="number">1</span>] = arr[i];</span><br><span class="line">				<span class="keyword">else</span> left[i + <span class="number">1</span>] = left[i] + arr[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = arr.length - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">				<span class="keyword">if</span> (right[j + <span class="number">1</span>] &lt; <span class="number">0</span>) right[j] = arr[j];</span><br><span class="line">				<span class="keyword">else</span> right[j] = right[j + <span class="number">1</span>] + arr[j];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> res = Math.max(left[arr.length], right[<span class="number">0</span>]);</span><br><span class="line">		<span class="comment">// 遍历需要删除的负数点 因为只有负数才需要删除 删除后才可能达到需要的连续两个段的最大值</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">				<span class="comment">// 只有小于 0 才需要分隔</span></span><br><span class="line">				<span class="keyword">if</span> (arr[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="comment">// 注意的是需要分离开 i == 0 i == arr.length - 1 因为 默认是0 会影响 res 为负数的情况</span></span><br><span class="line">						<span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">								res = Collections.max(Arrays.asList(right[i + <span class="number">1</span>], res));</span><br><span class="line">						&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">								res = Collections.max(Arrays.asList(left[i], res));</span><br><span class="line">						&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">								<span class="comment">// 平时的话 去掉这个值 只需要在三部分中取较大值与 res 比较即可</span></span><br><span class="line">								res = Collections.max(Arrays.asList(left[i] + right[i + <span class="number">1</span>], left[i], right[i + <span class="number">1</span>], res));</span><br><span class="line">						&#125;</span><br><span class="line">				&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 没有小于 0 的话 说明全是正数</span></span><br><span class="line">		<span class="comment">// 返回和即可</span></span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>两个 dp 数组保存状态</li>
</ul>
<p>那么可以使用一个循环得到结果。</p>
<ol>
<li>仍然需要一个数组保存以 arr[i] 结尾时的最大子序和</li>
<li>需要一个数组保存以 arr[i] 结尾时删除一个数字的最大子序和</li>
</ol>
<p>那么删除的这个数字可能是遍历的 arr[i] 或者 之前就已经删除了一个数字，arr[i] 不能被删除。所以<strong>第2个</strong>数组的更新策略即<code>deleteOne[i] = Math.max(deleteOne[i - 1] + arr[i], dp[i - 1])</code>。</p>
<p>即保留当前的 arr[i] 那么只能取之前删除了一次的最大子序和 和 删除当前的 arr[i]，那么就要去之前没有删除数字的最大子序和 dp[i - 1]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">		<span class="comment">// 保存删除一个的结果</span></span><br><span class="line">		<span class="keyword">int</span>[] deleteOne = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"></span><br><span class="line">		dp[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="comment">// 最小值到达 -10^ (4)</span></span><br><span class="line">		deleteOne[<span class="number">0</span>] = -<span class="number">100000</span>;</span><br><span class="line">		<span class="keyword">int</span> res = Math.max(dp[<span class="number">0</span>], deleteOne[<span class="number">0</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">				dp[i] = Math.max(arr[i], dp[i - <span class="number">1</span>] + arr[i]);</span><br><span class="line">				<span class="comment">// 要删除一个数的话 要么保留当前数 和 之前删除一个数形成的最大值比较 要么删除当前这个数 与之前保存的最大值比较</span></span><br><span class="line">				deleteOne[i] = Math.max(deleteOne[i - <span class="number">1</span>] + arr[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">				res = Math.max(res, Math.max(dp[i], deleteOne[i]));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css"></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/leetcode/">leetcode</a></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/02/24/sort/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">sort</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/04/24/interview-1/"><span class="level-item">春招java后端实习岗笔试总结</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "49a0c57d544b4b56cf06da02a1a49ed2",
            repo: "blog-comment",
            owner: "MajexH",
            clientID: "229758a40bcba2667c41",
            clientSecret: "543e850c3a7187040f8eebc05bd232f0f0a3e767",
            admin: ["MajexH"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#leetcode-例题"><span class="level-left"><span class="level-item">1</span><span class="level-item">leetcode 例题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#kmp-算法"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">kmp 算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#最短回文串"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">最短回文串</span></span></a></li></ul></li><li><a class="level is-mobile" href="#单调栈"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">单调栈</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#找出最具竞争力的子序列"><span class="level-left"><span class="level-item">1.2.1</span><span class="level-item">找出最具竞争力的子序列</span></span></a></li><li><a class="level is-mobile" href="#下一个更大元素-II"><span class="level-left"><span class="level-item">1.2.2</span><span class="level-item">下一个更大元素 II</span></span></a></li><li><a class="level is-mobile" href="#移调-k-位数字"><span class="level-left"><span class="level-item">1.2.3</span><span class="level-item">移调 k 位数字</span></span></a></li></ul></li><li><a class="level is-mobile" href="#滑动窗口"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">滑动窗口</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#最小覆盖子串"><span class="level-left"><span class="level-item">1.3.1</span><span class="level-item">最小覆盖子串</span></span></a></li><li><a class="level is-mobile" href="#K-个不同整数的子数组"><span class="level-left"><span class="level-item">1.3.2</span><span class="level-item">K 个不同整数的子数组</span></span></a></li><li><a class="level is-mobile" href="#最大连续-1-的个数-III"><span class="level-left"><span class="level-item">1.3.3</span><span class="level-item">最大连续 1 的个数 III</span></span></a></li><li><a class="level is-mobile" href="#绝对差不超过限制的最长连续子数组"><span class="level-left"><span class="level-item">1.3.4</span><span class="level-item">绝对差不超过限制的最长连续子数组</span></span></a></li><li><a class="level is-mobile" href="#爱生气的书店老板"><span class="level-left"><span class="level-item">1.3.5</span><span class="level-item">爱生气的书店老板</span></span></a></li></ul></li><li><a class="level is-mobile" href="#二进制题目"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">二进制题目</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#连接连续二进制数字"><span class="level-left"><span class="level-item">1.4.1</span><span class="level-item">连接连续二进制数字</span></span></a></li><li><a class="level is-mobile" href="#模拟除法"><span class="level-left"><span class="level-item">1.4.2</span><span class="level-item">模拟除法</span></span></a></li><li><a class="level is-mobile" href="#只出现一次的数字-II"><span class="level-left"><span class="level-item">1.4.3</span><span class="level-item">只出现一次的数字 II</span></span></a></li><li><a class="level is-mobile" href="#只出现一次的数字-III"><span class="level-left"><span class="level-item">1.4.4</span><span class="level-item">只出现一次的数字 III</span></span></a></li><li><a class="level is-mobile" href="#数字按位与"><span class="level-left"><span class="level-item">1.4.5</span><span class="level-item">数字按位与</span></span></a></li></ul></li><li><a class="level is-mobile" href="#动态规划"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">动态规划</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#最后一块石头的重量-II"><span class="level-left"><span class="level-item">1.5.1</span><span class="level-item">最后一块石头的重量 II</span></span></a></li><li><a class="level is-mobile" href="#最长子序列套题"><span class="level-left"><span class="level-item">1.5.2</span><span class="level-item">最长子序列套题</span></span></a></li><li><a class="level is-mobile" href="#摆动序列"><span class="level-left"><span class="level-item">1.5.3</span><span class="level-item">摆动序列</span></span></a></li><li><a class="level is-mobile" href="#类似摆动序列的题目-978-最长湍流子数组"><span class="level-left"><span class="level-item">1.5.4</span><span class="level-item">类似摆动序列的题目 978. 最长湍流子数组</span></span></a></li><li><a class="level is-mobile" href="#俄罗斯套娃信封问题"><span class="level-left"><span class="level-item">1.5.5</span><span class="level-item">俄罗斯套娃信封问题</span></span></a></li><li><a class="level is-mobile" href="#解码方法"><span class="level-left"><span class="level-item">1.5.6</span><span class="level-item">解码方法</span></span></a></li><li><a class="level is-mobile" href="#子序列"><span class="level-left"><span class="level-item">1.5.7</span><span class="level-item">子序列</span></span></a></li><li><a class="level is-mobile" href="#打家劫舍系列题"><span class="level-left"><span class="level-item">1.5.8</span><span class="level-item">打家劫舍系列题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#贪心算法"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">贪心算法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#转换罗马字"><span class="level-left"><span class="level-item">1.6.1</span><span class="level-item">转换罗马字</span></span></a></li><li><a class="level is-mobile" href="#jumpGame"><span class="level-left"><span class="level-item">1.6.2</span><span class="level-item">jumpGame</span></span></a></li></ul></li><li><a class="level is-mobile" href="#递归"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">递归</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#执行乘法运算的最大分数"><span class="level-left"><span class="level-item">1.7.1</span><span class="level-item">执行乘法运算的最大分数</span></span></a></li><li><a class="level is-mobile" href="#括号生成"><span class="level-left"><span class="level-item">1.7.2</span><span class="level-item">括号生成</span></span></a></li><li><a class="level is-mobile" href="#正则表达式匹配"><span class="level-left"><span class="level-item">1.7.3</span><span class="level-item">正则表达式匹配</span></span></a></li></ul></li><li><a class="level is-mobile" href="#数据结构"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">数据结构</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#栈和队列"><span class="level-left"><span class="level-item">1.8.1</span><span class="level-item">栈和队列</span></span></a></li><li><a class="level is-mobile" href="#链表"><span class="level-left"><span class="level-item">1.8.2</span><span class="level-item">链表</span></span></a></li><li><a class="level is-mobile" href="#树"><span class="level-left"><span class="level-item">1.8.3</span><span class="level-item">树</span></span></a></li><li><a class="level is-mobile" href="#图"><span class="level-left"><span class="level-item">1.8.4</span><span class="level-item">图</span></span></a></li><li><a class="level is-mobile" href="#拓扑排序"><span class="level-left"><span class="level-item">1.8.5</span><span class="level-item">拓扑排序</span></span></a></li><li><a class="level is-mobile" href="#最短路径"><span class="level-left"><span class="level-item">1.8.6</span><span class="level-item">最短路径</span></span></a></li><li><a class="level is-mobile" href="#1786-从第一个节点出发到最后一个节点的受限路径数"><span class="level-left"><span class="level-item">1.8.7</span><span class="level-item">1786. 从第一个节点出发到最后一个节点的受限路径数</span></span></a></li></ul></li><li><a class="level is-mobile" href="#博弈问题"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">博弈问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#预测赢家"><span class="level-left"><span class="level-item">1.9.1</span><span class="level-item">预测赢家</span></span></a></li><li><a class="level is-mobile" href="#石子游戏"><span class="level-left"><span class="level-item">1.9.2</span><span class="level-item">石子游戏</span></span></a></li><li><a class="level is-mobile" href="#石子游戏-VII"><span class="level-left"><span class="level-item">1.9.3</span><span class="level-item">石子游戏 VII</span></span></a></li></ul></li><li><a class="level is-mobile" href="#杂题"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">杂题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#递增的三元子序列"><span class="level-left"><span class="level-item">1.10.1</span><span class="level-item">递增的三元子序列</span></span></a></li><li><a class="level is-mobile" href="#二分"><span class="level-left"><span class="level-item">1.10.2</span><span class="level-item">二分</span></span></a></li><li><a class="level is-mobile" href="#字典树"><span class="level-left"><span class="level-item">1.10.3</span><span class="level-item">字典树</span></span></a></li><li><a class="level is-mobile" href="#计算器"><span class="level-left"><span class="level-item">1.10.4</span><span class="level-item">计算器</span></span></a></li><li><a class="level is-mobile" href="#数学问题"><span class="level-left"><span class="level-item">1.10.5</span><span class="level-item">数学问题</span></span></a></li><li><a class="level is-mobile" href="#132-模式"><span class="level-left"><span class="level-item">1.10.6</span><span class="level-item">132 模式</span></span></a></li><li><a class="level is-mobile" href="#最大子序和"><span class="level-left"><span class="level-item">1.10.7</span><span class="level-item">最大子序和</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/images/header.jpg" alt="Majexh"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Majexh</p><p class="is-size-6 is-block">苦逼学生党</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing, China</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">15</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">18</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="http://github.com/MajexH" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="http://github.com/MajexH"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/algorithm/"><span class="level-start"><span class="level-item">algorithm</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/code/"><span class="level-start"><span class="level-item">code</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/categories/life/"><span class="level-start"><span class="level-item">life</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/tutorial/"><span class="level-start"><span class="level-item">tutorial</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/code/"><span class="tag">code</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/concurrent/"><span class="tag">concurrent</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hash/"><span class="tag">hash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hello-world/"><span class="tag">hello world</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/kmp/"><span class="tag">kmp</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/qrcode/"><span class="tag">qrcode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sort/"><span class="tag">sort</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/string/"><span class="tag">string</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/summary/"><span class="tag">summary</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%90%E6%A7%BD/"><span class="tag">吐槽</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE%E7%AE%97%E6%B3%95/"><span class="tag">图算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B1%82%E8%81%8C/"><span class="tag">求职</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AC%94%E8%AF%95/"><span class="tag">笔试</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-13T07:09:08.000Z">2021-03-13</time></p><p class="title"><a href="/2021/03/13/hash-code/">hash-code</a></p><p class="categories"><a href="/categories/code/">code</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-09T13:42:47.000Z">2021-03-09</time></p><p class="title"><a href="/2021/03/09/design-pattern/">design-pattern</a></p><p class="categories"><a href="/categories/code/">code</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-07T12:51:36.000Z">2021-03-07</time></p><p class="title"><a href="/2021/03/07/kmp/">kmp</a></p><p class="categories"><a href="/categories/algorithm/">algorithm</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-03-07T08:31:21.000Z">2021-03-07</time></p><p class="title"><a href="/2021/03/07/graph/">简单图算法</a></p><p class="categories"><a href="/categories/%E7%AE%97%E6%B3%95/">算法</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-02-24T14:21:07.000Z">2021-02-24</time></p><p class="title"><a href="/2021/02/24/sort/">sort</a></p><p class="categories"><a href="/categories/algorithm/">algorithm</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/03/"><span class="level-start"><span class="level-item">三月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/02/"><span class="level-start"><span class="level-item">二月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/01/"><span class="level-start"><span class="level-item">一月 2021</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/09/"><span class="level-start"><span class="level-item">九月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/05/"><span class="level-start"><span class="level-item">五月 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/03/"><span class="level-start"><span class="level-item">三月 2019</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/01/"><span class="level-start"><span class="level-item">一月 2019</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Majexh</a><p class="is-size-7"><span>&copy; 2021 Majexh</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>
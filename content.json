{"pages":[{"title":"å…³äºæˆ‘","text":"è‹¦é€¼å­¦ç”Ÿå…š è¯»ç ”ä¸­","link":"/about/index.html"}],"posts":[{"title":"18å¹´å¹´ç»ˆæ€»ç»“","text":"&emsp;&emsp;18 å¹´å¹´ç»ˆæ€»ç»“è™½ç„¶ä¼šè¿Ÿåˆ°ï¼Œä½†æ°¸è¿œä¸ä¼šç¼ºå¸­ å›é¡¾ 2018 å¹´ è€ƒç ” ï¼ˆæ˜¯ä¸æ˜¯è¯¥ç®—åˆ° 2017 å‘€ï¼‰2333 è€ƒç ”å¤è¯• æœ¬ç§‘æ¯•ä¸š æ¯•ä¸šè®¾è®¡&amp;ç­”è¾© è¯»ç ” åŠ©æ•™ å®éªŒå®¤é¡¹ç›® å­¦ä¹ å‰ç«¯åŸºç¡€ æ­å»ºåšå®¢ï¼ˆå§‘ä¸”ç°åœ¨ç®—æ˜¯æ­äº†ä¸ªé›å½¢å‡ºæ¥äº†ï¼‰ è¡¥ java åŸºç¡€ï¼ˆç®—äº†ä¹°äº†ä¹¦ è¿˜æ²¡çœ‹å®Œçš„æ„Ÿè§‰ï¼‰ ç®—æ³•ï¼ˆç®—æ˜¯å‡†å¤‡å¼€å§‹è¡¥åŸºç¡€å§ï¼‰ spring boot &amp; spring cloudï¼ˆäº†è§£ä¸‹ç°åœ¨è¾ƒâ€œæ–°â€çš„å¾®æœåŠ¡æ¶æ„å§ï¼‰ è€ƒç ”åˆè¯•&emsp;&emsp;ä» 17 å¹´ä¸ŠåŠå¹´å¼€å§‹å‡†å¤‡åˆ° 17 å¹´ 12 æœˆ 22 å·è€ƒè¯•,æ•´ä¸ª 17 å¹´éƒ½åœ¨å¤ä¹ ä¸­åº¦è¿‡ã€‚æœ¬æ¥å¼€å§‹çš„å‡†å¤‡å¦‚ä¸‹ï¼š 17 å¹´ä¸ŠåŠå¹´è¿‡å®Œæ•°äºŒçš„ä¸¤é—¨æ•°å­¦çš„ç¬¬ä¸€é &amp; è‹±è¯­çš„å•è¯ æš‘å‡ \b è¿‡ç¬¬äºŒéå¼ºåŒ– &amp; å¤ä¹ æ”¿æ²» 9 æœˆä»½å¼€å§‹è¿‡æ•°å­¦çš„ç¬¬ä¸‰é &amp; å„ç§‘çš„å¾€å¹´è¯•é¢˜ï¼ˆåŒ…æ‹¬æ•°ä¸€ï¼‰&amp; ä¸“ä¸šè¯¾ &emsp;&emsp;ç»“æœæœ€åå˜æˆäº†ï¼š ä¸ŠåŠå¹´åŠæ‘¸é±¼çŠ¶æ€ï¼Œç»“æœæœ€ååªæŠŠé«˜æ•°çš„ä¸ŠåŠå†Œç»™å¤ä¹ å®Œåšå®Œé¢˜ï¼›è‹±è¯­çš„å•è¯ä¹Ÿå¤§æ¦‚èƒŒäº†ä¸€åŠ æš‘æœŸå­¦æ ¡è¿˜è§„å®šå¿…é¡»è‡ªä¸»å®ä¹ ï¼Œè‡ªå·±æ‰¾å®ä¹ ã€‚äºæ˜¯ä¹æ•´ä¸ªæš‘å‡å¤§éƒ¨åˆ†æ˜¯å’•å’•å’•çŠ¶æ€ã€‚æ¯•ç«Ÿæ‰¾äº†è€å¸ˆå®éªŒå®¤ï¼Œæ¥äº†ä¸€ä¸ªæ´»å„¿ï¼Œä»é›¶å¼€å§‹å…¥é—¨ \bjava webã€‚å¹¸è€Œåœ¨å®¤å‹çš„å¸®åŠ©ä¸‹è¿˜æ˜¯é¡ºé¡ºåˆ©åˆ©çš„äº¤å·®èµ°äººã€‚ è™½è¯´æš‘å‡è¿˜å»æŠ¥äº†ä¸ªæ•°å­¦çš„å¤ä¹ ç­ï¼ŒèŠ±è´¹äº† 2K å¤§æ´‹å¤ä¹ ä¸¤å‘¨ï¼Œæ„Ÿè§‰è¿˜éå¸¸ä¸€èˆ¬ï¼Œå¤§éƒ¨åˆ†è‡ªå·±çœ‹ä¹¦åšé¢˜çš„æ—¶å€™éƒ½èƒ½æ€»ç»“ \b å‡ºæ¥ï¼Œåªæœ‰ä¸€é“é¢˜å’Œä¸€ä¸ªæé™å››åˆ™è¿ç®—çš„æ¡ä»¶å°è±¡æ·±åˆ»ã€‚æ€»ä¹‹å°±æ˜¯ \b ç€å®ä¸å¤ªå€¼ï¼Œå¦‚è‹¥çœŸéœ€è¦è¡¥ä¹ ï¼Œè¿˜ä¸å¦‚æŠ¥å…¨ç¨‹ç­ï¼ˆç”šè‡³çº¿ä»£æ˜¯è¾¹ä¸Šè¯¾è¾¹å¤ä¹ çš„ï¼‰ï¼ˆæ¯å¤©ä¸Šè¯¾éƒ½æ˜¯åæœ€åé¢ä¸¤æ’ï¼Œç„¶è€Œä¸æ˜¯å› ä¸ºå»å¾—æ™šï¼Œåªæ˜¯å› ä¸º\bå‰é¢çš„æ˜¯ç•™ç»™VIPå’Œå…¨ç¨‹ç­çš„ï¼Œæ¯ä¸ªä½ç½®ä¸Šè¿˜æœ‰ç¼–å·ï¼ŒçœŸæ˜¯å¤ªçœŸå®äº†ï¼‰ ä» 9\b\b æœˆä»½ä¸­ä¸‹æ—¬å¼€å§‹ç€æ‰‹ç¬¬äºŒéæ•°å­¦å¤ä¹  + æ”¿æ²»å¤ä¹ ã€‚æ¯å¤©ä¸Šåˆ 10 ç‚¹èµ·åºŠï¼ˆåæ­£ä¹Ÿä¸å»å›¾ä¹¦é¦†æŠ¢ä½ç½®ï¼‰èƒŒä¸¤ä¸ªå°æ—¶å•è¯ï¼Œåƒå®Œé¥­å»è‡ªä¹ ï¼Œæ™šä¸Š 10 ç‚¹å›æ¥ï¼Œ12 ç‚¹ç¡è§‰ æœŸé—´æ‰¾äº†ä¸€ä½ dalao å» \b ä¸€èµ·å¤ä¹ ï¼Œä¸å¾—ä¸è¯´æ²¡å¼€æš–æ°”ä¹‹å‰çš„ä¸»æ¥¼å’Œä¸»å— 10 æœˆä»½å’Œ 11 æœˆä»½æ˜¯çœŸçš„å†· 11 æœˆå¼€é¢˜ç›´æ¥è¢«å¦ï¼Œ1 æœˆé‡å¼€ æœ€åä¸å¾—ä¸è¯´è‚–ç§€è£è€å¸ˆ ğŸ‚ğŸºï¼Œç”šè‡³è¿˜è®°å¾—è€ƒè¯•å‰å‡ å¤©åœ¨ä¸»æ¥¼èµ°é“èƒŒè‚–å››çš„æ„Ÿè§‰ï¼Œä¸å¾—ä¸è¯´æœ€åè¿˜æ˜¯æŒºç¨³çš„ emmmï¼Œå› ä¸ºæˆ‘ä»¬ç³»çš„ä¸“ä¸šè¯¾è€ƒè¯•æ˜¯ C è¯­è¨€å’Œæ•°æ®ç»“æ„ï¼ŒèŠ±äº†ä¸€å‘¨æ—¶é—´åšäº†åšå¾€å¹´çš„é¢˜ç›®ï¼Œæœ€åç»“æœä¹Ÿé¢‡ä¸ºæ»¡æ„ &emsp;&emsp;è€ƒç ”çš„ \b åˆè¯•è¿˜æ˜¯å…¨å‡­å®åŠ›çš„ï¼Œå¤§å®¶éƒ½åœ¨åŒä¸€ä¸ªèµ·ç‚¹ä¸Šï¼ŒåšåŒä¸€ä¸ªå·å­ï¼Œé¢‡æœ‰ä¸€ç§é«˜è€ƒçš„æ„Ÿè§‰ï¼Œå¯æ˜¯å´ä¹Ÿå›ä¸åˆ°é«˜è€ƒçš„çŠ¶æ€äº†ï¼ˆè™½è¯´é«˜è€ƒä¹Ÿä¸æƒ³å†ç»å†äº†ï¼‰ã€‚æœ€åæ€»ç»“åˆè¯•çš„ç»å†ï¼Œæ„Ÿè§‰è¿˜æ˜¯æœ‰å‡ ç‚¹å¯ä»¥è¯´ä¸€ä¸‹ï¼š æ¯å¹´çš„è€ƒè¯•èŒƒå›´éƒ½ä¼šåœ¨ç ”æ‹›ç½‘ä¸Šå…¬å¸ƒï¼Œè¦è€ƒç ”é¦–å…ˆå»äº†è§£è‡ªå·±è€ƒå•¥ï¼Œå…·ä½“éƒ½æ˜¯å•¥ å¦‚æœä½ å¯¹è‡ªå·±çš„åˆè¯•æœ‰ \b å®‰æ’ï¼Œé‚£ä¹ˆä½ ä¸€å®šè¦äº†è§£ä¸€ä¸‹å­¦æ ¡åœ¨å¤§ä¸‰å’Œå¤§å››çš„å®‰æ’ï¼Œå› ä¸ºä½ æ°¸è¿œä¸çŸ¥é“å­¦æ ¡ä¼šåœ¨ä»€ä¹ˆæ—¶å€™ç»™ä½ æ‰”ä¸€å †è«åå…¶å¦™çš„äº‹å„¿æ¥ æ”¿æ²»æ—©ç‚¹å¼€å§‹å¥½ï¼Œ9 æœˆåå¼€å§‹çš„æˆ‘ï¼Œé‚£ä¸¤ä¸ªæœˆç—›ä¸æ¬²ç”Ÿï¼Œæ¯å¤©å¤ä¹ å¾—ç¬¬ä¸€ä»¶äº‹å„¿å°±æ˜¯èƒŒæ”¿æ²»ï¼ŒèƒŒä¸ä¸‹å»äº†ï¼Œå„ç§æ•°å­¦é¢˜æ³¡ç€ã€‚é‡å¤ç€æ”¿æ²»=&gt;æ•°å­¦=&gt;æ”¿æ²»çš„æ— é™å¾ªç¯ å› ä¸ºæ—¶é—´çš„å…³ç³»ï¼Œæˆ‘æ˜¯ä¸å¯èƒ½æœ‰å¤§é‡çš„æ—¶é—´ç»ƒä¹ è‹±è¯­å†™ä½œå•¥çš„ï¼Œäºæ˜¯è‹±äºŒå°±é ç€è€ƒç ”å•è¯å’Œæœ€åä¸¤ä¸ªæœˆçš„çªå‡»å†™ä½œç»ƒä¹ æ’‘èµ·æ¥ï¼Œæœ€åç»“æœä¹Ÿç®—æ»¡æ„ï¼Œæœ¬æ¥ä¹Ÿæ²¡æ‰“ç®—æ‹¿é«˜åˆ†ï¼Œäº‹å®è¯æ˜å•è¯ä¹Ÿç¡®å®é‡è¦ ä¸“ä¸šè¯¾ï¼Œçœ‹è‡ªå·±çš„ \b å­¦æ ¡çš„æƒ…å†µå§ å¤è¯•&emsp;&emsp;18 å¹´ 3 æœˆåˆå°±æ˜¯å‡†å¤‡å¤è¯•ï¼Œå„ç±»ä¸“ä¸šè¯¾å‡†å¤‡å‘€å•¥çš„ï¼Œåæ­£å’±ä¹Ÿæ²¡ä¸Šæœºå•¥çš„ã€‚å…¶ä»–ä¹Ÿæ²¡å•¥å¥½è¯´çš„ï¼Œåªæ˜¯å½“æ—¶æ¯•è®¾è€å¸ˆäººæ‹›æ»¡äº†ï¼Œå¦å¤–è”ç³»äº†ä¸€ä½å¯¼å¸ˆï¼Œä¹Ÿå°±æ˜¯æˆ‘ç°åœ¨çš„å¯¼å¸ˆã€‚\b&emsp;&emsp;PSï¼šå¦‚æœä½ åˆè¯•é«˜ï¼Œåˆè”ç³»äº†è€å¸ˆâ€¦â€¦ æœ¬ç§‘æ¯•è®¾&emsp;&emsp;è¯´å®è¯ï¼Œå½“æˆ‘ä»æ¯•è®¾è€å¸ˆæ‰‹é‡Œé¢ç¬¬ä¸€æ¬¡æ‹¿åˆ°è¿™ä¸ªé¢˜ç›®çš„æ—¶å€™ï¼Œè§‰å¾—ä¸éš¾å˜›ã€‚å¯å„ç§æŠ€æœ¯éƒ½ä¸å¤ªä¼šï¼Œå¤–åŠ è¿˜è¦å»é’ˆå¯¹å½“å‰é¡¹ç›®æå‡ºä¸€ç§å¯è¡Œçš„è§£å†³æ–¹æ¡ˆã€‚å½“æ—¶çš„æˆ‘ç¡®å®åšä¸åˆ° ç°åœ¨å¥½åƒä¹Ÿä¸ä¸€å®šã€‚æ¯•ç«Ÿå’±ä»¬è½¯ä»¶å·¥ç¨‹ï¼Œå¼•ç”¨ç™¾åº¦ç™¾ç§‘å¦‚ä¸‹ è½¯ä»¶å·¥ç¨‹æ˜¯ä¸€é—¨ç ”ç©¶ç”¨å·¥ç¨‹åŒ–æ–¹æ³•æ„å»ºå’Œç»´æŠ¤æœ‰æ•ˆçš„ã€å®ç”¨çš„å’Œé«˜è´¨é‡çš„è½¯ä»¶çš„å­¦ç§‘ã€‚ ç™¾åº¦ç™¾ç§‘baike.baidu.com/item/è½¯ä»¶å·¥ç¨‹/25279 ç®€è¨€ä¹‹å°±æ˜¯éœ€è¦é’ˆå¯¹ç”¨æˆ·éœ€æ±‚åšå‡ºç”¨æˆ·æ»¡æ„è½¯ä»¶åˆ¶å“ã€‚ &emsp;&emsp;è™½è¯´æ•´ä¸ªæ¯•è®¾è¿‡ç¨‹ä¸­ï¼Œå¼€é¢˜ã€äºŒæ¬¡å¼€é¢˜ã€ä¸­æœŸå’Œæœ€ç»ˆç­”è¾©éƒ½è¢«æ€¼å‡º shit äº†ï¼Œä¸è¿‡æœ€ç»ˆè¿˜æ˜¯åœ¨å­¦é•¿çš„å¸®åŠ©ä¸‹è¿˜æ˜¯å†™äº†ä¸ª Demo å‡ºæ¥ã€‚\b æ‰“å¿ƒåº•é‡Œæ˜¯ååˆ†æ„Ÿè°¢å½“æ—¶çš„é‚£ä½å­¦é•¿çš„ ä»æ¯•è®¾æ¥è¯´ã€‚å½“æ—¶çš„ç¬¬ä¸€ç‰ˆ Demo æ˜¯å­¦é•¿å†™å‡ºæ¥çš„ï¼Œä¹Ÿæ˜¯å­¦é•¿ç»™æˆ‘è®²äº† \b ä»–å¯¹ç€è¿™ä¸ªä¸œè¥¿çš„è®¾è®¡æ€è·¯å’Œæƒ³æ³•ã€‚ç„¶ååœ¨æ­¤åŸºç¡€ä¸Šæ…¢æ…¢å®Œå–„äº†è¿™ä¸ª Demoï¼ˆè™½ç„¶æ„Ÿè§‰æ²¡å•¥å¤§ç”¨ï¼‰ã€‚ ä»æŠ€æœ¯æ¥è¯´ã€‚å½“æ—¶ç”¨çš„æ˜¯ Spring boot + Spring Security + Oauth2.0 å®Œæˆçš„ Demoï¼Œå› ä¸ºæ•´ä¸ªé¡¹ç›®æ˜¯åŸºäº Spring cloud çš„å¾®æœåŠ¡æ¶æ„ï¼Œæ‰€ä»¥ä½¿ç”¨äº†èƒ½å¤Ÿè¿™äº›èƒ½å¤Ÿæ–¹ä¾¿é›†æˆçš„æ¡†æ¶ã€‚å¯ä»¥è¯´ä» Java Web ä»¥åŠå¾®æœåŠ¡æ¶æ„çš„è§’åº¦æ¥è¯´ï¼Œå­¦é•¿ç»™æˆ‘å¼€äº†ä¸€æ‰‡çª—ã€‚ æ¯•ä¸š&emsp;&emsp;\b å¤©ä¹‹æ¶¯æµ·ä¹‹è§’æ¥å½¢å®¹æ¯•ä¸šçš„æƒ…å†µæ„Ÿè§‰ååˆ†è´´åˆ‡ã€‚æœ¬ç§‘çš„å‡ ä½å®¤å‹ï¼Œä¸€ä½å·²ç»è¿œåœ¨ç¾å›½æ±‚å­¦ï¼Œä¸€ä½ \b åœ¨åŒä¸€å­¦æ ¡è¯»ç ”ã€‚\b&emsp;&emsp;å›æ²™æ²³æ‹ç…§é‚£å¤©ï¼Œç«™åœ¨åŸæ¥çš„å¯å®¤é—¨å£ï¼Œ\b åˆæƒ³èµ·æœ¬ç§‘åˆšå…¥å­¦çš„æ—¶å€™åˆå…¥åŒ—äº¬ã€‚ç‹¬è‡ªä¸€äººæ¥åˆ°å­¦æ ¡ï¼Œåˆ°æœ€åæ¯•ä¸šçš„æ—¶å€™ï¼Œæ™®èˆª julaoã€å°å¼ºã€ä¹å“¥ã€ç”·ç¥ã€æ‰˜å„¿ã€å„¿å­â€¦â€¦å¤§å­¦ä¹Ÿå·²æ˜¯ç»™äº†æˆ‘å¤ªå¤šå¤ªå¤šã€‚ è¯»ç ”&emsp;&emsp;æˆ˜æˆ˜å…¢å…¢åœ°åº¦è¿‡äº†åˆè¯•ã€å¤è¯•ã€æ¯•è®¾åï¼Œæœ€ç»ˆè¿˜æ˜¯é¡ºåˆ©æœ¬ç§‘æ¯•ä¸šè¯»ç ”äº†ã€‚ç ”ç©¶ç”Ÿçš„æ•´ä½“ç”Ÿæ´»ç»™æˆ‘çš„æ„Ÿè§‰æ˜¯è¾ƒå¿™çš„ï¼Œè€å¸ˆçš„é¡¹ç›®ã€å­¦æ ¡çš„è¯¾ç¨‹å’Œè€ƒè¯•ç­‰ç­‰ï¼Œåˆ°å¯’å‡æœ€å¼€å§‹çš„æ—¶å€™ï¼ˆå°±æ˜¯ç°åœ¨ï¼‰è¿˜åœ¨å¿™åŠ©æ•™æœŸæœ« \b æˆç»©çš„äº‹å„¿ã€‚ é¡¹ç›®&emsp;&emsp;ç¬¬ä¸€æ¬¡æ¥åˆ°è€å¸ˆç»™çš„é¡¹ç›® \b åº”è¯¥æ˜¯åœ¨ 4 æœˆä¸­æ—¬ï¼ˆ\b å·§äº†ï¼Œé‚£æ—¶å€™æ¯•è®¾è¿˜æ­£å¼€å§‹åšï¼‰ã€‚æ•´ä½“çš„å†…å®¹å¤§æ¦‚æ˜¯åš NLPï¼ˆæ€ä¹ˆå¤§å®¶éƒ½æ˜¯æœºå™¨å­¦ä¹ ï¼Œè‡£å¦¾ä¸ä¼šå‘€ï¼‰ï¼Œå¯¹çˆ¬å–åˆ°çš„æ–‡æœ¬çš„è¯­ä¹‰å®ä½“è¿›è¡Œè¯†åˆ«ï¼Œå¦‚æ—¶é—´ã€äººç­‰ã€‚ &emsp;&emsp;æ¯•ç«Ÿæ˜¯è€å¸ˆç»™çš„ç¬¬ä¸€ä¸ªé¡¹ç›®ï¼Œè¿˜æ˜¯é¢‡ä¸ºé‡è§†ï¼ŒèŠ±äº†ä¸€ä¸ªæœˆä»é›¶å…¥é—¨æœºå™¨å­¦ä¹ ã€‚å´æ©è¾¾çš„ coursera ä¸Šçš„å’Œæ–¯å¦ç¦å¤§å­¦çš„å…¬å¼€è¯¾ç¨‹éƒ½å¼ºè¡Œçœ‹äº†ä¸€éï¼Œæœ€åå¾—å‡ºçš„ç»“è®ºæ˜¯ â€”â€”â€”â€” è‡£å¦¾çœ‹ä¸æ‡‚ï¼ˆæ•°å­¦å®åœ¨æ˜¯éš¾ï¼Œç‰¹åˆ«æ˜¯æ¦‚ç‡è®ºï¼‰ã€‚ &emsp;&emsp;äºæ˜¯è½¬å¤´ç›´æ¥å¯»æ‰¾ä»Šå¹´çš„ \bNLP å®ä½“è¯†åˆ«å®ç°ã€‚è¿˜çœŸæ‰¾åˆ°äº†,16 å¹´çš„è®ºæ–‡ï¼ŒBidirectional LSTM-CRFå®ç°ã€‚äºæ˜¯æƒ³é€šè¿‡ python\b å®ç°è¿™ä¸ª \b æ€è·¯ï¼Œå†ä¸€çœ‹ kerasã€tensorflow ç­‰ä¸€å †ä¸œè¥¿ï¼Œemmmï¼Œè¿˜æ˜¯ç›´æ¥å»æ‰¾åˆ«äººå®ç°çš„å§ã€‚ &emsp;&emsp;å°±è¿™æ ·ç›´åˆ°ä¸ƒæœˆä¸­æ—¬ï¼Œç»ˆäºåœ¨æŠŠåˆ«äººçš„ \b å®ç°æ‰’ä¸‹æ¥æ”¹æ”¹çš„æƒ…å†µä¸‹ï¼Œé€šè¿‡ä¸€ä¸ªå¼€æºçš„ Word2Vec çš„é¢„è®­ç»ƒå‘é‡é›†å’Œä¸€ä¸ªå°é‡çš„è®­ç»ƒé›†ï¼Œè¿™ä¸œè¥¿ç»ˆäºèƒ½è·‘èµ·æ¥å¹¶ä¸”èƒ½è¯†åˆ«ä¸€å®šé‡çš„ \b å®ä½“äº†ã€‚ &emsp;&emsp;æœ€ç»ˆè¿™ä¸ªæ–¹æ¡ˆè¿˜æ˜¯å¤±è´¥äº†ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿåšäº†è¿™å¤šï¼Œåˆ°æœ€åä¸€æ­¥æ‰å‘ç°â€”â€”â€”â€”æ²¡æœ‰æ•°æ®ï¼ï¼çˆ¬å–çš„æ•°æ®æ²¡äººå»æ‰‹åŠ¨æ¸…æ´—ï¼ˆå·¥ä½œé‡å¤ªå¤§ï¼‰ï¼Œè€Œä¸”æ•°æ®é‡å¤ªå°ï¼Œä¹Ÿä¸èƒ½ä¿è¯è®­ç»ƒå‡ºæ¥çš„æ­£ç¡®æ€§ã€‚ä½†æ˜¯é¡¹ç›®æ€»å¾—ç»§ç»­ï¼Œäºæ˜¯ä¹ç¡¬ç€å¤´çš®ç›´æ¥äººå·¥æ¸…ç†äº†çˆ¬å–çš„æ•°æ®ï¼Œç„¶ååšä¸ªå¯è§†åŒ–ã€‚æœ¬æ¥è¿˜æƒ³æ¸…æ´—å®Œæ‰”è¿›å»è®­ç»ƒçœ‹çœ‹ï¼Œå¯å½“æ¸…æ´—å·¥ä½œå¿«ç»“æŸæ—¶ï¼Œæ‰å‘ç°æœ€å¼€å§‹çš„æ¸…æ´—æ–¹æ³•é”™äº†ï¼Œå¯¼è‡´æ¸…æ´—çš„æ•°æ®å®Œå…¨æ— æ³•æ‰”è¿›å»è®­ç»ƒã€‚äºæ˜¯æˆ‘çš„å·¥ä½œå°±å˜æˆäº†å¯è§†åŒ–å‰ç«¯+åç«¯ã€‚ &emsp;&emsp;å¯¹äºè¿™ä¸ªé¡¹ç›®ï¼Œåªèƒ½ç”¨å¿ƒæƒ…å¤æ‚æ¥å½¢å®¹äº†ã€‚ æš‘å‡&emsp;&emsp;æš‘å‡ç•™ä¸‹æ¥å‚ä¸äº†å®éªŒå®¤çš„å…¶ä»–é¡¹ç›®ï¼ˆå¯æ€œé‚£æ—¶å€™è¿˜è¦å»çœ‹æœºå™¨å­¦ä¹ ï¼‰ï¼Œä»å­¦å§æ‰‹é‡Œåˆ†åˆ°äº†ä¸€ä¸ªè¿˜ç®— \b ä¸é‚£ä¹ˆå›°éš¾çš„éƒ¨åˆ†ï¼ˆæ„Ÿè°¢ä¸‹å­¦å§çš„æ€œæ‚¯ï¼‰ã€‚ &emsp;&emsp;æš‘å‡çš„é¡¹ç›®åœ¨æˆ‘çš„ç†è§£ä¸Šæ„Ÿè§‰åƒä¸€ä¸ª proxyï¼Œå„ç±»è¯·æ±‚çš„è½¬å‘å’Œå­˜å‚¨ã€‚\bKoa2 å®ç°ï¼Œäºæ˜¯è¾¹å­¦ nodejsã€es6ã€koa2 è¾¹å†™ã€‚ä¸å¾—ä¸è¯´ js å†™èµ·æ¥å°±æ˜¯æ¯” java æ„Ÿè§‰ç®€å•Â·Â·Â·æ¯•è®¾çš„ Demo å†™å¾—å®åœ¨æ˜¯å¤ªéš¾å—äº†ã€‚ åŠ©æ•™&emsp;&emsp;è¿™å­¦æœŸçš„å¦ä¸€ä¸ªå¤§äº‹å„¿å°±æ˜¯å½“äº†ä¸€é—¨æœ¬ç§‘è¯¾çš„åŠ©æ•™ã€‚å…¶å®è¯»ç ”ä¹‹å‰æ›¾ç»å¹»æƒ³è¿‡å½“åŠ©æ•™ï¼ˆä¸»è¦æ˜¯å½“æ—¶ä¹Ÿæƒ³å¤ä¹ ç‚¹å•¥ï¼Œæ¯”å¦‚ç®—æ³•ï¼Ÿæ•°æ®ç»“æ„ï¼Ÿï¼‰ã€‚å¯çœŸæ­£è¦å»å½“åŠ©æ•™çš„æ—¶å€™ï¼Œæ‰è§‰å¾—ååˆ†è›‹ç–¼â€”â€”â€”å› ä¸ºç ”ä¸€åˆè¦ä¸Šè¯¾ã€è¿˜æœ‰å®éªŒå®¤çš„å„ç§æ´»å„¿ã€‚è·Ÿæˆ‘æ­æ¡£çš„å¦ä¸€ä½åŠ©æ•™ï¼Œç»å¸¸è‡ªå˜²ä¸ºå®éªŒå®¤æœ€å¿™çš„äººï¼Œå¤§æ¦‚æ˜¯å°±æ˜¯å› ä¸ºè¿™äº›äº‹å„¿å§ã€‚ &emsp;&emsp;å½“åŠ©æ•™ï¼Œæ¯å‘¨éƒ½è¦æ‰¹æ”¹ã€ç»Ÿè®¡ 180 ä»½å„ä½åŒå­¦çš„ä½œä¸šã€‚å¯¹æˆ‘æ¥è¯´ä¸€ä¸ªæ™šä¸Šæ‰èƒ½å‹‰å¼ºæ”¹å®Œä½œä¸šï¼Œå†èŠ±ä¸€ä¸ªæ™šä¸Šæ‰èƒ½ç»Ÿè®¡å®Œæˆã€‚ç„¶è€ŒåŠ©æ•™æœ€éš¾å—çš„åœ°æ–¹æ˜¯ \b åŒå­¦ä»¬çš„é—®é¢˜ï¼ˆè™½ç„¶å¹³æ—¶æ¥é—®çš„åŒå­¦ä¸å¤šï¼ŒæœŸæœ«é™¡å¢ï¼‰ã€‚æ¯•ç«Ÿæ˜¯ä¸¤å¹´å‰çš„ \b ç§‘ç›®ï¼Œå¥½å¤šç»†èŠ‚éƒ½è®°ä¸å¤ªæ¸…æ¥šäº†ï¼Œå¯ç ”ä¸€çš„è¯¾ç¨‹ã€å®éªŒå®¤çš„æ´»å„¿ä¸€åšå®Œï¼Œæ ¹æœ¬æ²¡å•¥æ—¶é—´å’Œç²¾åŠ›å»å¤ä¹ è¿™é—¨è¯¾ï¼Œæˆ‘åªèƒ½è¯´å¯¹åŒå­¦ä»¬è¯´è¿™é—¨è¯¾çš„åŠ©æ•™æˆ‘å°½åŠ›äº†ã€‚\b &emsp;&emsp;å½“ç„¶ï¼Œæœ€åç»Ÿè®¡æœŸæœ«æˆç»©çš„ \b æ—¶å€™è¿˜å‡ºäº†ä¸€ç‚¹å°çº°æ¼ \bï¼Œå‡ ä½ \b åŒå­¦çš„æœ€åä¸€æ¬¡ç­¾åˆ°ç»™è®¡ç®—æ‰äº†ï¼Œåªèƒ½çœŸè¯šçš„ç»™å„ä½åŒå­¦è¯´ä¸€å£°å¯¹ä¸èµ·äº†ï¼ˆè™½ç„¶ä»–ä»¬ä¹Ÿçœ‹ä¸åˆ°å°±æ˜¯äº†\bï¼‰ã€‚ å­¦ä¹ &emsp;&emsp;æ•´ä¸ª 18 å¹´å¯ä»¥è¯´æ˜¯è¢«å„ç§äº‹æƒ… drive ç€å»å­¦ä¹ çš„ä¸€å¹´ è€ƒç ”çš„æ—¶å€™è¢«è‡ªä¸»å®ä¹  drive å­¦äº†ä¸€æ³¢ Java Web è¢«æ¯•è®¾ drive\b äº†è§£äº†ä¸€æ³¢ Spring Securityã€Oauthã€Spring Cloud è¢«é¡¹ç›® drive å­¦äº†ä¸€æ³¢æœºå™¨å­¦ä¹ ï¼Œè™½ç„¶æœ€åæ— ç–¾è€Œç»ˆï¼Œä¹Ÿè®©æˆ‘æ˜ç™½æˆ‘ç¡®å®æä¸æ‡‚æœºå™¨å­¦ä¹  è¢«é¡¹ç›® drive å­¦äº†ä¸€æ³¢å‰ç«¯ï¼Œè™½ç„¶åˆ°ç°åœ¨ css ä¾ç„¶æ˜¯ä¸€å—ç—›å¤„ &emsp;&emsp;ä»¥ä¸Š 18 å¹´çš„å­¦ä¹ ä¹Ÿè®©æˆ‘å¯¹è‡ªå·± 19 å¹´çš„æœ‰äº†ä¸€å®šæƒ³æ³•ï¼Œä¸»è¦åˆ†ä¸ºé¢å‘å·¥ç¨‹æ‰©å……è‡ªå·±å§ å·¥ç¨‹ è®¾è®¡æ¨¡å¼ ç®—æ³•ã€æ•°æ®ç»“æ„ æ¡†æ¶ vue spring node åˆ·é¢˜ leetcode? (é¢å‘å·¥ä½œå­¦ä¹  23333)","link":"/2019/01/25/18summary/"},{"title":"Hello World","text":"&emsp;&emsp;å»ºç«‹è¿™ä¸ªåšå®¢åªæ˜¯å…´è¶£æ‰€è‡´ä¸ºäº†å®Œæˆ18å¹´çš„æ—¢å®šç›®æ ‡ &amp; æ‰¾ä¸€ä¸ªèƒ½å¤Ÿå†™äº›ä¸œè¥¿çš„åœ°æ–¹ï¼ˆæ¯•ç«Ÿå·¥ä½œä¹‹ä½™å¿ƒæƒ…çƒ¦é—·ä¹‹æ—¶ï¼Ÿï¼ï¼‰ &emsp;&emsp;æŒ‡ä¸å®šå†™äº›å•¥å°±å’•å’•å’•äº† &emsp;&emsp;è°¨ä»¥æ­¤hello world\bçºªå¿µä¸‹åšå®¢æ­£å¼æ­å¥½","link":"/2019/01/23/hello-world/"},{"title":"hexoé™æ€åšå®¢æ­å»ºï¼ˆä¸€ï¼‰hexoç®€ä»‹&amp;ç¯å¢ƒ","text":"ä¸€ç›´ä»¥æ¥éƒ½æœ‰æ­å»ºåšå®¢çš„æƒ³æ³•ï¼Œç²—ç•¥äº†è§£äº†ä¸€ä¸‹WordPresså’Œhexoï¼Œ\båœ¨å°è¯•è¿‡WordPressçš„å®‰è£…éƒ¨ç½²åæœæ–­é€‰æ‹©äº†hexoã€‚å‡†å¤‡ä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ä»‹ç»ä¸‹hexoçš„æ­å»ºè¿‡ç¨‹ hexoç®€ä»‹ &amp; ç¯å¢ƒ hexoå‘½ä»¤ &amp; ä¸»é¢˜ hexoè‡ªåŠ¨éƒ¨ç½² hexoç®€ä»‹æˆ‘ä»¬é¦–å…ˆæ¥çœ‹çœ‹hexoå®˜ç½‘å¯¹hexoçš„ä»‹ç» è¶…å¿«é€Ÿåº¦ æ”¯æŒ Markdown ä¸€é”®éƒ¨ç½² ä¸°å¯Œçš„æ’ä»¶ \bç®€è€Œè¨€ä¹‹ï¼Œhexoå°±æ˜¯ ä¸€ä¸ªåŸºäºnodejsçš„åšå®¢å¼•æ“ æ”¯æŒejsç­‰æ¨¡æ¿å¼•æ“ é€šè¿‡æ¸²æŸ“Markdownæ–‡ä»¶ç”Ÿæˆåšå®¢æ‰€éœ€å„ç±»é™æ€æ–‡ä»¶ æœ‰è¾ƒä¸ºå®Œæ•´çš„\bç”Ÿæ€æ”¯æŒï¼ŒåŒ…å«å„ç§æ’ä»¶ï¼Œæ»¡è¶³å¤§éƒ¨åˆ†éœ€æ±‚ æ‰€ä»¥å¯¹äºç†Ÿæ‚‰nodejsçš„ç”¨æˆ·èƒ½å¤Ÿé€šè¿‡hexoå¿«é€Ÿæ­å»ºä¸€ä¸ªåšå®¢ hexoç¯å¢ƒnodejsç¯å¢ƒnvm + nrm å¯ä»¥ä½¿ç”¨nvmè¿›è¡Œnodejsç‰ˆæœ¬åˆ‡æ¢å’Œç®¡ç† å›½å†…ç¯å¢ƒä¸‹æ¨èä½¿ç”¨æ·˜å®çš„npmæºcnpmæˆ–è€…ä½¿ç”¨nrmåˆ‡æ¢åˆ°æ·˜å®æº å…¨å±€å®‰è£…hexo-cli1npm install hexo-cli -g ä½¿ç”¨åŒ…ç®¡ç†å™¨ osxç¯å¢ƒä¸‹ä½¿ç”¨homebrewå®‰è£… 1brew install nodejs gitç¯å¢ƒwindowså¯ä»¥é€šè¿‡è®¿é—®gitå®˜ç½‘ä¸‹è½½å®‰è£…åŒ…å³å¯ å„ç±»linuxç³»ç­‰å»ºè®®é€šè¿‡åŒ…ç®¡ç†å™¨ä¸‹è½½","link":"/2019/01/26/hexo-1/"},{"title":"hexoé™æ€åšå®¢æ­å»ºï¼ˆäºŒï¼‰hexoå‘½ä»¤&amp;ä¸»é¢˜","text":"ç®€å•è¯´ä¸‹å¸¸ç”¨çš„å‘½ä»¤ hexoå‘½ä»¤hexo å®‰è£…nodejsç¯å¢ƒå®‰è£…å®Œæˆåï¼Œåœ¨å…¨å±€ä¸‹å®‰è£…hexo\b-cliï¼Œå‘½ä»¤å¦‚ä¸‹ 1npm install -g hexo-cli hexo-cliå®‰è£…å®Œæ¯•åæ‰å¯ä»¥æ‰§è¡Œhexoå‘½ä»¤ hexo init1hexo init [folder] folderæ˜¯å½“å‰åšå®¢ç›®å½•ï¼Œé€šè¿‡hexo initå‘½ä»¤å¯ä»¥åœ¨æŒ‡å®šçš„folderç›®å½•ä¸‹è‡ªåŠ¨å…‹éš†ä¸€ä¸ªhexoé¡¹ç›®æ¨¡æ¿ï¼ˆä¸€ä¸ªnodejsé¡¹ç›®ï¼‰ï¼Œå¹¶è‡ªåŠ¨å®‰è£…ç›¸åº”çš„ä¾èµ–ï¼Œå…¶ç›®å½•æ–‡ä»¶ç»“æ„å¦‚ä¸‹. â”œâ”€â”€ _config.yml - hexoçš„ç›¸å…³é…ç½®ä¿¡æ¯ â”œâ”€â”€ db.json â”œâ”€â”€ node_modules - nodejsä¾èµ– â”œâ”€â”€ package.json - nodejsé¡¹ç›®ä¿¡æ¯ â”œâ”€â”€ scaffolds - å‘å¸ƒæ¨¡æ¿ â”œâ”€â”€ source - å­˜æ”¾ç”¨æˆ·èµ„æºï¼Œå¦‚æ–‡ç« ç­‰ â””â”€â”€ themes - ä¸»é¢˜ï¼Œä¼šæ ¹æ®ä¸»é¢˜ç”Ÿæˆ ã€å¯¹åº”çš„é¡µé¢ \bhexo serveré€šè¿‡hexo initå‘½ä»¤å»ºç«‹åšå®¢æ¨¡æ¿æ–‡ä»¶åï¼Œå…¶è‡ªå¸¦äº†landscapeä¸»é¢˜ï¼Œå¯ä»¥é€šè¿‡hexo serverç›´æ¥å¯åŠ¨ hexo new1hexo new [layout] &lt;title&gt; æ–°å»ºä¸€ä¸ªåä¸ºtitleçš„æ–‡ç« ã€‚å¦‚æœæ²¡æœ‰è®¾ç½® layout çš„è¯ï¼Œé»˜è®¤ä½¿ç”¨ _config.yml ä¸­çš„ default_layout å‚æ•°ä»£æ›¿ hexo publish1hexo publish [layout] &lt;filename&gt; hexoå°†æ–‡ç« ç»„ç»‡ä¸ºdraftå’Œpostä¸¤ç§çŠ¶æ€ï¼Œå› æ­¤åœ¨ä½¿ç”¨äº†hexo new draft someFileåéœ€è¦é€šè¿‡hexo publishå‘½ä»¤å°†å¤„äºdraftä¸‹çš„æ–‡ç« æ­£å¼å‘è¡¨ï¼Œè¿™æ ·æ‰èƒ½åœ¨blogä¸­æ­£å¸¸æŸ¥çœ‹ã€‚ hexo generate &amp; hexo deployhexo generateä¼šå°†markdownæ–‡ä»¶ç­‰ä¸€ç³»åˆ—çš„æ–‡ä»¶ç¼–è¯‘è½¬æ¢æˆæ ‡å‡†çš„é™æ€æ–‡ä»¶ã€‚hexo deployå‘½ä»¤ä¼šå°†æœ¬åœ°ç”Ÿæˆçš„é™æ€æ–‡ä»¶ä¸€é”®éƒ¨ç½²åˆ°è¿œç¨‹æœåŠ¡å™¨ã€‚ hexo ä¸»é¢˜hexoæä¾›äº†ä¸°å¯Œçš„ä¸»é¢˜ï¼Œè¿™ä¸ªblogä½¿ç”¨äº†icarus å®‰è£… å¦‚æœblogé€šè¿‡gitæ¥è¿›è¡Œç‰ˆæœ¬æ§åˆ¶ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡gitå®‰è£…1git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus å¯ä»¥å»å…¶githubé¡µé¢ä¸Šä¸‹è½½releaseåŒ…ï¼Œè§£å‹åˆ°themes/icarusä¸‹ å¾®è°ƒæ ·å¼å¤§éƒ¨åˆ†å¯¹äºæ ·å¼çš„å¾®è°ƒéƒ½èƒ½åœ¨issuesé¡µé¢æ‰¾åˆ° é˜…è¯»é¡µé¢ä¸‰æ è½¬äºŒæ  æ·»åŠ abouté¡µé¢icaruså°†abouté¡µé¢æŒ‚è½½åœ¨äº†ç½‘é¡µçš„/abouté¡µé¢123cd blogæ ¹ç›®å½•/sourcemkdir abouttouch index.md ä¸­æ–‡è®¾ç½® icarusè‡ªå¸¦ä¸­æ–‡è®¾ç½®1vim blogæ ¹ç›®å½•/_config.yml å°†languageé¡¹è°ƒæ•´æˆzh-CNï¼Œhexoä¼šè‡ªåŠ¨åŠ è½½themes/icarusä¸‹çš„i18næ–‡ä»¶ å¯¼èˆªæ ä¸­æ–‡è®¾ç½®ä¿®æ”¹/themes/icarusä¸‹çš„_config.ymlå°† æ·»åŠ commentæ’ä»¶icarusæä¾›äº†å¯¹äºgitalkã€Valineç­‰è¯„è®ºæ’ä»¶çš„æ”¯æŒï¼Œè¿™ä¸ªblogä½¿ç”¨äº†valineå¯¹è¯„è®ºæ’ä»¶ valineç”³è¯·åˆ›å»ºåº”ç”¨ç”³è¯·leancloud åº”ç”¨ç”³è¯·æˆåŠŸåå°†ä¸‹åˆ—keyå¡«å…¥icarusä¸‹çš„_config.ymlä¸­ æ·»åŠ valineäººæ•°ç»Ÿè®¡åœ¨æ·»åŠ valineçš„commentç»„ä»¶çš„æ—¶å€™ï¼Œå‘ç°valineæ”¯æŒæ–‡ç« çš„æµè§ˆæ•°é‡ç»Ÿè®¡ï¼Œè€ƒè™‘æ·»åŠ valineé˜…è¯»æ•°é‡ç»Ÿè®¡ã€‚æ‰¾åˆ°layout/comment/valine.ejsï¼Œæ·»ä»¥ä¸‹åˆ°else blockä¸­ 1234&lt;span id=&quot;&lt;Your/Path/Name&gt;&quot; class=&quot;leancloud-visitors&quot; data-flag-title=&quot;Your Article Title&quot;&gt; &lt;em class=&quot;post-meta-item-text&quot;&gt;é˜…è¯»é‡ &lt;/em&gt; &lt;i class=&quot;leancloud-visitors-count&quot;&gt;1000000&lt;/i&gt;&lt;/span&gt; 123456(function () { var span = document.getElementsByClassName('leancloud-visitors')[0]; span['id'] = window.location.pathname; // è²Œä¼¼ title æœ‰bug // span.dataset.flagTitle = document.title;})(); spançš„idä¼šä½œä¸ºvalineç»Ÿè®¡çš„ä¸»é”®ï¼Œæ‰€ä»¥ç›´æ¥å¡«å…¥æ¯ä¸ªlocationå¯¹è±¡çš„pathnameå³å¯ï¼Œå³å¯åšå‡ºé˜…è¯»é‡ç»Ÿè®¡","link":"/2019/03/06/hexo-2/"},{"title":"hexoé™æ€åšå®¢æ­å»ºï¼ˆä¸‰ï¼‰hexoè‡ªåŠ¨éƒ¨ç½²","text":"ç»è¿‡å‰ä¸¤æ­¥ï¼Œä¸€ä¸ªèƒ½çœ‹çš„blogå·²ç»æ­èµ·æ¥äº†ï¼Œåœ¨æœ¬åœ°è°ƒè¯•å®Œæˆåï¼Œè¿˜æ˜¯éœ€è¦ä¸€ä¸ªåœ°æ–¹éƒ¨ç½²è¿™ä¸ªblogã€‚å› ä¸ºæœ‰ä¸€ä¸ªæœåŠ¡å™¨æ¥ç§‘å­¦ä¸Šç½‘ï¼Œæ‰€ä»¥å°±å§è¿™ä¸ªblogéƒ¨ç½²åˆ°äº†åŒä¸€ä¸ªvpsä¸Šï¼ˆè¿™ä¸¤ä¸ªåº”ç”¨éƒ½ä¸æ˜¯å¤ªåƒèµ„æºï¼‰ã€‚æ‰€ä»¥æ¥ä¸‹æ¥ä»‹ç»å¦‚ä½•å°†blogéƒ¨ç½²åˆ°ä¸€ä¸ªè¿œç¨‹çš„æœåŠ¡å™¨ä¸Šã€‚ è‡ªåŠ¨éƒ¨ç½²åˆ°VPSéœ€è¦ç”¨åˆ°çš„hexoå‘½ä»¤hexoæ˜¯ä¸€ä¸ªéƒ¨ç½²é™æ€blogçš„å·¥å…·ï¼Œå› æ­¤æ‰€æœ‰çš„æ–‡ä»¶æœ€åéƒ½ä¼šè¢«ç”Ÿæˆæµè§ˆå™¨èƒ½è®¤è¯†çš„htmlã€cssã€jsæ–‡ä»¶ã€‚ 12hexo cleanhexo deploy å› æ­¤éœ€è¦åœ¨éƒ¨ç½²å‰ä½¿ç”¨hexo cleanå‘½ä»¤ï¼Œæ¸…ç†å·²ç»ç”Ÿæˆçš„/publicä¸‹çš„é™æ€æ–‡ä»¶å’Œdb.jsonï¼Œå†è°ƒç”¨hexo deployå‘½ä»¤ä½¿ç”¨hexoæä¾›çš„éƒ¨ç½²å‘½ä»¤å°†æœ¬åœ°çš„é™æ€æ–‡ä»¶éƒ¨ç½²åˆ°è¿œç¨‹æœåŠ¡å™¨ã€‚ hexo deploy use rsynchexo deployæä¾›äº†å¤šç§æ–¹å¼æ¥éƒ¨ç½²åˆ°è¿œç¨‹ï¼Œè¿™é‡Œä½¿ç”¨äº†rsyncæ¥éƒ¨ç½²ã€‚ éœ€è¦åœ¨æœåŠ¡å™¨ç«¯åšä»€ä¹ˆéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¦æ±‚æ‚¨æä¾›çš„å®é™…ä¸Šæ˜¯ä¸€ä¸ªèƒ½é€šè¿‡SSHç™»é™†è¿œç¨‹ä¸»æœºçš„Linuxç”¨æˆ·ã€‚Hexoä¼šè‡ªåŠ¨å¤„ç†å…³äºrsyncä½¿ç”¨çš„ä¸€åˆ‡æ“ä½œã€‚å› æ­¤ï¼Œæ‚¨éœ€è¦åœ¨è¿œç¨‹ä¸»æœºä¸Šä¸ºæ‚¨çš„Hexoç«™ç‚¹å»ºç«‹ä¸€ä¸ªç”¨æˆ·ï¼Œå¹¶å…è®¸å…¶é€šè¿‡SSHç™»é™†ã€‚ä¸è¿‡ï¼Œè¿™é‡Œçš„portï¼Œçš„ç¡®æ˜¯æŒ‡rsyncç›‘å¬çš„ç«¯å£ï¼Œè¯·ç¡®ä¿é˜²ç«å¢™æ‰“å¼€äº†è¯¥ç«¯å£ã€‚ hexoå¯¹äºrsyncçš„ä»‹ç» ä¹Ÿå°±æ˜¯è¯´rsyncéœ€è¦æˆ‘ä»¬æä¾›ä¸€ä¸ªå¯ä»¥é€šè¿‡sshç™»å½•çš„ç”¨æˆ·ï¼Œè¿™æ ·hexoå¯ä»¥ä½¿ç”¨è¯¥ç”¨æˆ·é€šè¿‡sshå°†éœ€è¦éƒ¨ç½²çš„æ–‡ä»¶ç§»åŠ¨åˆ°è¿œç¨‹æœåŠ¡å™¨ä¸Š æœ¬åœ°è®¾ç½®åœ¨æå®šäº†ç”¨æˆ·ä¹‹åæˆ‘ä»¬å°±éœ€è¦åœ¨blogçš„é…ç½®æ–‡ä»¶_config.ymlä¸­é…ç½®deployé€‰é¡¹æ¥å¯ç”¨rsyncå¸®åŠ©æˆ‘ä»¬æ¥è¿›è¡Œè¿œç¨‹éƒ¨ç½²ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ ä½¿ç”¨git hooksæ¥è‡ªåŠ¨è°ƒç”¨hexo deployåœ¨å®Œæˆäº†deployé€‰é¡¹çš„è®¾ç½®åï¼Œå¯ä»¥é€šè¿‡hexo deployå‘½ä»¤ä¸€é”®å°†é™æ€æ–‡ä»¶è¿œç¨‹éƒ¨ç½²åˆ°æœåŠ¡å™¨ä¸Šï¼Œä½†æ˜¯æ¯æ¬¡éƒ½éœ€è¦æ‰‹åŠ¨è°ƒç”¨ä¸‹è¿™ä¸ªå‘½ä»¤ï¼ŒåŒæ—¶å› ä¸ºblogæ”¾åˆ°äº†githubä¸Šï¼Œæ‰€ä»¥ä¸ºäº†å·ä¸ªå°æ‡’å°±åˆ©ç”¨git hooksï¼Œåœ¨æœ¬åœ°commitåï¼Œè°ƒç”¨hexo deployå‘½ä»¤å°†æœ¬åœ°çš„æ–‡ä»¶éƒ¨ç½²åˆ°è¿œç¨‹ã€‚ é¦–å…ˆè¿›å…¥åˆ°hooksæ–‡ä»¶ä¸­ 1cd .git/hooks æ·»åŠ ä»¥ä¸‹å†…å®¹åˆ°post-commitæ–‡ä»¶ä¸­ï¼Œè¿™æ ·æ¯æ¬¡åœ¨æœ¬åœ°commitåï¼Œéƒ½ä¼šå‡ºå‘è¿™ä¸ªhookï¼Œè°ƒç”¨è¿™ä¸ªæ–‡ä»¶ä¸­çš„å‘½ä»¤ 1234567#!/bin/bashcd /path/to/your/blogecho &quot;----- å¼€å§‹ -----&quot;hexo cleanhexo generatehexo deployecho &quot;----- ç»“æŸ -----&quot; warning:é¦–å…ˆéœ€è¦è¿›å…¥åˆ°ä½ çš„blogçš„æ ¹ç›®å½•ä¸‹ï¼Œè¿™æ ·hexoçš„å‘½ä»¤æ‰ä¼šè¢«æ­£ç¡®çš„è°ƒç”¨","link":"/2019/05/17/hexo-3/"},{"title":"æ˜¥æ‹›javaåç«¯å®ä¹ å²—ç¬”è¯•æ€»ç»“","text":"æ˜¥æ‹›å®ä¹ ç”ŸæŠ•é€’å°ç»“æ˜¥æ‹›å®ä¹ ç”Ÿä¸€å…±æŠ•äº†4å®¶ä¼ä¸šï¼ŒåŒ…æ‹¬å­—èŠ‚ã€ç¾å›¢ã€é˜¿é‡Œå’Œå¿«æ‰‹ï¼Œå› ä¸ºä¸¤è¾¹éƒ½ç›¸å¯¹è¾ƒå¤šï¼Œå› æ­¤å°†ç¬”è¯•å’Œé¢è¯•åˆ†å¼€å§ å­—èŠ‚å€’åœ¨äº†äºŒé¢ ç¾å›¢åˆšåˆšå®Œæˆäº†äºŒé¢ é˜¿é‡Œå®Œæˆäº†ä¸‰é¢(ä¸è¿‡æˆ‘è§‰å¾—æˆ‘è·Ÿä»–ä»¬éœ€æ±‚çš„æ–¹å‘ç›¸å¯¹è¾ƒè¿œï¼Œå› æ­¤å¸Œæœ›æ¸ºèŒ«) å¿«æ‰‹ï¼Œå¯èƒ½æ˜¯æŠ•é€’å¾—æ¯”è¾ƒæ™šï¼Œè‡³ä»Š(4æœˆ24æ—¥æ— ä»»ä½•æ¶ˆæ¯) å› ä¸ºè§‰å¾—å¤§éƒ¨åˆ†å¸Œæœ›æ¸ºèŒ«ï¼Œæ‰€ä»¥ç‰¹åœ°è®°å½•ä¸‹æ˜¥æ‹›çš„ç¬”è¯•å’Œé¢è¯•æƒ…å†µï¼Œå¸Œæœ›æœ‰æ‰€å¸®åŠ©ã€‚ æœ‰å‡ å®¶æ˜¯åœ¨ç‰›å®¢ç½‘æä¾›çš„å¹³å°ä¸Šç¬”è¯•çš„ï¼Œä¸è¿‡ç¬”è¯•çš„æ–¹å¼éƒ½æ˜¯å¤§åŒå°å¼‚ï¼Œä¿è¯å…¥å£classæ˜¯Mainå³å¯ï¼Œå¯ä»¥å…ˆå»ç‰›å®¢ç½‘ä¸Šè¯•è¯• ä¸ä¿è¯è‡ªå·±çš„è´´å‡ºçš„ä»£ç èƒ½å¤Ÿå…¨éƒ¨ACï¼Œä»…ä¾›å‚è€ƒ é˜¿é‡Œé˜¿é‡Œçš„ç¬”è¯•æ˜¯æ‰€æœ‰äººç»Ÿä¸€æ—¶é—´å‚åŠ ç¬”è¯•ï¼Œæˆ‘æ˜¯åœ¨4æœˆ13æ—¥å‚åŠ çš„æ™šä¸Šçš„ç¬”è¯•ï¼ŒæŠ½åˆ°çš„ç¬”è¯•é¢˜éƒ½æ˜¯è·Ÿå›¾ç›¸å…³çš„ ç¬¬ä¸€é¢˜é¢˜ç›®æè¿°ä¸€ä¸ªæ•°ç»„ï¼Œè¡¨ç¤ºä¸€ç»„åŠ¨ç‰©ï¼ˆåŠ¨ç‰©çš„ä¸‹æ ‡ä»1å¼€å§‹ï¼‰ï¼Œæ•°ç»„ä¸­çš„æ•°å€¼è¡¨ç¤ºä»°æ…•çš„å¯¹è±¡ï¼Œè¿™ä¸ªåŠ¨ç‰©å¯ä»¥ç»™è‡ªå·±æŠ•ç¥¨ï¼Œæˆ–è€…è·Ÿè‡ªå·±ä»°æ…•çš„äººæŠ•åŒæ ·çš„ç¥¨ï¼Œå¦‚æœæ•°ç»„ä¸­æ•°å€¼ä¸º0 é‚£ä¹ˆä»–åªèƒ½ç»™è‡ªå·±æŠ•ç¥¨ï¼Œè€Œä¸”æ•°ç»„ä¸­çš„ä½ç½®ä»£è¡¨äº†è¿™ä¸ªåŠ¨ç‰©çš„èƒ½åŠ›å¤§å° åé¢çš„åŠ¨ç‰©è¶Šä½ï¼Œä»–ä»¬åªèƒ½ä»°æ…•å‰é¢çš„åŠ¨ç‰©ã€‚ é—®ï¼šæ¯ä¸ªåŠ¨ç‰©å¯èƒ½æ‹¿åˆ°çš„æœ€å¤§çš„æŠ•ç¥¨æ•°ä¸ºå¤šå°‘ 1234567ä¾‹ï¼šè¾“å…¥[0,1,1,1,1]è¾“å‡º4 1 1 1 1 è§£é‡Šï¼šç¬¬ä¸€ä¸ªåŠ¨ç‰©åªèƒ½ç»™è‡ªå·±æŠ•ç¥¨ï¼Œæ‰€ä»¥ä»–ç»™è‡ªå·±æŠ•ç¥¨ï¼Œè€Œåé¢çš„åŠ¨ç‰©ä»°æ…•1å·åŠ¨ç‰©ï¼Œå› æ­¤å…¨éƒ¨è·Ÿè‡ªå·±ä»°æ…•çš„å¯¹è±¡æŠ•ç›¸åŒçš„ç¥¨ï¼Œå³1æŠ•è‡ªå·±åï¼Œåé¢çš„2 3 4 5å·åŠ¨ç‰©å…¨è·Ÿ1æŠ•ç›¸åŒçš„ç¥¨ï¼ŒæŠ•1ï¼Œå› æ­¤1å·æœ€å¤š4ç¥¨ï¼Œå…¶ä»–çš„åªæœ‰è‡ªå·±æŠ•è‡ªå·±ã€‚ ä¾‹ç¨‹ï¼ˆç¬”è¯•ä¸­å†™çš„ä»£ç æ²¡æœ‰è€ƒè™‘åˆ°é€’å½’æƒ…å†µï¼Œåªå¯¹äº†10%ï¼‰ å¯èƒ½è§£æ³•1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.company;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Scanner;public class First { // é€’å½’çš„å»å¯»æ‰¾åé¢èƒ½å¤ŸæŠ•ç¥¨çš„æ˜¯å“ªäº› public static int dfs(HashMap&lt;Integer, List&lt;Integer&gt;&gt; map, int start, boolean[] memo) { List&lt;Integer&gt; temp = map.get(start); memo[start] = true; int res = temp.size(); for (Integer admire : temp) { if (start &lt; admire &amp;&amp; !memo[admire]) res += dfs(map, admire, memo); } memo[start] = false; return res; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] admires = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { admires[i] = scanner.nextInt(); } HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); // ç®€å†å´‡æ‹œè€…å›¾ for (int i = 1; i &lt; admires.length; i++) { if (!map.containsKey(i)) { map.put(i, new ArrayList&lt;&gt;()); } if (admires[i] != 0 &amp;&amp; admires[i] != i) { if (!map.containsKey(admires[i])) { map.put(admires[i], new ArrayList&lt;&gt;()); } List&lt;Integer&gt; temp = map.get(admires[i]); temp.add(i); } } System.out.println(map); for (int i = 1; i &lt;= n; i++) { System.out.println(dfs(map, i, new boolean[n + 1]) + 1); } }} ç¬¬äºŒé¢˜é¢˜ç›®æè¿°ç»™å®šä¸‰ä¸ªå‚æ•°ï¼Œ3ä¸ªå‚æ•°è¡¨ç¤ºï¼ŒåŸå¸‚æ•°ï¼Œè·¯å¾„æ•°å’Œç›®æ ‡åŸå¸‚ï¼Œç„¶åä¸‹é¢æœ‰è·¯å¾„æ•°çš„è¾“å…¥i,j,kï¼Œåˆ†åˆ«è¡¨ç¤ºä»iåŸå¸‚åˆ°jåŸå¸‚èŠ±è´¹çš„æ—¶é—´æ˜¯kã€‚ é—®ï¼šå¦‚æœæ¯ä¸ªåŸå¸‚éƒ½æœ‰ä¸€ä¸ªäººï¼Œé‚£ä¹ˆè¿™äº›äººï¼Œåˆ°è¿™ä¸ªç›®æ ‡åŸå¸‚ï¼Œç„¶åå›æ¥ï¼Œåœ¨è·¯ä¸ŠèŠ±è´¹çš„æ—¶é—´çš„æœ€å°å€¼ (ps:å®é™…ä¸Šå°±æ˜¯ä¸ªæœ€çŸ­è·¯å¾„çš„é—®é¢˜ï¼Œä½†æ˜¯æˆ‘å½“æ—¶æ ¹æœ¬å°±æ²¡å’‹å¼„è¿‡å›¾ç®—æ³•ï¼Œåªäº†è§£åŸºæœ¬çš„dfsï¼Œbfså’Œè¿é€šåˆ†é‡å•¥çš„ï¼Œå› æ­¤ç¬”è¯•çš„æ—¶å€™æ˜¯ç”¨ä¸¤è¾¹dfsåšçš„ï¼Œå­˜åœ¨é—®é¢˜ï¼Œæœ€çŸ­è·¯ç®—æ³•åº”è¯¥å»å¤ä¹ ä¸€ä¸‹) å¯èƒ½è§£æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.company;import java.util.*;public class Second { static class Pair { public Integer key; public Integer value; public Pair(Integer key, Integer value) { this.key = key; this.value = value; } } public static int resolve(HashMap&lt;Integer, List&lt;Pair&gt;&gt; map, int start, int end, int size) { boolean[] memo = new boolean[size]; return dfs(map, start, end, memo, 0); } public static int dfs(HashMap&lt;Integer, List&lt;Pair&gt;&gt; map, int start, int end, boolean[] memo, int current) { if (start == end) return current; memo[start] = true; List&lt;Pair&gt; temp = map.get(start); int res = Integer.MAX_VALUE; for (Pair tempPair : temp) { if (!memo[tempPair.key]) { res = Math.min(res, dfs(map, tempPair.key, end, memo, current + tempPair.value)); } } memo[start] = false; return res; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(), x = scanner.nextInt(); HashMap&lt;Integer, List&lt;Pair&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; m; i++) { int a = scanner.nextInt(), b = scanner.nextInt(), l = scanner.nextInt(); if (!map.containsKey(a)) { map.put(a, new ArrayList&lt;&gt;()); } List&lt;Pair&gt; temp = map.get(a); temp.add(new Pair(b, l)); } int res = Integer.MIN_VALUE; for (int i = 1; i &lt;= n; i++) { res = Math.max(res, resolve(map, i, x, n + 1) + resolve(map, x, i, n + 1)); } System.out.println(res); }} ç¾å›¢ç¾å›¢çš„ç¬”è¯•ï¼Œæˆ‘ä»¬åŒå­¦æŠ•çš„å‰ç«¯å’Œåç«¯æ˜¯ä¸€æ ·çš„ï¼Œç¾å›¢çš„ç¬”è¯•ç¯å¢ƒè·Ÿç‰›å®¢ç½‘å·®ä¸å¤šï¼Œæ³¨æ„ä¸€ä¸‹å³å¯ ç¬¬ä¸€é¢˜é¢˜ç›®æè¿°ç»™å®šä¸¤ä¸ªæ•´æ•°n,mã€‚nè¡¨ç¤ºæœ‰å¤šå°‘ä¸ªå­¦ç”Ÿï¼Œmè¡¨ç¤ºæœ‰å¤šå°‘é—¨è¯¾ç¨‹ï¼Œæ¥ä¸‹æ¥è¾“å…¥nè¡Œï¼Œæ¯è¡Œmä¸ªï¼Œè¡¨ç¤ºè¿™ä¸ªå­¦ç”Ÿåœ¨è¿™é—¨è¯¾çš„å¾—åˆ†æ˜¯å¤šå°‘ã€‚ é—®ï¼šæ¯é—¨è¯¾è·å¾—æœ€é«˜æˆç»©çš„äººï¼ˆå¯èƒ½æœ‰å¤šä¸ªï¼‰ä¸€å…±æœ‰å¤šå°‘ä¸ªï¼Œé‡å¤çš„äººåœ¨ä¸åŒçš„è¯¾ç¨‹ä¸­æ‹¿ç¬¬ä¸€é—¨ï¼Œç®—åŒä¸€ä¸ªäººã€‚ å¯èƒ½è§£æ³•ï¼ˆç¬”è¯•æ—¶ACï¼‰123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.*;public class MFirst { public static class Pair { public Integer index; public Integer credit; public Pair(int i, int i1) { this.index = i; this.credit = i1; } } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); HashSet&lt;Integer&gt; res = new HashSet&lt;&gt;(); int[][] credits = new int[n][m]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { credits[i][j] = scanner.nextInt(); } } PriorityQueue&lt;Pair&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; b.credit - a.credit); for (int j = 0; j &lt; m; j++) { for (int i = 0; i &lt; n; i++) { queue.add(new Pair(i, credits[i][j])); } if (queue.size() &gt; 0) { int max = queue.peek().credit; Pair temp; while (queue.size() &gt; 0 &amp;&amp; (temp = queue.poll()).credit == max) { res.add(temp.index); } } queue.clear(); } System.out.println(res.size()); }} ç¬¬äºŒé¢˜é—®é¢˜æè¿°ç»™å®šä¸€ä¸ªè¾“å…¥ï¼Œaã€bã€må’Œxã€‚é‡‡ç”¨ä¸€ä¸ªå¾ªç¯ç®—æ³•ï¼Œå¦‚ä¸‹ 12while (true) x = (a * x + b) % m; é—®å¾ªç¯å‡ æ¬¡ï¼Œè¿™ä¸ªç®—æ³•ä¸­xå€¼ä¼šè·Ÿæœ€å¼€å§‹ä¸€æ · å¯èƒ½è§£æ³•ï¼ˆå› ä¸ºæ²¡æœ‰æ³¨æ„åˆ°é¢˜ç›®çš„æ•°æ®èŒƒå›´ï¼Œçˆ†äº†intï¼ŒACäº†65%ï¼‰1234567891011121314151617181920212223242526import java.util.HashSet;import java.util.Scanner;import java.util.Set;public class MSecond { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(), b = scanner.nextInt(), m = scanner.nextInt(); long x = scanner.nextLong(); int counter = 0; Set&lt;Long&gt; set = new HashSet&lt;&gt;(); while (true) { x = (a * x + b) % m; if (!set.contains(x)) { set.add(x); counter++; } else { break; } } System.out.println(counter); }} ç¬¬ä¸‰é¢˜é—®é¢˜æè¿°ç»™å®šä¸€ä¸ªè¾“å…¥nå’Œmï¼Œæ¥ä¸‹æ¥è¾“å…¥nä¸ªæ•°ã€‚ é—®ï¼šå¦‚æœè¿™ä¸ªnä¸ªæ•°ï¼ˆè¿™nä¸ªæ•°æœ‰å¯èƒ½é‡å¤ï¼‰è¿›è¡Œæ’åˆ—ç»„åˆä¼šäº§ç”Ÿn*nçš„ç»„åˆï¼ˆè‡ªå·±å¯ä»¥å’Œè‡ªå·±ç»„åˆï¼‰ï¼Œé‚£ä¹ˆå¦‚æœå°†è¿™äº›ç»„åˆä»å¤§åˆ°å°æ’åºï¼ˆæ’åºçš„è§„åˆ™æ˜¯å¯¹äºä¸€ä¸ªç»„åˆ[i,j] å¦‚æœiç›¸åŒï¼Œåˆ™æŒ‰ç…§jçš„å¤§å°æ’åºï¼Œå¦‚æœiä¸åŒï¼Œiå¤§çš„æ’åœ¨å‰é¢ï¼‰ï¼Œé—®ç¬¬må°çš„ä¸€ä¸ªç»„åˆæ˜¯ä»€ä¹ˆ 12345678ä¾‹è¾“å…¥ï¼š3 41 2 3è¾“å‡º(2,1) å¯èƒ½è§£æ³•(å½“æ—¶ACäº†)123456789101112131415161718192021222324252627282930import java.util.Arrays;import java.util.Scanner;public class MThird { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); int[] nums = new int[n]; for (int i = 0; i &lt; n; i++) { nums[i] = scanner.nextInt(); } Arrays.sort(nums); int divide; if (m % n == 0) { divide = m / n - 1; } else { divide = m / n; } int counter = 0, counter1 = 0; for (int num : nums) { if (nums[divide] &gt; num) counter1++; if (nums[divide] == num) counter++; } int temp = (m - counter1 * n) / counter; System.out.format(&quot;(%d,%d)\\n&quot;, nums[divide], nums[temp - 1]); }} ç¬¬å››é¢˜é—®é¢˜æè¿°ç»™å®šä¸€ä¸ªè¾“å…¥nï¼Œkã€‚nè¡¨ç¤ºè¦è¾“å…¥çš„æ•°ç»„çš„æ•°çš„æ•°é‡ï¼Œkè¡¨ç¤ºå…¶ä¸­çš„æŸä¸ªæ•°ï¼Œç„¶åè¾“å…¥nä¸ªæ•°ã€‚ é—®ï¼šå¦‚æœè¦è®©kè¿™ä¸ªæ•°æˆä¸ºä¸­ä½æ•°ï¼Œé‚£ä¹ˆéœ€è¦å†å¾€è¿™ä¸ªæ•°ç»„é‡Œé¢æ·»åŠ å‡ ä½æ•°æ‰è¡Œ 12345678ä¾‹è¾“å…¥4 11 2 2 3è¾“å‡º2 è§£é‡Šï¼šè¦è®©1æˆä¸ºä¸­ä½æ•°ï¼Œé‚£ä¹ˆå°±éœ€è¦å†åœ¨1å‰é¢æ·»åŠ ä¸¤ä¸ªæ•°å³å¯æˆä¸ºæ–°æ•°ç»„çš„ä¸­ä½æ•° å¯èƒ½çš„è§£æ³•ï¼ˆTODOï¼‰æˆ‘å½“æ—¶ä»¥ä¸ºæ•´ä¸ªæ•°ç»„çš„è¾“å…¥é¡ºåºï¼ŒåŒ…æ‹¬ç°åœ¨çš„ä¸€åˆ‡éƒ½ä¸èƒ½æ”¹å˜ï¼Œå› æ­¤æˆ‘åªæ‰¾äº†ç¦»ç°åœ¨çš„ä¸­å¿ƒæœ€è¿‘çš„kçš„ä½ç½®ï¼Œç„¶åçœ‹çœ‹å®ƒéœ€è¦å‡ ä½æ•°æ‰èƒ½åˆ°ä¸­å¿ƒï¼ˆAC 10%ï¼‰ å®é™…ä¸Šè¿™é“é¢˜æ˜¯ä¸€ä¸ªæ¡¶æ’åºï¼Œåªéœ€è¦ç»Ÿè®¡å°äºKçš„æœ‰å¤šå°‘ä¸ªæ•°ï¼Œç­‰äºKçš„æœ‰å¤šå°‘ä¸ªæ•°ï¼Œå¤§äºKçš„å¤šå°‘ä¸ªæ•°ï¼Œç„¶åå†å»è·Ÿmidæ¯”è¾ƒï¼Œæœ€åå¾—åˆ°ç­”æ¡ˆï¼ˆæ„Ÿè°¢é•‡å®‡dalaoï¼‰ æˆ‘çš„è§£æ³• 1234567891011121314151617181920212223import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class MFourth { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), k = scanner.nextInt(); int mid = (n + 1) / 2; int[] nums = new int[n]; int remember = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { nums[i] = scanner.nextInt(); if (nums[i] == k) remember = Math.min(remember, Math.abs(mid - i)); } int res = Integer.MAX_VALUE; System.out.println(res); }} æ­£ç¡®çš„è§£æ³•(æ¨¡ä»¿é•‡å®‡dalaoçš„æ€è·¯æ¥çš„ TODO) 1 ç¬¬äº”é¢˜é—®é¢˜æè¿°ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²s1,s2 é—®ï¼šs1å­ä¸²ä¸s2çš„çš„å­åºåˆ—çš„åŒ¹é…ä¸ªæ•°ï¼ˆå­ä¸²å°±æ˜¯è¯´æ˜¯è¿ç»­çš„ï¼Œå­åºåˆ—å°±æ˜¯è¯´æ˜¯ä¸è¿ç»­çš„ï¼‰ è§£æ³•æ–¹æ³•å½“æ—¶ç¬¬ä¸€ååº”å°±æ˜¯dpï¼Œå¯æ˜¯æ²¡æœ‰æ‰¾åˆ°é€’æ¨å…¬å¼ï¼Œæ™®èˆªjulao ACäº†ï¼Œè¯·æ•™äº†ä¸€ä¸‹ï¼Œå¤§è‡´ç†è§£äº†æ€è·¯ï¼Œå°±æ˜¯ç”¨dp[i][j] è¡¨ç¤ºä»¥s1[i]ç»“å°¾å­ä¸²å’Œs2[j]ç»“å°¾çš„å­åºåˆ—èƒ½å¤ŸåŒ¹é…çš„æ•°é‡ è½¬ç§»æ–¹ç¨‹çš„è¯å°±æ˜¯éœ€è¦è€ƒè™‘s1[i] == s[j],ç›¸ç­‰å°±è¯´æ˜æˆ‘ä»¬åªéœ€è¦çœ‹dp[i - 1][k](k = 0 â€¦â€¦â€¦â€¦ j-1)çš„å’Œ+1å³å¯ ï¼Œå› æ­¤æœ€åä¸€ä½æ˜¯åŒ¹é…çš„ï¼Œè€Œä¸ç­‰ï¼Œå°±ç›´æ¥èµ‹å€¼ä¸º0å³å¯ è®¨è®ºåŸæ–‡ï¼šdp[i][j]æ˜¯s[i]ä¸ºå°¾çš„çš„å­ä¸²ä¸t[j]ä¸ºå°¾çš„çš„å­åºåˆ—çš„åŒ¹é…ä¸ªæ•° å¦‚æœs[i] != t[j]é‚£ç›´æ¥å°±æ˜¯0äº† å¦‚æœä¸æ˜¯çš„è¯ é‚£å°±æ˜¯ä»¥s[i-1]ä»¥åŠæ‰€æœ‰t[k]ï¼ˆ0&lt;=k&lt;=j-1ï¼‰çš„åŒ¹é…ä¸ªæ•°çš„å’Œï¼ˆå› ä¸ºè¿™äº›åŒ¹é…çš„æ¥ä¸Šs[i] t[j]è¿˜æ˜¯åŒ¹é…çš„ï¼‰å†+1ï¼ˆåªæœ‰è¿™ä¸€ä¸ªä½ç½®åŒ¹é…å‰é¢å…¨éƒ¨ä¸åŒ¹é…çš„æƒ…å†µï¼‰ ä»£ç ï¼ˆTODOï¼‰ 1","link":"/2020/04/24/interview-1/"},{"title":"javaå¤šçº¿ç¨‹(ä¸€)","text":"ä¸€ç›´ä»¥æ¥ï¼Œå¯¹äºjavaçš„å¤šçº¿ç¨‹å˜æˆéƒ½ä¸æ˜¯ååˆ†äº†è§£ï¼Œè¶ç€é¡¹ç›®éœ€è¦ä¸€ä¸ªå¤šçº¿ç¨‹çš„çˆ¬è™«å­¦ä¹ äº†ä¸€ä¸‹ï¼Œä¸»è¦æ˜¯ä¸€äº›åŸºç¡€çš„ç›¸å…³çŸ¥è¯†ï¼Œä»¥ä¸Šã€‚ Runnableå’ŒThreadè¸©çš„ç¬¬ä¸€ä¸ªå‘æ˜¯å…³äºå®ç°Runnableæ¥å£å’Œç»§æ‰¿Threadç±»æ¥buildä¸€ä¸ªæ–°çš„å¯è¿è¡Œçº¿ç¨‹ã€‚ 12345678910111213141516// Runnableæ¥å£å®šä¹‰public class MyRunnable implements Runnable { private int count = 5; @Override public void run() { System.out.println(this.count--); }}// Threadç±»å®šä¹‰public class MyThread extends Thread { private int count = 5; @Override public void run() { System.out.println(this.count--); }} 1234567// å¯åŠ¨public static void main(String[] args) { while (int i = 0; i &lt; 5; i++) { new MyRunnable().run(); // new MyThread().start(); }} åœ¨mainä¸­åˆ†åˆ«å¯åŠ¨ä¸¤ä¸ªç±»çš„5ä¸ªçº¿ç¨‹ï¼Œå¯ä»¥çœ‹åˆ°Runnableæ¥å£å¹¶æ²¡æœ‰å®é™…ä¸Šçš„å¹¶å‘çš„å¯åŠ¨å‡ ä¸ªçº¿ç¨‹ï¼Œè€Œæ˜¯åœ¨ç¬¬ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œå®Œæ¯•ä¹‹åï¼Œå†å»æ‰§è¡Œç¬¬äºŒä¸ªçº¿ç¨‹ï¼Œé˜»å¡å¼åœ°æ‰§è¡Œå®Œnewå‡ºæ¥çš„5ä¸ªçº¿ç¨‹ï¼Œç©¶å…¶åŸå› ï¼Œæ˜¯å› ä¸ºRunnableæ¥å£å®é™…ä¸Šå¹¶ä¸æ˜¯å®é™…çš„Threadçš„å…¥å£ï¼ŒRunnableæ¥å£åªæ˜¯å®šä¹‰äº†Threadçš„ä»»åŠ¡é€»è¾‘ï¼Œä¹Ÿå°±æ˜¯è¯´Runnableæ¥å£ä¸­çš„run()æ–¹æ³•åªæ˜¯å®ç°äº†ç°åœ¨éœ€è¦çš„ä¸šåŠ¡é€»è¾‘ï¼Œå®é™…çš„å¤šçº¿ç¨‹ä»ç„¶éœ€è¦é€šè¿‡Threadç±»å¼€å§‹ã€‚ å¤šçº¿ç¨‹çš„æ‰§è¡Œåœ¨å®é™…çš„çº¿ç¨‹æ‰§è¡Œçš„æ—¶å€™ï¼Œè¾ƒä¸ºä¼ ç»Ÿçš„åšæ³•æ˜¯é€šè¿‡new Thread(new Runnable()).start()æ¥æ‰§è¡Œï¼Œç„¶è€Œæ–°å»ºçº¿ç¨‹å®é™…ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªè¾ƒä¸ºç¹é‡çš„æ“ä½œï¼Œä»¥ä¸‹æ˜¯åç¼–è¯‘çš„Threadç±»ä»£ç  123456789101112131415161718192021222324public synchronized void start() { if (this.threadStatus != 0) { throw new IllegalThreadStateException(); } else { this.group.add(this); boolean started = false; try { this.start0(); started = true; } finally { try { if (!started) { this.group.threadStartFailed(this); } } catch (Throwable var8) { } } }}private native void start0(); ä»¥ä¸Šå¯ä»¥çœ‹å‡ºï¼ŒThreadç±»çš„start()æ–¹æ³•ï¼Œæœ€ç»ˆè°ƒç”¨äº†nativeçš„start0()ï¼Œæœ€ç»ˆé€šè¿‡JNI(java native interface)è°ƒç”¨åº•å±‚æä¾›çš„pthread_createæ–¹æ³•ï¼Œæœ€ç»ˆè¿›å…¥linuxç³»ç»Ÿæä¾›çš„åˆ›å»ºçº¿ç¨‹çš„æ¥å£ã€‚ åœ¨javase 1.5æä¾›äº†ä¸€ä¸ªConcurrentçš„åŒ…æ¥æä¾›æ–¹ä¾¿è¿è¡Œçš„å¤šçº¿ç¨‹ç±»åº“ï¼Œå¦‚æä¾›è¿è¡Œçš„ExecutorServiceï¼Œæä¾›çº¿ç¨‹å®‰å…¨çš„å„ç±»Blocking Queueã€Blocking Listã€Concurrent Listç­‰ï¼Œä»¥åŠä¸€äº›åŸå­æ“ä½œç±»åº“ã€‚ å…¶ä¸»è¦é€šè¿‡ExecutorServiceæ¥å¯åŠ¨éœ€è¦æ‰§è¡Œçš„çº¿ç¨‹ 12345678910111213// åˆ›å»ºæ— é™å¤§çš„çº¿ç¨‹æ± ï¼Œå½“ä»»åŠ¡åˆ°æ¥çš„æ—¶å€™ExecutorService e1 = Executors.newCachedThreadPool();// åˆ›å»ºæŒ‡å®špool sizeçš„çº¿ç¨‹æ± ExecutorService e1 = Executors.newCachedThreadPool(int poolSize);// åˆ›å»ºä¸€ä¸ªæŒ‡å®špool sizeçš„å®šæ—¶çº¿ç¨‹æ± ExecutorService e3 = Executors.newScheduledThreadPool(int poolSize);// åˆ›ä¸€ä¸ªæ‰§è¡Œå•ä¸ªçº¿ç¨‹çš„ExecutorService e4 = Executors.newSingleThreadExecutor();// é€šè¿‡submitæ–¹æ³•å¯ä»¥å°†éœ€è¦æ‰§è¡Œçš„Runnable Callableæ¥å£å®ç°ç±»å¯åŠ¨e1.submit(() -&gt; { // do something}) ä»»åŠ¡é€šè¿‡ExecutorServiceæäº¤åˆ°æŒ‡å®šçš„çº¿ç¨‹æ± ï¼Œæˆ–è€…æ‰§è¡Œçº¿ç¨‹ä¸­å¼‚æ­¥çš„æ‰§è¡Œï¼Œå³submitå‡½æ•°ä¸ä¼šé˜»å¡ä¸»çº¿ç¨‹çš„æ‰§è¡Œï¼Œæœ€ç»ˆå­ä»»åŠ¡çš„é€»è¾‘ä¼šå¼‚æ­¥çš„åœ¨æ–°çº¿ç¨‹ä¸­æ‰§è¡Œ ä½†æ˜¯å¦‚æœä¸»çº¿ç¨‹ä¾èµ–å­çº¿ç¨‹çš„è¿è¡Œç»“æœï¼Œåœ¨submitæ–¹æ³•æ‰§è¡Œåï¼Œè¿”å›äº†ä¸€ä¸ªFutureå¯¹è±¡ï¼ŒFutureå¯¹è±¡å¯ä»¥åœ¨ä¸»çº¿ç¨‹ä¸­æ§åˆ¶å­çº¿ç¨‹ 12345678910111213141516171819ExecutorService ex = Executors.newCachedThreadPool();Future f = ex.submit(() -&gt; { try { Thread.sleep(10000) } catch (Exception e) { e.printStackTrace(); }})// è·å–å­çº¿ç¨‹çš„è¿è¡Œç»“æœf.get()// åœ¨1sä¹‹ågetæ²¡æœ‰è¿”å›æ‰§è¡Œç»“æœ å³æ²¡æœ‰æ‰§è¡Œå®Œæ¯• åˆ™å‡ºå‘timeout å¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼æ¥å¯¹ä¸€äº›ä»»åŠ¡åšè¶…æ—¶å¤„ç†try { f.get(1000, TimeUnit.MilliSeconds)} catch(TimeoutException | InterruptedException | ExecutionException e) { e.printStackTrace();}","link":"/2019/12/10/javaConcurrent/"},{"title":"kmp","text":"ç®—æ³•ä¹¦ä¸Šä½¿ç”¨çš„æ˜¯ æœ‰é™çŠ¶æ€æœº æ¥æè¿°çš„ kmp ç®—æ³•ã€‚ ä¹‹å‰å­¦ä¹ çš„æ˜¯é€šè¿‡å‰åç¼€åŒ¹é…çš„æ–¹å¼æ¥åšçš„ kmp ç®—æ³•ã€‚ ç°åœ¨è®°å½•ä¸€ä¸‹ã€‚ å‚è€ƒï¼šé˜®ä¸€å³° blog å‰åç¼€åŒ¹é…å®é™…ä¸Š kmp çš„æ€æƒ³å°±æ˜¯åœ¨å­—ç¬¦ä¸²å¤±é…çš„æ—¶å€™ï¼Œè·³è¿‡ä¸€å®šçš„è·ç¦»ï¼Œå°±å¯ä»¥ä¸ç”¨é‡ç½®æ¨¡å¼ä¸²çš„æŒ‡é’ˆåˆ°å¼€å¤´ã€‚ å¦‚ å­—ç¬¦ä¸² a b a b a b a b c a æ¨¡å¼ä¸² a b a b a b c a kmp a b a b a b c a å¦‚ä¸Šæ‰€ç¤ºï¼Œåœ¨å¤±é…çš„æ—¶å€™(çº¢è‰²æ‰€ç¤º)ï¼Œä¼šæ‰¾åˆ°å‰é¢å­—ç¬¦ä¸²ä¸­ç›¸åŒé•¿åº¦çš„å‰ç¼€å’Œåç¼€(ç»¿è‰²æ‰€ç¤º)ï¼Œè¿™æ ·åœ¨åŒ¹é…çš„æ—¶å€™ï¼Œå°±å¯ä»¥ç›´æ¥è·³è¿‡è¿™äº›é•¿åº¦çš„å‰åç¼€ï¼Œå‘å³ç§»åŠ¨ 6 - 4 = 2 ä½é•¿åº¦å³å¯ã€‚ é‚£ä¹ˆå®é™…ä¸Š kmp çš„åŸå§‹è¿ç®—ç®—æ³•å°±å¯ä»¥å¾—åˆ°äº† 1234567891011121314151617181920public int kmp(String origin, String pattern) { // è·å¾— kmp æ•°ç»„ int[] next = getNext(String pattern); int i = 0, j = 0; while (i &lt; origin.length() &amp;&amp; j &lt; pattern.length()) { if (origin.charAt(i) == pattern.charAt(j)) { i++; j++; } else { // å› ä¸ºæœ‰ç›¸åŒçš„å‰åç¼€ æ‰€ä»¥ç›´æ¥èµ‹å€¼ å°±æ‰¾åˆ°æ¨¡å¼ä¸²ç›¸ç­‰çš„å‰ç¼€çš„ä½ç½® j = next[j]; } } // è¿”å›å¼€å§‹çš„ index if (j == pattern.length()) return i - j; // æ²¡æœ‰æ‰¾åˆ°åŒ¹é… return -1;} è€Œ next æ•°ç»„çš„æ±‚æ³•ï¼Œå®é™…ä¸Šæ˜¯ pattern å­—ç¬¦ä¸²è‡ªå·±è·Ÿè‡ªå·±åŒ¹é…ï¼Œæ‰¾åˆ°ç›¸ç­‰çš„å‰åç¼€çš„é•¿åº¦ ä»¥ a b a b a b c a ä¸ºä¾‹ å­—ç¬¦ä¸² å‰ç¼€ åç¼€ åŒ¹é…çš„æœ€å¤§é•¿åº¦ a [] [] 0 a b [a] [b] 0 aba [a, ab] [a, ba] 1ï¼ˆa ä¸ a åŒ¹é…ï¼‰ abab [a, ab, aba] [bab, ab, b] 2 (ab åŒ¹é…) ababa [a, ab, aba, abab] [baba, aba, ba, a] 3(aba åŒ¹é…) â€¦â€¦ â€¦â€¦ â€¦â€¦ â€¦â€¦ ä¸Šé¢çš„è¡¨æ ¼è¡¨ç¤ºäº†å‰åç¼€çš„åŒ¹é…æƒ…å†µï¼Œä¸‹ä¸€æ­¥å°±æ˜¯æ±‚å¾—è¿™ä¸ªå‰åç¼€åŒ¹é…é•¿åº¦çš„ next æ•°ç»„ 123456789101112131415161718public int[] getNext(String str) { int n = str.length(); int[] next = new int[n]; // è®©æ¨¡å¼ä¸²é”™ä½ä¸€ä¸ªå¼€å§‹ kmp çš„åŒ¹é…è¿‡ç¨‹ int k = -1, j = 0; while (j &lt; n)) { if (k == -1 || str.charAt(k) == str.charAt(j)) { k++; j++; next[j] = k; } else { // æ ¹æ®å·²ç»åŒ¹é…çš„é•¿åº¦ é‡æ–°å®šä½ k = next[k]; } } return next;}","link":"/2021/03/07/kmp/"},{"title":"ç­¾åˆ°äºŒç»´ç ç”Ÿæˆ","text":"åšè¿™ä¸ªä¸œè¥¿çš„çµæ„Ÿæ¥è‡ªäº[lufer blog]('http://coder.lufer.cc/2018/06/11/%E7%8C%AB%E9%80%94%E6%A0%A1%E5%9B%AD%E7%AD%BE%E5%88%B0%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%BC%AA%E9%80%A0/')ä»¥åŠå®¤å‹çš„å¾®ä¿¡å°ç¨‹åºæ‹†åŒ…å¸®åŠ© åšè¿™ä¸ªäº‹å„¿çš„åŸå› å˜›ï¼Œæœ€è¿‘è€å¸ˆå‡†å¤‡æ´¾å‡ºå»å‡ºå·®å»å­¦ä¹  2 å‘¨ï¼Œä½†æ˜¯äººå‡ºå»äº†ï¼Œè¯¾è¿˜æ˜¯è¦ä¸Šçš„ï¼Œå°¤å…¶æ˜¯æœåšå£«çš„è¯¾åˆåœ¨æœ€è¿‘å¼€äº†ã€‚æœåšå£«è¿˜æ˜¯æœ‰ç‚¹æ€•çš„ï¼Œè€Œå¥½å·§ä¸å·§æœåšå£«åˆå–œæ¬¢ç”¨å¾®ä¿¡å°ç¨‹åºçš„çŒ«é€”æ ¡å›­æ¥è¿›è¡ŒäºŒç»´ç ç­¾åˆ°ï¼Œæ‰€ä»¥æ‰æœ‰äº†åšè¿™ä¸ªä¸œè¥¿çš„åŠ¨åŠ›å’ŒåŸå› ã€‚ çŒ«é€”æ ¡å›­ç­¾åˆ°äºŒç»´ç ç”Ÿæˆå»å¹´å·²ç»æœ‰å­¦é•¿å¤§è‡´åšè¿‡äº†è¿™ä¸ªäºŒç»´ç çš„ä¼ªé€ ç­¾åˆ°ï¼Œç²—ç•¥çš„çœ‹äº†ä¸€ä¸‹ï¼Œå¤§æ¦‚å¯¹é¢åªæ˜¯åœ¨äºŒç»´ç é‡Œé¢æ˜æ–‡æ”¾äº†ä¸€ä¸ªè¯¾ç¨‹ID&amp;å­¦ç”ŸID&amp;&amp;å½“å‰æ—¶é—´çš„ä¸‰å…ƒç»„ï¼Œé€šè¿‡åœ¨ä¸€ä¸¤ç§’çš„æ—¶é—´å†…ä¸æ–­å˜æ¢å½“å‰æ—¶é—´æ¥å˜åŒ–äºŒç»´ç ï¼Œè¾¾åˆ°å¿…é¡»åœ¨ç°åœºæ‰èƒ½ç­¾åˆ°çš„ç›®çš„ã€‚å¯æ˜¯å’±å¦å¤–ç»™ä½ ç”Ÿæˆä¸€ä¸ªäºŒç»´ç ä¸å°±è¡Œäº†å˜›ï¼Œ23333ã€‚ é—®é¢˜è¿™å‘¨ï¼Œä¸“é—¨æˆªå›¾äº†ä¸€ä¸ªç­¾åˆ°äºŒç»´ç æ¥æ‰«ç è¯•è¯•ï¼Œæ‰«ç ç»“æœå¦‚ä¸‹ã€‚ 1x%97%C5%94joj%97%93%92%98ggf%60%60f%9C%C8%C6%C7%94a%95%8B%5B%98%C7%C6%9Bke%98%98chni%95%92%60foo%99%9Anm%99%89Wfjloqljnnikp%5D%u5F46%uC46F%uC8C6 å—¯ï¼Ÿï¼ï¼è¿™å’Œè¯´å¥½çš„æœ‰ç‚¹ä¸å¤ªä¸€æ ·å‘€ï¼Œä¸æ˜¯è¯´å¥½çš„æ˜æ–‡å­˜å‚¨å˜›ã€‚åœ¨çœ‹åˆ°%åé¢è·Ÿç€æ•°å­—çš„æ—¶å€™ï¼Œæœæ–­çŒœæƒ³æ˜¯ä½¿ç”¨äº† js çš„encodeURI()æ¥è½¬æ¢äº†ä¸€ä¸‹æ— æ³•åœ¨æµè§ˆå™¨è·¯å¾„æ é‡Œé¢è¯†åˆ«çš„å­—ç¬¦ï¼Œç„¶åæœç„¶Â·Â·Â·çŒœé”™äº†ã€‚ å°ç¨‹åºåç¼–è¯‘ï¼ˆè¿™æ—¶å€™åˆè¦è†œä¸€æ³¢å®¤å‹äº†ï¼‰åœ¨å°è¯•äº†å¸¸è§äº†ç¼–ç å’ŒåŠ å¯†æ–¹å¼éƒ½æ²¡åŠæ³•æ‹¿åˆ°åŠ å¯†ä¿¡æ¯åï¼Œåœ¨å®¤å‹çš„å¸®åŠ©ä¸‹å§å¾®ä¿¡å°ç¨‹åºåç¼–è¯‘æ‹¿åˆ°äº†æºä»£ç ã€‚(å¾®ä¿¡å°ç¨‹åºä¼šåœ¨æœ¬åœ°ç¼“å­˜ä¸€ä¸ª.wxapkgçš„æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶å¯ä»¥åç¼–è¯‘å‡ºæºä»£ç ï¼Œåç¼–è¯‘å·¥å…·)ï¼ˆä»¥åå°±ç®—ä»–çš„åŠ è§£å¯†æ–¹æ³•å˜äº†ï¼Œä»ç„¶å¯ä»¥é€šè¿‡è¿™ç§æ–¹æ³•é‡æ–°æ‹¿åˆ°ä»–çš„åŠ è§£å¯†æ–¹æ³•ï¼‰ã€‚æ€»å€¼æœ€åæ‹¿åˆ°çš„åŠ è§£å¯†æ–¹æ³•å¦‚ä¸‹ã€‚ 1234567891011121314151617181920212223// åŠ å¯†function encrypt(str) { for ( var t = String.fromCharCode(str.charCodeAt(0) + str.length), n = 1; n &lt; str.length; n++ ) { t += String.fromCharCode(str.charCodeAt(n) + str.charCodeAt(n - 1)); } return escape(t);}// è§£å¯†function decode(str) { str = unescape(str); for ( var t = String.fromCharCode(str.charCodeAt(0) - str.length), n = 1; n &lt; str.length; n++ ) t += String.fromCharCode(str.charCodeAt(n) - t.charCodeAt(n - 1)); return t;} æ€»ä½“æ¥è¯´å°±æ˜¯é€šè¿‡ js æ¥äº§ç”Ÿäº† unicode ç çš„åç§»ï¼Œåœ¨åŠ å¯†æ—¶ï¼Œé™¤äº†ç¬¬ä¸€ä½åç§»äº†å­—ç¬¦ä¸²é•¿åº¦çš„ä½æ•°ï¼Œå…¶ä»–çš„å‡æ˜¯åç§»äº†åä¸€ä¸ªä½ç½®çš„ä½æ•°ã€‚å”¯ä¸€ä¸æ‡‚çš„æ˜¯escape()å’Œunescape()æ–¹æ³•ï¼Œä¸€æŸ¥ï¼Œè¿™ä¸¤æ–¹æ³•éƒ½å·²åºŸå¼ƒÂ·Â·Â·ï¼Œä¸ä¹‹å¯¹åº”çš„æ˜¯ encodeURI()å’ŒdecodeURI()ã€‚äºæ˜¯å°†ä¹‹å‰æ‰«ç æ‹¿åˆ°çš„å­—ç¬¦ä¸²ä¸¢è¿›å»è§£ç ï¼Œå¯ä»¥å¾—åˆ° ç°åœ¨å˜æˆäº†ä¸€ä¸ªå››å…ƒç»„(&amp;åˆ†éš”)ï¼Œç¬¬ä¸‰ä¸ªæ˜¯æ ‡å‡†çš„ unix æ—¶é—´æˆ³ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦æ‹¿åˆ°å››å…ƒç»„çš„å…¶ä»–ä¸‰ä¸ªä¿¡æ¯ï¼Œç„¶åè‡ªå·±ç”Ÿæˆä¸€ä¸ªæ—¶é—´æˆ³ï¼Œå°±å¯ä»¥ç”Ÿæˆè·Ÿä»–å®Œå…¨ä¸€æ ·çš„äºŒç»´ç äº†ã€‚æœ€åå®ƒæ¯ 3 ç§’é’Ÿç”Ÿæˆä¸€æ¬¡äºŒç»´ç ï¼Œä¸è¶…è¿‡ 5s çš„æ—¶é—´å·®å°±æ¥å—è¯¥äºŒç»´ç ã€‚ è‡ªå·±å†™äº†ä¸ªç”Ÿæˆçš„é¡µé¢ï¼Œéœ€è¦ä¸Šä¼ ä¸€ä¸ªè‡ªå·±çš„ç­¾åˆ°æˆªå›¾ï¼Œå°±ä¼šæ¯ 1s ä¸­åœ¨é¡µé¢ä¸­ç”Ÿæˆä¸€ä¸ªäºŒç»´ç å’Œåˆ†äº«é“¾æ¥ï¼ŒæŠŠåˆ†äº«é“¾æ¥å‘é€ç»™åœ¨æ•™å®¤çš„å¤§ä½¬ä»¬å¸®å¿™ç­¾åˆ°å³å¯ã€‚å®ä¾‹å¦‚ä¸‹majexh.xyz/qrcode","link":"/2019/05/17/maotuQrcode/"},{"title":"ä¸€äº›åæ§½çš„é›†ä¸­è´´","text":"4d5b354008a79032227bf4d2dcfc8ac348f0e256e558eca4a30f845895870ce8fb5e8f8fb0907b486c29aa2a1c5cfe43a0705892748bdafa18044d53171cc282a0158f686b95a14bcaf0529f57c540003c62a7154aa095f6ec434dc400a39f688aa811682f6add45ab148d3b3db137d2504a6ba23d02bf8e27fcf15870338c4189be78f818213f6d0522cdd8c983de66fb311b49504a97e808e3f21cb7db10b53ca9b3923add8b1fdbbabfa5505967f64ec0ff60944b56fae433a1a74f7511ca8f8484fd9e4c481bac1c5829892916b279fe4a04d6650e7345a86eec364bb88cc1ce5b9ec114091d2db12cf261a8b4c313c5279a406feac438b048099a81be4ccd0e527e5545c2addecac06e02f4259258e053a883f827d340a069c2e6dc79cba72c5e343b07f7fb171ed5d5a7f6959bbc4ec8b7d56865439f31bb687714f6aabb20f004b8f27c03a695740f8f25f1c4f0798638972112bcb01278020cb2f89b6f8dad32a32e44d30138ef398f48e664ac41e3ff2b7d229e32562a738bb1bb3666a21a1a15cbb514b0058c93ba847b27e2aa44b16ee36138e3471e09d4753074a8c22d35dc22984534e293d8710ab2390695a782c21421e260949d26f064bb2042b1eb9b6eb0ae2eb3c703f0bc8dfd570ae6e64bcf5d4108bde72bee146f5e74d4feaed1084dae44bc28f68195647dd0c66257794f96a29f123328ef4ce41794ad0221ae1a32a8d20ccb7ca9f48b046b66a992abdbd182a94fba8688137e73aad952d6551255bf24338bb63fc044529af044db22ff678bb676397f297d2b549c73ce8aa848a18af352b3bc5478ce6fab9a7310c71d441218457c40a7e16191c7a98ea448ff0e6a30fd22c5bdf1296217d60093d531fd138917a6c497ec6fef4cd3b7ce973d957b9f0083e175c3c392053854791752186d1ae1d0cfd23665ea1f81dfcc0d8c3a647cbee8698e8df8838632342bd3bed47ba0efcadaafcfb625dab57f98a2a0a7aaef180e83c39395a0f78ab3c0c20873785277ad190341831ae827000c9266e624852fbb029e4361bcbdead34af7a9e45a5503459f16bb7cffdd828c6cd17a7178b479d734860935147cc0b3a8752204e62c22332eb5ef60c1e940fb83cff797bfa0e0638b64ac3dd5033f877669bc3bd8fb00e190728a0e5ca524581466ebac3e6be2f356ad33f31c58e06fa9d381c4ca0d2c1f37262df51e24cfe0b82db1556c713298204522c5c1fd68f0b3d9c9624988c71e15374570ffa63ed576d998d0c667c90f4e2b6c14e43f4f0d7845b15afd741653752c4185d9753baacd2030daebe63adc3298129ca30acbbb20de0eae03e7537329e899bb8044499cdc58aaa0eb586261f0fa27d63372cd6b7c57735c0e8ec8735a514cb2ad3918bbe9424eb9acd8deaf9ca50518d905e79581401fd37da4b950e63f80269aa498b0f98dfad2786f19b2af0813f5c4877c8fcfcf6c8e105686cf5e206ec2ac3411b57299a22317cbf5aa898f3bd2b3a2d5aa983545c0a1d427f114405ae63f8d1929ccc6575f64a417cb61ebad62e5972f566504b0f1b0b434656fe94427f40b77526e4706d083378101c4cba3c1d1fa63c6005e34b0422a483e6e71eb2c0b6a77d7399bab425594cb11593f933f6ee0646b7fb1fd26e148b0908356d9ad990f1fa1cc5a6e0f1a2b7b5e50de6f4d27d8bd5d3c282fb8217891689671d82878fea61049e4d28e2b1a5212f3e19dcb1a48d982a2d4d2c6d9ac4fe5f9c0eb3ac13b31bbbe188340703d3821ae4fd53216c1238d96296f91ce3b70bd22f84cd96b047738bea76f779a9ab11180e23dd59e45dfdc8ca08770872c0b585cb2467618882ee089b0b497e01a1b889e2300a983e90cf7077703eed7bb3575435c612946c469de05bdaba01a37aede9c4d949cdfbde171917c49d933c790a6980a2c02fff811f725174c5c16f8799db9336a47d19e8c700627f5c55727b6faa41a0d6c2664044f0ed693536cd1f7d78fc7630c4e6e46ddc6d54854cae7da43dc257d4f183d728ad961fb3aed31255385cb403b3c6df996b7a57645ea608f8e452e5eeb9b38eb372434c1c66b7b203a4dfb80c55f5ab17ed7a94a84e955a2a91c76ee066cb72544cde387a7f8a20ac2c4d8e7653d2940780e637bfa5d6022b9d246d561c99f985bbc1a62aec6a1874a96ad20f0434ed6e77120ea669fdf4d685b09faf6e98c2ec5992d90676927f5fcf53c4601c666795731946e67b2d71f2d52cb6ae91e4155d735bc069610459d814103a0c72eec23569413a268853f5a8f4947e7430664a2648aa1c57cec3ca37559ffdb43ae1dee24c039b66bf660bfdd0ae7aecbb9b95dc1f1d6a2ab44f915fb1b7396d350b72bb8a4d42f60c085f40aaed15be042475efe8a59c2e087875f747c2f9d3820659e985a78e7e3f28a9b13142c033d7c5c303fe436286eb6aeff8030b6157d4208d4e863e089c6d85027dc20f94c372d9cc3f07733a1282a59390c6b7acfb5a7eea9968ea701e812fb5f1350d37e4544f67533ddd45b4092e404eac1439aea27efc5bf008d1660ba7563185f1f173e8e4b9c06befb0379e21fc595f97619944ae9ecfeb13ed9663c36886d68daebc3f7e711d9f25e75802119d69e3c3827f71bb43df7fab27e25b165a2b8a452394fec9e0728f4d25e129cbb36d31e7854bd9d4693e3a37d1820aef9084547dacf914f74f40b50a597dbff19ffd07ff6150de3e26d58a1109727b4bf8800d928bb38ac236dde1638567af7dd8ad952841930ddfabcba921bad528c9adae8276429c0bb17c0c94b050183a670302a5a248e5c8a08e3858d7fcc5090a543b33f71f516ff8f08a494dadafd151a657d906ef916a36a08f41f57b3e25ccb00b50340cb7e39c711ca8d34a9f4e016a338edc18e04a68dc0f04135ec3d3f31198d50853b3ff0edbbd9860ca9c81eafd302e5fc4437c60d5ebbdf68a38ce6c3f83c78405efc213fa97eb0c794b6dd05ffdc5f1fb077d586a2e6253c836517ad099ff05e0aebe0f3e6647feba34a82698baf06f712a85e78c96dcda8c0e8a638e33d608f42674b40b86baaa8a4733aa7b848e4e5e09a5c40e77fab935376631db73555c16b2b38a696a802e3a6e8ed370af64ca5a0faf274e092ed71d1c4db0c62e67b1c714963ec16ccda1959d8ba6712d350b0a9a2c3db51f456b3badd8906d8f0888f48333c51724a3680a615d0a2f3973ba48dddb52723d6291802348a199a59f8bc38017439d2209133740c6b9e8f78c0ea9df1d575db892f6e0ca9d4afbe629536872a8f01f0e2479f4b785b09702924e4a739666d0a5bb247f8f504401891ce00c527b7fad8b74faed7fd74fe93189601ec046d2527d2736c5719b72d96fd06a3670b0d230fbb15a90e8c433a1141061a5fc45cc34a000bd0bc202b9d14e53fd78368421f3222a55c5f0fcd26dbf2c544d8b2f13926bdaf1801762ccdb04725cc998788ec31d0737ef3bb5409261ebe4990e689b9a38dd3cbb4dc45e90a22642b2b87ffaaab1aba29af1fc44212f6c7e13f19cb0fe6be9cdb99baf0bb3108a2e85dfc0f8b67b35298ff1b4bbf61356a14b5ab9b89e0c31ac728216a6aacb5a53ef039c3cdd4daec86f5f41b3f641cd46f7e285793f2cb26128ca14b05546f9ec7966e0438f4db8c014b2c0273689378ed09e519f4e7267a1d5471814f277a955cb1baee7676a3b17c03988c2aee7bbd7ecac07b8b737049f1817f4a1ca9a76a98f5834eafe5d2c593b6ec5e4348a1c6d7d83a1005258a28677c254e9565c05ae2c57d157040dfc2098b7066cbb17b6a7d36b4f127dd6ca8bb0db615d760f8929aa53b75856b954c5fe0fae0bf5b5c210903dc14d09ac01622cd59fcb03dca7ca20bf5b0365978a91e3c3f5fde00d155aa0a68471c5ae2f65f788b8e58e865122c91db123aeb6de64a3addbf563b79427ad1c2c35537518c3e1b2da839c070bd7d3f9a16f91cf474dd55fac9d00922b7fd6701497dd88e9dcd75a1addeefc49046f0be0ddff92afd7dfca598ac58c7ad90b3a5e8a0e8f0294e866520e3e78a7c3a077e95d2d6a7703318832db8b3c5f54e8c4dc39c18ae57576777f0b4b697560c5ee566248f812cc6512388f6e12ed462da3116e81de74ede576d6b91e8d1294cdc7e312ffdda47448e004aa4e1bea540f68359a28dbef30dbcaf3a08b6eb4a8f7464ede227148bdfd07f1a1871330f0bee4b596223cf9f58de545ac9e7a1c9f3fa37048573a0a57208fb358ef319276887fec7dcff3df6d1cbe5c80320c0b47b25b4ee8aa456d4fe68d971a7254e964b039d2abdce999f682deab5f8638545e2fbce9f8ab351874332300c6c1f08c97d7f11788824c3489e92394b833ea2bc4831c023a48400d5282a4116ade049eb4072131ecd78b36e62ad5c7a4777f5985192a41fdc5f67f435c3cf88cd5c0e8bf6afe1aacdfda46518f3d2d35365ef414c90181d88d9f3d533453b60c5860fac4097303120b65858d92f7069590bfe95a16556c1a3d2959629c205dfb1f5e90fb506f0812e34a9a7f928d176a57edeef33f3ed331b5a7f646ea799ac6be92ae3a9deb6e0c5e22714462523f1d196e3a7353cf73bba326bc2c5f0f98c2beb226f2fe2d5e7979c5d7792cb5dc61d10e86feb5dcf7cc00fe4ebc69451c7d3203a25d90702bcc0c4c5c675fb3e7605cc0eeda56210a92f0f28550387c1519c1cf8205afad3608ac96f7d8e857e6712ea38b17017d7148224e99b6cf7612d24630d28b3b3fe278e18c9b036b7cdae3440f1c6f7a96965fa423d2196751763654fbae9688792a19fd12097390e2013f1eaf57bd1226338bec7dcf9e0ebbc8a570cea7856a08d6c00522b98aae7c48cbbea62773bf66cd08ce72b154ead879c762736ef874869c8d176587bf7f4bda03845c43d0cd84dda632181b3636f4a14b91a464416582f12ef6761b319507f9e74fc24d70c66bd4cf7bf6f0e7cae7a932a96b9aec9cee1873dd1d35a80a2aee1d9cc074925559b8bbf0e9f5772fac4d6738f36479f631390aea94a96812fe651d9b3d5896cd89910ce3cf78490d1c874434a43d7c9dd24fc54de74090cf0b302a21be8942f1057bef175edd1cf6229059e777f53effc833178e4c88ffa08f1ed647ce575e6abc26a5aade790b181c936861c5f8ed6722ec84a43a21832957972832684e7e6498689f3abb78f2f84823e272b25f9a6e425a845b8333a83d08d521be9a9af1fde78bd70de54ebc1e58293ae11038d32c3ca8ac5b833a72a95ab251bc2ae11a5a0c611ca8c96dadf3ecb8bf5a5d50e47a665680b67d3ff3c427d3b5d5094d5dfab2fdf1d3693635bc22c946a62a2d482dc072cae1ee671beb8df147d1b099d7da37d3c413af71a75e77a236a1be10f3bafc8f4231347ac2902f0570b76ac7fb90d4dc2530afdf4364d1229e98f2d4dc3360e438663877b0c087108e9068367ab663a1a0bffcb663d61f4047ef9f906034d879fef1eefe48d30427d1976972c8236a5243a67ea0025987da2e80f172b32a638975853f26f8bc932487be81722756babf1650e182c07bd4c76d33106261db6769f9cf75869b212542440d14a69b2f118c95980cc2e69d0df802fc20a7ae2bf2146753894b92ddb87c8de59fcd4047ab09b22595f7e410810b89d40b2a64741009b4be258e4d7a655f59d13042467eb37e18dd4e5bf2a07455af6b8717294a7cda59d31e3444edcae18bb561ada2824adb0ae0620d935d3ee724e6c5ae3ae79acad04ac56f2632301912fbca0de68b6befc0018c1277c3a42f081682b69bcee5c8441f47c45b9146693ec8a6b935e66c99b2db8441db819b29af1a7eb4807becc40999438bfcebc8d6c78ebaaa4fa15e603fed563f6b930fce0ad747d93572e68af2b5de135d1882f7e0b47c9b2511137c727318b879d17e1cca17d12d28dcbfae7fa81b2e7eef237d51b03678c9b906e2a6eab2a630600af09cb3d04eea3a12827af4535f7c50d954eb88b0b10e86051d8033d134061c6f67d1f986af3ce9da9c5fd3b563976a729d039fa72567c749d50d3b3ce746d11f508a1ebd7389599420c4e012e7dbd986a40288b9be6e2939bfb75b4eebd334405532822daa32e85e2ab375d70ed8d9ba2badcc4250dc848cd8ff3358726fd8d04fde49f9b5f273ba3b37e8e6df0f46884a4f3ee6dc227c91b8caf4a5492cc336c6b1be8f1f81435416a09e6d155a39cb181b06b187d4943981e888fd169cfdd7e097bfd7a8aa4c3f3a6185c963cee12328850f97ca6d536de86d7e74263e620a0994f32cc09dcf3a4eea5f589c9b767039ba7121dfc1187c9a99fccc4b3b341c8c41705f08f06dcd61c8d2ff73b63f91cb99b40eeb21f4e65690851578a07b9b31710bd0f9b71d98117767a57dcae11aabfe93b5fb87d680bef7a2de954da595d0c4f49ce5a2d45d87d51e15c7cba5c93401d85fe1297c123d60573b17193ea17430b57591a51e7afb2534b11028dfb5ef4607f3d9f5235f05021d395f72864ccc83becd4e109b6a8cce14ba86dd75b301ffd2acac7a9c9bb35cf6bfdeb1e8c8f56fe3167184214d04c5411717b5421300277b517f387bd1f3874119e57b22742242b81ab65018f104e0d6396ea17d1f1ca48611c02c927755a8a4c09bd63af2f7223fd4fc1d57ab53f603285dd9e9540da4082256187c50b2d9ca8d055a2cae61f1a2249f86231cb9e0ef13237efbce5a36a040e31221fc74572bac84fc8023384b47f6fde437045db25ea33e26df7abaf144efdb05ee1b96c95c6f088fb5027cc6d375301c9f9c7f8186f55e09e19f045cebd0dc7e8d4ad43bc2539cb619994a564807638ecd6211917d43a9afaeaafe58472314b9baa1ce9ba6495d90346af8f52c037936ea66d7393cf79dbcc0639ea6ed093df58055003226a44f1c3d4b21cb2b4925b30b567c888c0af70224cfb32dc70038df637cc1f23748c6cfe690a5be6fc76a3781a69db413bb92c7d3812cdea9e63d39865364ff9aeb8d1e8357184a4c5d08c7bf7303b01acef09d417552ac6d2bc1fe2132fb2d836437b55e1aed40809db2b2163e31f4ae78b3409ac6f79c96fbf391a9cd298843fcc572c8bbd1bf739b88e0dbabb3e82824a894e5465b7a67602d41e682f6f7dc0f1a0f1048cd945912e8cb3fdce312fb245653d56de7b49c66bd722f4d9a50f28b2e90954f86f93c4072c3881b7a108ab16e7c3a4b7df172741774772e22083963a16c5ca4c7b07611451a0c0603d89d731908352e97855983def85a6e0218e6753afdd787790763a91417dd396c19b74da6f3277e2f6e771977b0db1bc875269cb94b92c747c77edf79cb00e3cff95550e279e78b5cefd4dd2e4561b625550e3f80b75abd840f08e86fc233552b70e9cd6ddb71f2f5effdeb950e03fa3c261585252f76116550102073610820ae9f98ff86fd83cedacce9657480e913a93fa36020d52bb3835aafa92048bd7a52988ead550a0e03efd546b8826962ebbb07b57899067a9fe455ec3df86b0e57477fb87816ea63662f52df221f61ac52f208f140e9cb525bec09225ba6af0ab7854b236949a31a9d3855516bda811412a772cdbe62ad27fbaa0e012b97610b3ba6a8fe0edc5962a9fb7cca652a87efe81e0eefac379f229261e35c7cfe025ecc12a32518c8b28b1f69d5e3650e33da460ed186b4a913c5943d0274ae4d659ac0a91d2bc685d47b157034447aa7761c493f3663d22dda3a590588348942c689f401f17bcebea7ed399f445b2dbafb9c77d332bbd24e858657e6c7a7ee331aed150abc2aadd352e3abd59f7b77c62317e51bb21249fa8905e2608162307a418052299fa9ab051e9d2b0067300b0820b7a11fef103098d602bbeb456bb20e33dbbe32a476a27fdb71361d85ee9b2a264021439aa471410bef2686c03842434d14d8b93ca60c4c0281da4ae93748096df8b4e21f3c11b2c3e6f5b6ac96ac8079073d18bb0aaaeff933ea51cceac2746509b2c70574d14b31cce44099670e1e58a701c4d55132c5593927f1457ddda8110a76b3dcf0e10d77ddf21593e43eb98e6c09d628114da0aa06a8d162a1f8e4d5e1320c3824bcccf3c1ce3a4d9875ebc1fb38855a98d8c39d9015abca386c0b56b983261510c639e366990c1c89d3a1f74864f1ef13b15f94c2efd7fbb28bc6ea75c4ac66b6aef012ea577f579ad2d4e34543945c9c854ccda362f15a2d4189f2849495878f08d50277d3306953e5b64d6bbdd63d277a4e096ee586852eb2d58e16b923dd569abf53475f1a61f31bf22bcbb3af5c8 è¯·è¾“å…¥å¯†ç æŸ¥çœ‹.","link":"/2019/09/15/master-complaints/"},{"title":"sort","text":"æ’åºç®—æ³•ç®€å•å®ç°äº†ä¸€ä¸‹å‡ ç§å¸¸è§çš„å†…æ’åºç®—æ³• å¸Œå°”æ’åº å½’å¹¶æ’åº å¿«é€Ÿæ’åº å †æ’åº åŸºæ•°æ’åº æ¡¶æ’åº å¸Œå°”æ’åºå¸Œå°”æ’åºå®é™…ä¸Šå°±æ˜¯å¸¦æ­¥é•¿çš„æ’å…¥æ’åºã€‚ä¸åŒäºæ’å…¥æ’åºæŒ‰ç…§æ­¥é•¿ä¸º1è¿›è¡Œæ’åºï¼Œå¸Œå°”æ’åºé‡‡ç”¨äº†ç¼©è¿›çš„æ­¥é•¿ã€‚æ¯æ¬¡åªåœ¨ç›¸åŒæ­¥é•¿çš„ä¸€ç»„æ•°æ®ä¸­è¿›è¡Œæ’åºã€‚ å‚è€ƒç»´åŸºç™¾ç§‘çš„è§£é‡Šï¼Œä¾‹å¦‚å¯¹äºæ•°ç»„ []int{1,5,4,2,7,45,75,3,4,87} æ’åºï¼Œé€‰å–æ­¥é•¿ä¸º len() / 2ï¼Œä¸”æ¯æ¬¡æ­¥é•¿ç¼©è¿›ä¸€åŠ å…¶æ’åºçš„è¿‡ç¨‹å¦‚ä¸‹ ç¬¬ä¸€æ¬¡åˆ†ç»„ ï¼ˆæ­¥é•¿ä¸º 5ï¼‰ æ’åºå‰ 1 5 4 2 7 45 75 3 4 87 è°ƒç”¨æ’å…¥æ’åº å¯¹ç«–ç€çš„æ•°ç»„è¿›è¡Œæ’åº 1 5 3 2 7 45 75 4 4 87 ç¬¬äºŒæ¬¡åˆ†ç»„ (æ­¥é•¿ä¸º 2) æ’åºå‰çš„æ•°ç»„ä¸º {1,5,3,2,7,45,75,4,4,87}ï¼Œå› æ­¤åˆ†ç»„ä¸º 1 5 3 2 7 45 75 4 4 87 æ’å…¥æ’åº 1 2 3 4 4 5 7 45 75 87 ç¬¬ä¸‰æ¬¡åˆ†ç»„ ï¼ˆæ­¥é•¿ä¸º1ï¼‰ æ­¥é•¿ä¸º1 ç›¸å½“äºæ’å…¥æ’åº ç›´æ¥æ’åºå³å¯ 123456789101112131415161718192021222324252627package sort// shell æ’åºæ˜¯ä¸€ä¸ªæŒ‰ç…§æ­¥é•¿çš„æ’åº// å…¶æœ¬è´¨æ˜¯ä¸€ä¸ªä¼˜åŒ–äº†æ­¥é•¿çš„æ’å…¥æ’åºfunc shellSort(nums []int) { if nums == nil || len(nums) == 0 { return } step := len(nums) / 2 // æ­¥é•¿ä¸åœçš„ç¼©çŸ­ ç›´åˆ°æœ€åæˆä¸ºæ’å…¥æ’åºï¼ˆä½†æ˜¯æ’å…¥æ’åºè¿™ä¸ªæ—¶å€™å·²ç»åŸºæœ¬æœ‰åº æ‰€ä»¥è·Ÿå®Œå…¨ä¹±åºçš„ç›¸æ¯” ä¼šæœ‰æ¯”è¾ƒå¤§çš„æ€§èƒ½æå‡ï¼‰ for step &gt;= 1 { // æ’å…¥æ’åº for i := step; i &lt; len(nums); i++ { exchange := nums[i] j := i - step // å°† i ä½ç½®çš„æ•° æ’å…¥åˆ° ä»¥ step ä¸ºæ­¥é•¿çš„æ•°ç»„ä¸­é—´ for ; j &gt;= 0 &amp;&amp; exchange &lt; nums[j]; j -= step { nums[j + step] = nums[j] } // ä¸Šé¢å·²ç»æŠŠæ•°æ®è¿ç§»å®Œæ¯• åªéœ€è¦åœ¨ j+step å³ç»“æŸè¿ç§»çš„ä½ç½® æŠŠéœ€è¦æ’å…¥çš„æ•°æ®æ’å…¥å³å¯ nums[j + step] = exchange } step /= 2 }} å½’å¹¶æ’åº1234567891011121314151617181920212223242526272829303132333435363738394041424344package sortfunc mergeSort(nums []int, i, j int) { if i &gt;= j { return } mid := (i + j) / 2 mergeSort(nums, i, mid) mergeSort(nums, mid+1, j) // è¿™ä¸€æ­¥ i -&gt; mid mid + 1 -&gt; j å·²ç»æ˜¯æœ‰åºçš„äº† merge(nums, i, mid, j)}func merge(nums []int, i, mid, j int) { tmp, index := make([]int, j-i+1), 0 iStart, jStart := i, mid+1 for iStart &lt;= mid &amp;&amp; jStart &lt;= j { if nums[iStart] &gt; nums[jStart] { tmp[index] = nums[jStart] jStart++ } else { tmp[index] = nums[iStart] iStart++ } index++ } for iStart &lt;= mid { tmp[index] = nums[iStart] index++ iStart++ } for jStart &lt;= j { tmp[index] = nums[jStart] index++ jStart++ } for m, n := 0, i; m &lt; len(tmp); m, n = m+1, n+1 { nums[n] = tmp[m] }} é“¾è¡¨çš„å½’å¹¶æ’åºå…¶å®æ€æƒ³è·Ÿæ™®é€šçš„å½’å¹¶æ’åºåŸºæœ¬ä¸€æ ·ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ã€‚å½’å¹¶åˆ†é“¾è¡¨çš„æ—¶å€™ï¼Œè¦ç›´æ¥æˆªæ–­é“¾è¡¨ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func sortList(head *ListNode) *ListNode { return mergeSort(head)}func mergeSort(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } mid := divideList(head) return mergeTwoListNode(mergeSort(head), mergeSort(mid))}func mergeTwoListNode(left, right *ListNode) *ListNode { res := new(ListNode) mov := res for left != nil &amp;&amp; right != nil { if left.Val &gt; right.Val { mov.Next = right right = right.Next } else { mov.Next = left left = left.Next } mov = mov.Next } if left != nil { mov.Next = left } if right != nil { mov.Next = right } return res.Next}// divideList ä¼šæŠŠ list åˆ†ä¸ºä¸¤ä¸ª list// ä¼šæˆªæ–­åŸæ¥çš„ nodefunc divideList(node *ListNode) *ListNode { if node == nil || node.Next == nil { return node } fast := node.Next for fast != nil &amp;&amp; fast.Next != nil { fast = fast.Next.Next node = node.Next } mid := node.Next node.Next = nil return mid} å¿«é€Ÿæ’åº12345678910111213141516171819202122232425262728293031323334353637383940414243444546package sortfunc QuickSort(nums []int, i, j int) { if i &gt;= j { return } p := partition(nums, i, j) QuickSort(nums, i, p-1) QuickSort(nums, p+1, j)}func partition(nums []int, start, end int) int { base := nums[start] i, j := start, end+1 for true { i++ for i &lt; len(nums) &amp;&amp; nums[i] &lt; base { i++ } j-- for j &gt;= 0 &amp;&amp; nums[j] &gt; base { j-- } if i &gt;= j { break } swap(nums, i, j) } swap(nums, start, j) return j}func swap(nums []int, i, j int) { if nums[i] == nums[j] { return } nums[i] = nums[i] ^ nums[j] nums[j] = nums[i] ^ nums[j] nums[i] = nums[i] ^ nums[j]} å †æ’åº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package sortfunc defaultCompare(a, b int) bool { return a &gt; b}// Heap æ ¹æ®è¾“å…¥çš„ compare æ„å»ºä¸åŒçš„å †// é»˜è®¤å°é¡¶å † -&gt; ä»å¤§åˆ°å°æ’åˆ—type Heap struct { nums []int compare func(a, b int) bool}// shiftDown ç§»åŠ¨é¡¶å±‚çš„å‘ä¸‹func (h *Heap) shiftDown(k, n int) { for 2*k+1 &lt;= n { j := 2*k + 1 // æ³¨æ„è¿™ä¸ªåœ°æ–¹ å¤§é¡¶å †çš„æ—¶å€™ å› ä¸ºéœ€è¦æŠŠå°çš„ä¸œè¥¿å¾€ä¸‹æ²‰ æ‰€ä»¥éœ€è¦é€‰æ‹©çš„æ˜¯ å­èŠ‚ç‚¹ä¸­ çš„è¾ƒå¤§å€¼ // å°é¡¶å †çš„æ—¶å€™ ç”±äºéœ€è¦æŠŠå¤§çš„ä¸œè¥¿å¾€ä¸‹æ²‰ æ‰€ä»¥éœ€è¦é€‰å–çš„æ˜¯è¾ƒå°å€¼ ï¼ˆå› ä¸ºæ¯”è¾ƒå°å€¼å° è¿™ä¸ªèŠ‚ç‚¹ä¸€å®šæ¯”ä¸¤ä¸ªèŠ‚ç‚¹éƒ½å°ï¼‰ if j+1 &lt;= n &amp;&amp; h.compare(h.nums[j],h.nums[j+1]) { j++ } if h.compare(h.nums[j], h.nums[k]) { break } swap(h.nums, k, j) k = j }}// popUp æœ€ä¸‹é¢çš„æµ®åŠ¨åˆ°æœ€ä¸Šé¢func (h *Heap) popUp(k int) { for k &gt;= 0 { var father int if k%2 == 1 { father = k / 2 } else { father = k/2 - 1 } if h.compare(h.nums[k], h.nums[father]) { break } swap(h.nums, father, k) k = father }}func NewHeap(nums []int) *Heap { return &amp;Heap{nums: nums, compare: defaultCompare}}func NewHeapWithCompare(nums []int, compare func(a, b int) bool) *Heap { return &amp;Heap{nums: nums, compare: compare}}func (h *Heap) Sort() { n := len(h.nums) - 1 // é¦–å…ˆå°†è¾“å…¥æ„é€ æˆå † for i := n / 2; i &gt;= 0; i-- { h.shiftDown(i, n) } // è¿™æ ·æ’åºæ˜¯å§æœ€å°çš„æ’åœ¨åé¢ for n &gt;= 0 { swap(h.nums, 0, n) n-- h.shiftDown(0, n) }}func swap(nums []int, i, j int) { if nums[i] == nums[j] { return } nums[i] = nums[i] ^ nums[j] nums[j] = nums[i] ^ nums[j] nums[i] = nums[i] ^ nums[j]} åŸºæ•°æ’åºåŸºæ•°æ’åºçš„æ€ç»´å¾ˆç®€å•ï¼Œå°±æ˜¯æ ¹æ®æ•°å­—çš„æ¯ä¸€ä½æ¥æ’åº é¦–å…ˆæ’åºä¸ªä½ï¼Œæ ¹æ®ä¸ªä½æ•°å­— åˆ†åˆ«æ”¾åˆ° ç¼–å· 0-9 çš„æ¡¶é‡Œé¢ ç„¶åå†æ’åºåä½ï¼Œæœ€åç›´åˆ°æœ€å¤§çš„æ•°å­—ä¹Ÿä¸º 0 å³å¯åœæ­¢ 1234567891011121314151617181920212223242526272829303132333435363738394041424344func maximumGap(nums []int) int { if len(nums) &lt; 2 { return 0 } biggest := nums[0] for _, num := range nums { biggest = max(biggest, num) } // åŸºæ•°æ’åºçš„æ¡¶ åˆ†ä¸º 0 - 9 lists := make([][]int, 10) base := 1 for biggest &gt; 0 { // æ¯æ¬¡å¾ªç¯å‰éƒ½é‡ç½® for i := 0; i &lt; 10; i++ { lists[i] = make([]int, 0) } // æ’åºæ•°ç»„ for _, num := range nums { i := num / base % 10 lists[i] = append(lists[i], num) } // æ ¹æ®æ¯è½®çš„é¡ºåº é‡æ–°èµ‹å€¼ nums æ•°ç»„ for i, index := 0, 0; i &lt; 10; i++ { for j := 0; j &lt; len(lists[i]); j++ { nums[index] = lists[i][j] index++ } } biggest /= 10 base *= 10 } res := 0 for i := 0; i &lt; len(nums)-1; i++ { res = max(res, nums[i+1]-nums[i]) } return res} æ¡¶æ’åºæ¡¶æ’åºä¹Ÿå¾ˆç®€å• ç›´æ¥æ ¹æ®æœ€å¤§å°å€¼åˆ†æ¡¶ ç„¶åæ ¹æ®å…¶æ•°å€¼æ”¾åˆ°ä¸åŒçš„æ¡¶é‡Œé¢ æ’åº åªéœ€è¦éå†æ¡¶çš„ ä¸‹æ ‡å³å¯ 1234567891011121314151617181920212223242526272829303132333435363738func maximumGapWithBucket(nums []int) int { if len(nums) &lt; 2 { return 0 } smallest, biggest := math.MaxInt32, math.MinInt32 for _, num := range nums { smallest = min(smallest, num) biggest = max(biggest, num) } // æ¡¶æ’åº counts := make([]int, biggest - smallest + 1) for _, num := range nums { counts[num-smallest]++ } res := 0 var pre *int for i, num := range counts { // è¡¨ç¤ºæ²¡æœ‰æ•°å­— if num == 0 { continue } if pre == nil { tmp := i pre = &amp;tmp continue } // æ¯”è¾ƒ res = max(res, i - *pre) tmp := i pre = &amp;tmp } return res}","link":"/2021/02/24/sort/"},{"title":"ç®€å•å›¾ç®—æ³•","text":"å›¾ç®—æ³•ç®€å•å®ç°äº†æ— å‘å›¾ã€æ— å‘åŠ æƒå›¾ã€æœ‰å‘å›¾ã€æœ‰å‘åŠ æƒå›¾çš„å‡ ç§ç®—æ³•ï¼ŒåŒ…æ‹¬: éå† dfs bfs åº”ç”¨ ç¯å›¾ æ‹“æ‰‘æ’åº åŒè‰²é—®é¢˜ æœ€å°ç”Ÿæˆæ ‘ prim krusal æœ€çŸ­è·¯å¾„ Dijkstra æ‹“æ‰‘æ’åºéå† bellemanFord å›¾çš„æ•°æ®ç»“æ„ä»¥ä¸‹å‡ä½¿ç”¨é‚»æ¥è¡¨æ ‡è¯† æ— å‘å›¾ æ— å‘å›¾è®¾è®¡å¾—æœ‰ç‚¹å°´å°¬ å…¶å®æ²¡å¿…è¦ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class UndirectedGraph&lt;T&gt; implements Graph&lt;T&gt; { public HashMap&lt;T, UndirectedNode&lt;T&gt;&gt; map; public UndirectedGraph() { this.map = new HashMap&lt;&gt;(); } public Set&lt;T&gt; keys() { return map.keySet(); } // æ— å‘å›¾ ä¸¤ééƒ½è¦åŠ  public void addEdge(T from, T to) { if (!map.containsKey(from)) { map.put(from, new UndirectedNode&lt;&gt;(to)); } UndirectedNode&lt;T&gt; temp = map.get(from); // è¯´æ˜åŠ å…¥äº†é‡å¤è¾¹ if (!temp.addNode(to)) return; if (!map.containsKey(to)) { map.put(to, new UndirectedNode&lt;&gt;(from)); } UndirectedNode&lt;T&gt; tempTo = map.get(to); tempTo.addNode(from); } public Node&lt;T&gt; adjacent(T from) { return this.map.getOrDefault(from, null); }}public class UndirectedNode&lt;T&gt; implements Node&lt;T&gt; { public T to; public UndirectedNode&lt;T&gt; next; public UndirectedNode(T to) { this.to = to; this.next = null; } /** * * @param to * @return boolean è¡¨ç¤ºæ˜¯å¦åŠ å…¥æˆåŠŸ */ public boolean addNode(T to) { // åŠ å…¥ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™çš„åˆ¤æ–­ if (this.to == to) return true; UndirectedNode&lt;T&gt; temp = this.next; // åŠ å…¥ç¬¬äºŒä¸ªèŠ‚ç‚¹æ—¶çš„åˆ¤æ–­ if (temp == null) { this.next = new UndirectedNode&lt;&gt;(to); return true; } while (temp.next != null) { if (temp.to == this.to) return false; temp = temp.next; } temp.next = new UndirectedNode&lt;&gt;(to); return true; }} æœ‰å‘å›¾ 12345678910111213141516171819202122232425262728293031323334353637public class DirectedGraph { public int getCapacity() { return capacity; } private int capacity; private List&lt;LinkedList&lt;Integer&gt;&gt; nodes; public DirectedGraph(int capacity) { this.capacity = capacity; this.nodes = new ArrayList&lt;&gt;(capacity); for (int i = 0; i &lt; capacity; i++) { nodes.add(new LinkedList&lt;&gt;()); } } public LinkedList&lt;Integer&gt; adj(int node) { return this.nodes.get(node); } public void addEdge(int from, int to) { this.nodes.get(from).add(to); } public DirectedGraph reverse() { DirectedGraph reversed = new DirectedGraph(this.capacity); for (int from = 0; from &lt; this.capacity; from++) { for (Integer to : adj(from)) { if (to != null) { reversed.addEdge(to, from); } } } return reversed; }} åŠ æƒæ— å‘å›¾ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class UndirectedWeightGraph { public int getCapacity() { return capacity; } private int capacity; // é‚»æ¥è¡¨ private List&lt;LinkedList&lt;Edge&gt;&gt; nodes; public UndirectedWeightGraph(int capacity) { this.capacity = capacity; this.nodes = new ArrayList&lt;&gt;(capacity); for (int i = 0; i &lt; capacity; i++) { this.nodes.add(new LinkedList&lt;&gt;()); } } public LinkedList&lt;Edge&gt; adj(int node) { return this.nodes.get(node); } public void addEdge(int from, int to, int weight) { Edge edge = new Edge(from, to, weight); this.nodes.get(from).add(edge); this.nodes.get(to).add(edge); }}public class Edge { public int from; public int to; public int weight; public Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } // æ ¹æ®ä¼ å…¥çš„å€¼ è¿”å›ä¸åŒçš„ from to public int other(int in) { // æ ¹æ®ä¼ å…¥çš„ç«¯ç‚¹ æ‰¾åˆ°é“¾æ¥çš„å¦å¤–ä¸€ä¸ªæ–­ç‚¹ if (in == from) { return to; } return from; } @Override public String toString() { return &quot;Edge{&quot; + &quot;from=&quot; + from + &quot;, to=&quot; + to + &quot;, weight=&quot; + weight + '}'; }} åŠ æƒæœ‰å‘å›¾ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class Edge { int from, to; int weight; public Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } public int getFrom() { return from; } public void setFrom(int from) { this.from = from; } public int getTo() { return to; } public void setTo(int to) { this.to = to; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } @Override public String toString() { return &quot;Edge{&quot; + &quot;from=&quot; + from + &quot;, to=&quot; + to + &quot;, weight=&quot; + weight + '}'; }}public class DirectedWeightGraph { public int getCapacity() { return capacity; } int capacity; List&lt;List&lt;Edge&gt;&gt; nodes; public DirectedWeightGraph(int capacity) { this.capacity = capacity; this.nodes = new ArrayList&lt;&gt;(this.capacity); for (int i = 0; i &lt; capacity; i++) { this.nodes.add(new LinkedList&lt;&gt;()); } } // æœ‰å‘å›¾åªç”¨åŠ å…¥ä¸€é public void addEdge(int from, int to, int weight) { this.nodes.get(from).add(new Edge(from, to, weight)); } public void addEdge(Edge edge) { this.nodes.get(edge.from).add(new Edge(edge.from, edge.to, edge.weight)); } public List&lt;Edge&gt; adj(int node) { return this.nodes.get(node); } // è¿”å›æ‰€æœ‰çš„è¾¹ public List&lt;Edge&gt; edges() { List&lt;Edge&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) { res.addAll(this.nodes.get(i)); } return res; }} å›¾çš„éå†æ–¹æ³•ä»¥æ— çº¿å›¾ä¸ºä¾‹ï¼Œæœ‰å‘å›¾å’Œæ— å‘å›¾çš„éå†åŸºæœ¬ä¸€æ · DFS DFS å³ä½¿ç”¨æ ˆçš„æ€æƒ³ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DFS { public static &lt;T&gt; void DFSWithRecursion(Graph&lt;T&gt; graph) { Set&lt;T&gt; memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!memo.contains(start)) DFSWithRecursion(graph, start, memo); } } public static &lt;T&gt; void DFSWithoutRecursion(Graph&lt;T&gt; graph) { Set&lt;T&gt; memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!memo.contains(start)) DFSWithOutRecursion(graph, start, memo); } } public static &lt;T&gt; void DFSWithRecursion(Graph&lt;T&gt; graph, T start, Set&lt;T&gt; memo) { System.out.println(start); UndirectedNode&lt;T&gt; node = (UndirectedNode&lt;T&gt;) graph.adjacent(start); memo.add(start); while (node != null) { if (!memo.contains(node.to)) DFS.DFSWithRecursion(graph, node.to, memo); node = node.next; } } public static &lt;T&gt; void DFSWithOutRecursion(Graph&lt;T&gt; graph, T start, Set&lt;T&gt; memo) { LinkedList&lt;T&gt; stack = new LinkedList&lt;&gt;(); stack.add(start); memo.add(start); while (stack.size() != 0) { T top = stack.removeLast(); System.out.println(top); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) graph.adjacent(top); while (temp != null) { if (!memo.contains(temp.to)) { stack.add(temp.to); memo.add(temp.to); } temp = temp.next; } } }} BFS bfs ä½¿ç”¨é˜Ÿåˆ—çš„æ€æƒ³ 12345678910111213141516171819202122232425262728public class BFS { public static &lt;T&gt; void BFS(Graph&lt;T&gt; graph) { Set&lt;T&gt; memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!memo.contains(start)) BFS(graph, start, memo); } } public static &lt;T&gt; void BFS(Graph&lt;T&gt; graph, T start, Set&lt;T&gt; memo) { LinkedList&lt;T&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); memo.add(start); while (!queue.isEmpty()) { T first = queue.removeFirst(); System.out.println(first); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) graph.adjacent(first); while (temp != null) { if (!memo.contains(temp.to)) { queue.add(temp.to); memo.add(temp.to); } temp = temp.next; } } }} å›¾éå†æ–¹æ³•çš„åº”ç”¨æ— å‘å›¾è¿é€šåˆ†é‡12345678910111213141516171819202122232425262728293031323334353637// è¿é€šåˆ†é‡public class Connected&lt;T&gt; { // å¦‚æœè¿ä¸ªç«¯ç‚¹å±äºä¸€ä¸ªè¿é€šåˆ†é‡ // ä»–ä»¬çš„idåº”è¯¥æ˜¯ä¸€æ ·çš„ public HashMap&lt;T, Integer&gt; ids; public int count = 0; public Graph&lt;T&gt; graph; public Set&lt;T&gt; memo; public Connected(Graph&lt;T&gt; graph) { this.ids = new HashMap&lt;&gt;(); this.graph = graph; this.memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!this.memo.contains(start)) { dfs(start); count++; } } } public void dfs(T start) { this.memo.add(start); ids.put(start, this.count); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) this.graph.adjacent(start); while (temp != null) { if (!memo.contains(temp.to)) dfs(temp.to); temp = temp.next; } } public boolean connected(T from, T to) { return ids.get(from).equals(ids.get(to)); }} æˆç¯æ£€æµ‹1234567891011121314151617181920212223242526272829303132public class CheckCycle&lt;T&gt; { // memo è®°å½•åœ¨dfsçš„è¿‡ç¨‹ä¸­çš„èŠ‚ç‚¹ public Set&lt;T&gt; memo; public Graph&lt;T&gt; graph; public boolean hasCycle = false; public CheckCycle(Graph&lt;T&gt; graph) { this.graph = graph; this.memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!this.memo.contains(start)) { dfs(start, start); } } } public void dfs(T start, T parent) { memo.add(start); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) graph.adjacent(start); while (temp != null) { if (!memo.contains(temp.to)) dfs(temp.to, start); // å› ä¸ºæ˜¯æ— å‘å›¾ å› æ­¤åœ¨è®¿é—®çš„æ—¶å€™ ä¼šåœ¨å­èŠ‚ç‚¹ä¸Š é‡æ–°è®¿é—®çˆ¶èŠ‚ç‚¹è¿‡æ¥çš„é‚£æ¡è¾¹ å› æ­¤è¿™æ ·è®°å½•çˆ¶èŠ‚ç‚¹å³å¯ else if(temp.to != parent) hasCycle = true; temp = temp.next; } }} æ‹“æ‰‘æ’åºæ‹“æ‰‘æ’åºå¯¹äºæ’é˜Ÿã€è¯¾ç¨‹å®‰æ’ä¹‹ç±»çš„æœ‰å¸®åŠ©ï¼Œå…¶åŸºäºæœ‰å‘å›¾å®ç° é¦–å…ˆè¦åšçš„å°±æ˜¯æœ‰å‘å›¾æˆç¯æ£€æµ‹ï¼Œå› æ­¤æˆç¯æ˜¯æ²¡æœ‰ æ‹“æ‰‘æ’åº çš„ æœ‰å‘å›¾æˆç¯æ£€æµ‹ 1234567891011121314151617181920212223public void DFS(DirectedGraph g) { boolean[] memo = new boolean[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { if (!memo[i]) { DFSRecursion(g, i, memo, new boolean[g.getCapacity()]); } } }private void DFSRecursion(DirectedGraph g, int start, boolean[] memo, boolean[] marked) { memo[start] = true; System.out.printf(&quot;%s &quot;, start); marked[start] = true; for (int i : g.adj(start)) { if (!marked[i]) { DFSRecursion(g, i, memo, marked); } else { // å·²ç»æˆç¯ this.cycle = true; } } marked[start] = false;} æ‹“æ‰‘æ’åº æœ‰ä¸¤ç§æ–¹æ³• é€†åç»­æ’åˆ—ã€‚å› ä¸ºè¦æ‰¾åˆ° v-&gt;w è¿™ç§æ‹“æ‰‘ç»“æœï¼Œé‚£ä¹ˆåœ¨è®¿é—®å®Œ V ä¹‹å è®¿é—® W å³å…¶è¿æ¥èŠ‚ç‚¹ï¼Œç”¨ stack æ¥ä¿å­˜è®¿é—®é¡ºåºï¼Œå†å¼¹å‡ºæ ˆ å°±å¯ä»¥å¾—åˆ° v -&gt; w çš„é¡ºåº 12345678910111213141516171819202122232425262728public static List&lt;Integer&gt; topologySortWithRecursion(DirectedGraph g) { // ä½œä¸ºä¸€ä¸ªæ ˆ List&lt;Integer&gt; stack = new ArrayList&lt;&gt;(); boolean[] memo = new boolean[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { if (!memo[i]) { // æ ¹æ®ä¸€ä¸ªå‡ºå‘ç‚¹ æ‰¾åˆ°å…¶ æ‹“æ‰‘æ’åº topologySortRecursion(g, stack, i, memo); } } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // è¾“å‡º stack for (int i = stack.size() - 1; i &gt;= 0; i--) { res.add(stack.get(i)); } return res;}private static void topologySortRecursion(DirectedGraph g, List&lt;Integer&gt; res, int start, boolean[] memo) { memo[start] = true; for (int adj : g.adj(start)) { if (!memo[adj]) { topologySortRecursion(g, res, adj, memo); } } res.add(start);} éå†å…¥åº¦ä¸º 0 çš„ç‚¹ï¼Œå› ä¸ºèƒ½å¤Ÿä½œä¸ºå¼€å§‹èŠ‚ç‚¹çš„ç‚¹ï¼Œä¸€å®šå…¥åº¦ä¸º 0ï¼Œé‚£ä¹ˆä¸åœçš„éå†ï¼Œåˆ é™¤è¾¹ï¼Œç»´æŠ¤ä¸€ä¸ªå…¥åº¦ä¸º 0 çš„ç‚¹çš„ collection æ—¢å¯æ‰¾åˆ°è®¿é—®é¡ºåº 123456789101112131415161718192021222324252627282930313233343536// 2. ä¸åœåœ°éå†å…¥åº¦ä¸º 0 çš„ç‚¹ ç„¶ååˆ é™¤public static List&lt;Integer&gt; topologySortIteration(DirectedGraph g) { int[] inDegree = new int[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { for (int adj : g.adj(i)) { inDegree[adj] += 1; } } Deque&lt;Integer&gt; inDegreeEqualsZero = new LinkedList&lt;&gt;(); // æ‰¾åˆ°ä¸º 0 çš„ç‚¹ for (int i = 0; i &lt; g.getCapacity(); i++) { if (inDegree[i] == 0) { inDegreeEqualsZero.offer(i); } } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while (!inDegreeEqualsZero.isEmpty()) { int top = inDegreeEqualsZero.poll(); res.add(top); for (int adj : g.adj(top)) { inDegree[adj] -= 1; if (inDegree[adj] == 0) { inDegreeEqualsZero.offer(adj); } } } return res;} æœ‰å‘å›¾çš„å¼ºè¿é€šåˆ†é‡12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class DirectedGraphStrongConnected { public static List&lt;Integer&gt; KosarajuConnected(DirectedGraph g) { // ä¿å­˜çš„å¼ºè¿é€šåˆ†é‡çš„ id // ids[i] è¡¨ç¤º i èŠ‚ç‚¹å±äºå“ªä¸ª å¼ºè¿é€šåˆ†é‡ id List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(g.getCapacity()); for (int i = 0; i &lt; g.getCapacity(); i++) { ids.add(-1); } // éå†çš„æ—¶å€™çš„å¼ºè¿é€šåˆ†é‡ id int count = 0; // å…ˆå¾—åˆ° åå›¾ çš„æ‹“æ‰‘æ’åº List&lt;Integer&gt; order = TopologySort.topologySortWithRecursion(g.reverse()); boolean[] memo = new boolean[g.getCapacity()]; for (int node : order) { if (!memo[node]) { recursionDFS(g, node, count, memo, ids); count++; } } // æ ¹æ®æ‹“æ‰‘æ’åº DFS return ids; } private static void recursionDFS(DirectedGraph g, int start, int count, boolean[] memo, List&lt;Integer&gt; ids) { memo[start] = true; ids.set(start, count); for (int adj : g.adj(start)) { if (!memo[adj]) { recursionDFS(g, adj, count, memo, ids); } } } public static void main(String[] args) { DirectedGraph g = new DirectedGraph(13); g.addEdge(1, 2); g.addEdge(3, 1); g.addEdge(6, 3); g.addEdge(4, 7); g.addEdge(2, 0); g.addEdge(11, 8); g.addEdge(10, 1); g.addEdge(0, 7); g.addEdge(0, 6); System.out.println(KosarajuConnected(g)); }} æœ€å°ç”Ÿæˆæ ‘æœ€å°ç”Ÿæˆæ ‘éƒ½æ˜¯åŸºäºè´ªå¿ƒçš„æ€è·¯å’Œæƒ³æ³•ã€‚ç”±äºéœ€è¦ç”Ÿæˆçš„æ— å‘åŠ æƒå›¾çš„æ ‘ï¼ˆv-1 æ¡è¾¹ï¼‰çš„è·¯å¾„å’Œæœ€çŸ­ï¼Œæ‰€ä»¥å®é™…ä¸Šæ˜¯ä¸€ä¸ªä¸æ–­éå†æœ€çŸ­è·¯å¾„è¾¹çš„è´ªå¿ƒç­–ç•¥ã€‚ prim ç®—æ³• lazy ç‰ˆæœ¬ åœ¨éå†æ‰€æœ‰çš„è¾¹çš„æ—¶å€™ï¼Œä¸ä¸»åŠ¨åˆ é™¤é˜Ÿåˆ—ä¸­çš„æ— æ•ˆè¾¹ï¼Œæ‰€ä»¥ä¸º lazy å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MinTree { // æœ€å°ç”Ÿæˆæ ‘ æŒ‡çš„æ˜¯æ— å‘å›¾ä¸­ï¼Œèƒ½å¤Ÿç”Ÿæˆçš„è¾¹çš„æƒé‡æ€»å’Œæœ€å°çš„æ ‘ // prime çš„æœ€å°ç”Ÿæˆæ ‘å®é™…ä¸Šæ˜¯ä¸€ä¸ªè´ªå¿ƒç®—æ³• // é€šè¿‡ PriorityQueue ä¸åœåœ°ç”Ÿæˆæƒé‡æœ€å°çš„è¾¹ // lazyPrim æŒ‡çš„æ˜¯åœ¨éå†çš„è¿‡ç¨‹ä¸­ pq ä¸­çš„è¾¹ æ˜¯è®¿é—®æ—¶æ‰å¤±æ•ˆ public static Deque&lt;Edge&gt; lazyPrim(UndirectedWeightGraph g) { // å­˜å‚¨æ‰€æœ‰çš„è¾¹ PriorityQueue&lt;Edge&gt; minQueue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a.weight)); // ä¿å­˜è¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹ boolean[] marked = new boolean[g.getCapacity()]; // ä¿å­˜è¿”å›çš„ç»“æœ Deque&lt;Edge&gt; res = new LinkedList&lt;&gt;(); // ä¿è¯ g æ•´ä½“æ˜¯è¿é€šçš„ // éšæ„é€‰å–ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºå¼€å§‹èŠ‚ç‚¹ addEdgeToPQ(marked, minQueue, 0, g); while (!minQueue.isEmpty()) { // æŠ“åˆ°çš„ä¸€å®šæ˜¯æœ€çŸ­çš„è·¯å¾„ Edge top = minQueue.poll(); int from = top.from, to = top.to; // from to ä¸¤ä¸ªæ–­ç‚¹éƒ½å·²ç»è®¿é—®è¿‡ è¯´æ˜åœ¨ä¸¤ä¸ªç«¯ç‚¹ä¹‹é—´å·²ç»æ‰¾åˆ°æœ€çŸ­çš„äº† if (marked[from] &amp;&amp; marked[to]) continue; // å¦åˆ™å°±æ‰¾åˆ°æœ€çŸ­çš„ res.add(top); // å°†ä¸¤ä¸ªç«¯ç‚¹çš„ edge åŠ å…¥åˆ° queue ä¸­ if (!marked[from]) addEdgeToPQ(marked, minQueue, from, g); if (!marked[to]) addEdgeToPQ(marked, minQueue, to, g); } return res; } public static void addEdgeToPQ(boolean[] marked, PriorityQueue&lt;Edge&gt; minQueue, int start, UndirectedWeightGraph g) { marked[start] = true; for (Edge e : g.adj(start)) { if (!marked[e.other(start)]) { // å¦å¤–ä¸€ä¸ªæ–­ç‚¹æ²¡æœ‰è®¿é—®è¿‡ minQueue.add(e); } } }} åŠæ—¶ç‰ˆæœ¬ åœ¨éå†çš„æ—¶å€™ï¼Œä¸å†ä»¥è¾¹ä½œä¸º ä¼˜å…ˆé˜Ÿåˆ— çš„éå†å¯¹è±¡ï¼Œè€Œæ˜¯é‡‡ç”¨å¯¹ç‚¹è¿›è¡Œéå†ï¼Œåœ¨éå†çš„å›¾ä¸­ï¼Œä¸åœçš„æ›´æ–° ä¼˜å…ˆé˜Ÿåˆ— ä¸­ç‚¹å¯¹åº”çš„æœ€çŸ­è¾¹ï¼Œä»¥æ­¤å‡å°‘è°ƒæ•´å †çš„æ—¶é—´ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private static class Pair { int node; int weight; public Pair(int node, int weight) { this.node = node; this.weight = weight; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Pair pair = (Pair) o; return node == pair.node; } @Override public int hashCode() { return Objects.hash(node); }}// å®æ—¶çš„ prim ç®—æ³• ä¸ lazy ä¸åŒçš„æ˜¯// åœ¨ v è¿™ä¸ªèŠ‚ç‚¹ åŠ å…¥ pq çš„æ—¶å€™ å…¶ä½™çš„éæ ‘é˜¶æ®µ åº”è¯¥åªåŠ å…¥ åˆ° æ ‘ä¸­æœ€çŸ­çš„è¾¹// ç›¸å¯¹æ¥è¯´ å¯ä»¥å‡å°‘æ—¶é—´ å› ä¸º ä¸€ä¸ªå›¾çš„è¯ ä¸€èˆ¬æ˜¯ è¾¹æ¯”ç‚¹å¤š// è¿™ä¸ªç®—æ³•åªç”¨åœ¨ ä¼˜å…ˆé˜Ÿåˆ—ä¸­ä¿å­˜ç‚¹public static Edge[] prim(UndirectedWeightGraph g) { // ä»ç„¶ä½¿ç”¨ä¸€ä¸ª pq ä¿å­˜æœ€çŸ­çš„ç‚¹ ï¼ˆåˆ°è¿™ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»ï¼‰ PriorityQueue&lt;Pair&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(e -&gt; e.weight)); // edge[i] ä¿å­˜ i åˆ° edge.to çš„æœ€çŸ­è¾¹é•¿ Edge[] edgeTo = new Edge[g.getCapacity()]; boolean[] marked = new boolean[g.getCapacity()]; pq.add(new Pair(0, 0)); while (!pq.isEmpty()) { Pair top = pq.poll(); inTimeAddEdgeToPQ(g, top.node, marked, edgeTo, pq); } return edgeTo;}private static void inTimeAddEdgeToPQ(UndirectedWeightGraph g, int node, boolean[] marked, Edge[] edgeTo, PriorityQueue&lt;Pair&gt; pq) { marked[node] = true; for (Edge adj : g.adj(node)) { int otherNode = adj.other(node); // å·²ç»æ‰¾åˆ°äº† if (marked[otherNode]) continue; // è¯´æ˜è¿˜æ²¡æœ‰æ‰¾åˆ°åˆ°è¿™ä¸ªç‚¹çš„æœ€çŸ­è·ç¦» æˆ–è€… // ç°åœ¨çš„ edge çš„ weight æ›´çŸ­ æ›´æ–° if (edgeTo[otherNode] == null || adj.weight &lt; edgeTo[otherNode].weight) { edgeTo[otherNode] = adj; Pair p = new Pair(otherNode, adj.weight); for (Pair tmp : pq) { // remove æ‰å·²ç»å¤±æ•ˆçš„è¾¹ if (tmp.node == otherNode) { pq.remove(tmp); } break; } pq.add(p); } }} krusal ç®—æ³• ä¸ lazy prim ç®—æ³•ç±»ä¼¼ï¼Œå…¶ä¹Ÿæ˜¯éå†æ‰€æœ‰çš„è¾¹å¹¶åŠ å…¥åˆ° ä¼˜å…ˆé˜Ÿåˆ— ä¸­ï¼Œä½†æ˜¯éå†çš„æ—¶å€™é‡‡ç”¨çš„æ–¹æ³•æ˜¯é€šè¿‡ å¹¶æŸ¥é›† åˆ¤æ–­ç‚¹æ˜¯å¦å·²ç»æ‰¾åˆ°äº†æœ€çŸ­çš„è·ç¦»ï¼Œåœ¨æ‰¾åˆ°æœ€çŸ­è·ç¦»åï¼Œä¼šåˆ¤æ–­ä¸¤ä¸ªç‚¹ç›¸è¿ï¼ŒçŸ¥é“ç»“æœè¾¹é›†åˆå¤§å°æ‰©å±•åˆ° v-1ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MinTreeKruskal { // ä½¿ç”¨ å¹¶æŸ¥é›† æ¥åˆ¤æ–­åŠ å…¥çš„è¾¹æ˜¯å¦æˆç¯ public static List&lt;Edge&gt; kruskalUseUnion(UndirectedWeightGraph g) { List&lt;Edge&gt; res = new ArrayList&lt;&gt;(); Union uf = new Union(g.getCapacity()); PriorityQueue&lt;Edge&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt((e) -&gt; e.weight)); pq.addAll(g.getEdges()); // æœ€å°ç”Ÿæˆæ ‘ åªèƒ½æœ‰ V - 1 ä¸ª ï¼ˆV ä¸º node æ•°ï¼‰ while (!pq.isEmpty() &amp;&amp; (res.size() &lt; g.getCapacity() - 1)) { Edge e = pq.poll(); assert e != null; int from = e.from, to = e.to; // ä¹‹å‰å·²ç»è¿æ¥äº†æœ€çŸ­çš„è¾¹ æ‰€ä»¥ä¸ç”¨å†è¿æ¥äº† if (uf.connected(from, to)) continue; // è¿æ¥ä¸¤æ¡è¾¹ uf.union(from, to); res.add(e); } return res; }}public class Union { // å¹¶æŸ¥é›† int[] parents; public Union(int capacity) { this.parents = new int[capacity]; for (int i = 0; i &lt; capacity; i++) { // åˆå§‹åŒ– this.parents[i] = i; } } public void union(int n1, int n2) { int rootOfN1 = find(n1); int rootOfN2 = find(n2); if (rootOfN1 == rootOfN2) return; // n1 root è¿æ¥åˆ° n2 root ä¸Š this.parents[rootOfN1] = rootOfN2; } // æ‰¾åˆ°è·ŸèŠ‚ç‚¹ private int find(int node) { if (this.parents[node] == node) { return node; } return find(this.parents[node]); } public boolean connected(int i, int j) { // åˆ¤æ–­ä¸¤ä¸ª root æ˜¯å¦ç›¸ç­‰ int rootOfI = find(i); int rootOfJ = find(j); return rootOfI == rootOfJ; }} æœ€çŸ­è·¯å¾„æœ€çŸ­è·¯å¾„å…¶å®è·Ÿä¸Šè¿°çš„ç®—æ³•ç±»ä¼¼ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªç±»ä¼¼è´ªå¿ƒçš„ç­–ç•¥ï¼Œä½†æ˜¯åœ¨éå†æœ€çŸ­è¾¹çš„æ—¶å€™ï¼Œæˆ–åŒæ—¶ä½¿ç”¨ relax çš„æ“ä½œï¼Œä¿éšœä¸€ä¸ªç‚¹ç»è¿‡ä¸€ä¸ªä¸­é—´ç‚¹å¯èƒ½æ¯”ç›´æ¥åˆ°ç›®æ ‡ç‚¹çš„è·ç¦»çŸ­è¿™ä¸ªé—®é¢˜ã€‚ Dijkstra ç®—æ³• åŸºæœ¬ä¸ prim ç®—æ³•ä¸€æ ·ï¼Œåªæ˜¯åŠ å…¥äº† relax çš„æ“ä½œ å…¶åªèƒ½å¤„ç†éè´Ÿçš„æœ‰å‘å›¾ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static class Pair { int node; int weight; public Pair(int node, int weight) { this.node = node; this.weight = weight; }}// dijkstra ä¸ in time çš„ prim ç®—æ³•ç±»ä¼¼// è¿™äº›æ˜¯æ‰¾åˆ°å•æºæœ€çŸ­è·¯çš„public static Edge[] dijkstraMinPath(DirectedWeightGraph g, int start) { // ä¿å­˜æœ€çŸ­è·¯å¾„çš„è¾¹ Edge[] edgeTo = new Edge[g.getCapacity()]; // ä¿å­˜æœ€çŸ­è·¯å¾„çš„é•¿åº¦ int[] distTo = new int[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { distTo[i] = Integer.MAX_VALUE; } distTo[start] = 0; PriorityQueue&lt;Pair&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt((e) -&gt; e.weight)); pq.add(new Pair(start, 0)); // æ¯æ¬¡éƒ½æ‰¾ç°åœ¨æœ€çŸ­çš„è·¯å¾„ ç„¶å relax è·¯å¾„ while (!pq.isEmpty()) { Pair min = pq.poll(); relax(g, min.node, pq, edgeTo, distTo); } return edgeTo;}// relax èŠ‚ç‚¹private static void relax(DirectedWeightGraph g, int node, PriorityQueue&lt;Pair&gt; pq, Edge[] edgeTo, int[] distTo) { for (Edge adj : g.adj(node)) { // å› ä¸º edgeTo ä¿å­˜çš„æ˜¯ä¹‹å‰éå†çš„æœ€çŸ­çš„è·¯å¾„ // æ‰€ä»¥ å¦‚æœé€šè¿‡ç°åœ¨è¿™ä¸ªç‚¹ + adj.weight çš„è·ç¦» æ¯” edgeTo çš„çŸ­ å°±éœ€è¦æ›´æ–° if (distTo[adj.to] &gt; distTo[node] + adj.weight) { edgeTo[adj.to] = adj; distTo[adj.to] = distTo[node] + adj.weight; // æ·»åŠ æ–°çš„ æˆ–è€… æ›´æ–°åŸæ¥çš„èŠ‚ç‚¹çš„æœ€å°å€¼ Pair p = new Pair(adj.to, distTo[adj.to]); // æ›´æ–° pq for (Pair tmp : pq) { if (tmp.node == adj.to) { pq.remove(tmp); } break; } pq.add(p); } }} æ‹“æ‰‘æ’åºå¤„ç†æ— ç¯å›¾ ç”±äºæ‹“æ‰‘æ’åºçš„æ€§è´¨ï¼Œæ˜¯ä»å…¥åº¦ä¸º 0 çš„ç‚¹ä¸æ–­å‘å¤–å»¶ä¼¸ï¼Œæ‰€ä»¥ï¼Œå¦‚æœæ ¹æ® æ‹“æ‰‘æ’åº çš„é¡ºåºè®¿é—®å›¾ä¸­çš„ç‚¹ï¼Œé‚£ä¹ˆåé¢çš„ç‚¹æ˜¯ä¸€å®šä¸ä¼šå†è®¿é—®å·²ç»è®¿é—®è¿‡çš„ç‚¹ï¼Œæ‰€ä»¥ä¸ä¼šå‡ºç° relaxã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// é‡‡ç”¨ dfs åšçš„ topologySort// ä¿è¯æ— ç¯public static int[] topologySort(DirectedWeightGraph g) { boolean[] marked = new boolean[g.getCapacity()]; Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; g.getCapacity(); i++) { // marked æ ‡è¯†æ ‡è®°è¿‡çš„ç‚¹ if (!marked[i]) { dfs(g, marked, i, stack); } } int[] res = new int[stack.size()]; int i = 0; while (!stack.isEmpty()) { res[i++] = stack.removeLast(); } return res;}public static void dfs(DirectedWeightGraph g, boolean[] marked, int start, Deque&lt;Integer&gt; stack) { marked[start] = true; for (Edge adj : g.adj(start)) { if (!marked[adj.to]) { dfs(g, marked, adj.to, stack); } } stack.addLast(start);}// ä½¿ç”¨æ‹“æ‰‘æ’åºçš„å•æºæœ€çŸ­è·¯ç»// åªèƒ½å¤„ç†æ— ç¯çš„æƒ…å†µ// æ‹“æ‰‘æ’åºåªèƒ½é’ˆå¯¹æ— ç¯å›¾// ç”±äº æ‹“æ‰‘æ’åºæ˜¯ä» æ— å…¥åº¦çš„ç‚¹å¼€å§‹// å¦‚æœæ‰¾æœ€çŸ­è·¯å¾„ä»è¿™å„¿å¼€å§‹çš„è¯ è¿™ä¸ªç‚¹ ä¸€å®šä¸ä¼šå†æ¬¡è¢«è®¿é—®åˆ° æ‰€ä»¥åªæ”¾æ¾ä¸€æ¬¡// åŒç† è§£å†³å•ç‚¹æ— ç¯å›¾çš„æœ€é•¿è·¯å¾„ å¯ä»¥æŠŠ weight å–è´Ÿ å†æ¥æœ€çŸ­è·¯å¾„å³å¯public static Edge[] topologyMinPath(DirectedWeightGraph g, int start) { int[] topologyPath = TopologySort.topologySort(g); Edge[] res = new Edge[g.getCapacity()]; // åˆå§‹åŒ–è·ç¦» int[] dst = new int[g.getCapacity()]; Arrays.fill(dst, Integer.MAX_VALUE); dst[start] = 0; for (int node : topologyPath) { relax(g, res, dst, node); } return res;}private static void relax(DirectedWeightGraph g, Edge[] res, int[] dst, int node) { for (Edge adj : g.adj(node)) { // å¦‚æœä¹‹å‰éå†çš„ åˆ° adj.to çš„è·ç¦» æ¯”ä» node ç»è¿‡ adj åˆ°è¾¾ adj.to çš„è·ç¦»é•¿ è¯´æ˜è¯¥æ›´æ–°äº† if (dst[adj.to] &gt; dst[node] + adj.weight) { res[adj.to] = adj; dst[adj.to] = dst[node] + adj.weight; } }} BellmanFord ç®—æ³• èƒ½è¿‡å¤„ç†è´Ÿæ•°çš„å›¾ï¼Œä½†æ˜¯ä¸èƒ½å¤„ç†è´Ÿæ•°ç¯ï¼ˆå› ä¸ºè´Ÿæ•°ç¯èƒ½å¤Ÿè¾¾åˆ°ä»»æ„çŸ­çš„è´Ÿæ•°ï¼‰ã€‚ å…¶æ ¸å¿ƒæ€æƒ³æ˜¯éå† V æ¬¡ å›¾ï¼Œè¿™æ ·ä¿éšœæ¯ä¸ªç‚¹éƒ½è¢«éå† V æ¬¡ï¼Œæ‰¾åˆ°æœ€çŸ­çš„è·¯å¾„ã€‚ ä½†æ˜¯å¯ä»¥ä¼˜åŒ–çš„ç‚¹æ˜¯ï¼Œåªæœ‰åœ¨ä¸Šæ¬¡è¢«æ›´æ”¹äº†é•¿åº¦çš„ç‚¹æ‰èƒ½åŠ å…¥é˜Ÿåˆ—ä¸­ã€‚ // è¿™ä¸ªç®—æ³•åªèƒ½å¤„ç†æ²¡æœ‰è´Ÿæƒé‡ç¯çš„æœ‰å‘å›¾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// å› ä¸ºå¸¦æœ‰è´Ÿæƒé‡ç¯çš„å›¾å¯ä»¥å¾—åˆ°ä»»æ„çŸ­çš„æƒé‡ æ˜¯æ— æ•ˆçš„public static Edge[] bellmanFordMinPath(DirectedWeightGraph g, int start) { // æ‰€ä»¥ å¦‚æœéå†æ‰€æœ‰çš„ç‚¹ åŒæ—¶ relax æ‰€æœ‰çš„ è¾¹ å°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªç»“æœ // å…¶æ•ˆç‡ä¸º o(v + e) // ä½†æ˜¯ å¯ä»¥è€ƒè™‘ä¸€ä¸ªé—®é¢˜ å°±æ˜¯åªæœ‰åœ¨ä¸Šè½®å¾ªç¯ä¸­æ›´æ–°è¿‡çš„ç‚¹ æ‰æœ‰å¯èƒ½ä½¿ è·ç¦»æ›´çŸ­ï¼Œæ‰€ä»¥ ç”¨ä¸€ä¸ª queue æ¥ä¿å­˜è¿™æ ·çš„ç‚¹ // è½¬ä¸Šè½®å¯¹ dst æ•°ç»„æœ‰è´¡çŒ®çš„ç‚¹ Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // ç»“æœ Edge[] edgeTo = new Edge[g.getCapacity()]; // è·ç¦»åˆå§‹åŒ– int[] dst = new int[g.getCapacity()]; Arrays.fill(dst, Integer.MAX_VALUE); dst[start] = 0; // å› ä¸º queue é‡Œé¢ä¸èƒ½æœ‰é‡å¤èŠ‚ç‚¹ æ‰€ä»¥ç”¨è¿™ä¸ªæ¥åˆ¤æ–­ boolean[] inQueue = new boolean[g.getCapacity()]; // æ‰§è¡Œ relax çš„æ¬¡æ•° int cost = 0; // æœ€å¼€å§‹çš„èŠ‚ç‚¹ queue.add(start); // TODO è¿™ä¸ªæ—¶å€™è¿˜è¦æ£€æŸ¥è´Ÿæƒé‡ç¯ // è¿™ä¸ªåœ°æ–¹åªéœ€è¦æ£€æŸ¥æ˜¯å¦æ˜¯æˆç¯å³å¯ while (!queue.isEmpty()) { relax(g, queue.remove(), dst, edgeTo, queue, inQueue); } return edgeTo;}// åœ¨æ”¾æ¾çš„æ—¶å€™åŒæ—¶æ›´æ–° queueprivate static void relax(DirectedWeightGraph g, int node, int[] dst, Edge[] edgeTo, Queue&lt;Integer&gt; queue, boolean[] inQueue) { for (Edge adj : g.adj(node)) { int to = adj.to; // æ›´æ–° if (dst[to] &gt; dst[node] + adj.weight) { edgeTo[to] = adj; dst[to] = dst[node] + adj.weight; if (!inQueue[node]) { inQueue[node] = true; // è¿™æœ‰è¿™è½®å·²ç»æ›´æ–°è¿‡çš„ åˆ° to çš„æ›´çŸ­è·ç¦» å…¶ä»–æ‰å¯èƒ½æ›´çŸ­ queue.add(to); } } // TODO æ£€æŸ¥è´Ÿæƒé‡ç¯ }}","link":"/2021/03/07/graph/"},{"title":"leetcode","text":"leetcode ä¾‹é¢˜è®°å½•ä¸‹ leetcode å€¼å¾—è®°å½•çš„ä¾‹é¢˜ kmp ç®—æ³•kmp ç®—æ³•çš„åŸå§‹å®ç°æ–¹æ³•åœ¨å¦ä¸€ç¯‡é‡Œé¢å·²ç»å†™è¿‡ï¼Œå®é™…ä¸Š å•è°ƒæ ˆä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II ç¤ºä¾‹ è¾“å…¥: [1,2,1] è¾“å‡º: [2,-1,2] è§£é‡Š: ç¬¬ä¸€ä¸ª 1 çš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°æ˜¯ 2ï¼› æ•°å­— 2 æ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°ï¼› ç¬¬äºŒä¸ª 1 çš„ä¸‹ä¸€ä¸ªæœ€å¤§çš„æ•°éœ€è¦å¾ªç¯æœç´¢ï¼Œç»“æœä¹Ÿæ˜¯ 2ã€‚ ç”¨å•è°ƒæ ˆæ¥ä¿å­˜ä¹‹å‰éå†è¿‡çš„è·¯å¾„ï¼Œä¹‹åè®¿é—®çš„æ•°å­—å¦‚æœæ¯”è·¯å¾„ä¸Šçš„æ•°å­—å¤§çš„è¯ï¼Œè¯´æ˜å¯¹äºæ ˆä¸­ä¿å­˜çš„è·¯å¾„ä¸Šçš„æ•°å­—ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°æ˜¯å½“å‰è®¿é—®çš„æ•°ã€‚ 12345678910111213141516171819public int[] nextGreaterElements(int[] nums) { // ä¼˜åŒ–å¾ªç¯ int n = nums.length; int[] res = new int[n]; // æ·»åŠ çš„é»˜è®¤å€¼ Arrays.fill(res, -1); // å•è°ƒæ ˆä¿å­˜ nums ä¸­çš„ä¸‹æ ‡ Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); // å› ä¸ºæ˜¯å¾ªç¯æ•°ç»„ æ‰€ä»¥éå†åˆ°æœ€åä¸€ä¸ªçš„æ—¶å€™ è¿˜è¦çœ‹å…¶å·¦ä¾§çš„ // æ‰€ä»¥ç›¸å½“äºæ˜¯ä¸¤å€é•¿åº¦ for (int i = 0; i &lt; 2 * n - 1; i++) { // stack é‡Œé¢æ”¾ç½®çš„éƒ½æ˜¯æ¯” nums[i % n] å°çš„æ•° åœ¨å…¶è¢«å¼¹å‡ºçš„æ—¶å€™ è¯´æ˜ä¹‹åç¬¬ä¸€ä¸ªæ¯”ä»–å¤§çš„æ•° å°±æ˜¯è®¿é—®çš„ nums[i % n] while (!stack.isEmpty() &amp;&amp; nums[i % n] &gt; nums[stack.peek()]) { res[stack.pop()] = nums[i % n]; } stack.push(i % n); } return res;} æ»‘åŠ¨çª—å£æœ€å°è¦†ç›–å­ä¸²æ»‘åŠ¨çª—å£ å½“å‰éå†çš„å­—ç¬¦ä¸²æ²¡æœ‰åŒ…å«æ‰€æœ‰å­—ç¬¦çš„æ—¶å€™ï¼Œå³ç§»å³æ¸¸æ ‡ ç„¶åå·¦ç§»å·¦æ¸¸æ ‡ï¼Œç›´åˆ°ä¸å†åŒ…å«è¯¥å­—ç¬¦ä¸² åœ¨ç§»åŠ¨çª—å£çš„æ—¶å€™ä¸å¬æ¯”è¾ƒå³å¯ 123456789101112131415161718192021222324252627282930313233func checkEqualMap(mapForT, window map[int32]int) bool { for k, v := range mapForT { if count, ok := window[k]; !ok || count &lt; v { return false } } return true}func minWindow(s string, t string) string { i, j := 0, 0 res := &quot;&quot; mapForT := make(map[int32]int) for _, char := range t { mapForT[char]++ } window := make(map[int32]int) for j &lt; len(s) || i &lt; j { for j &lt; len(s) &amp;&amp; !checkEqualMap(mapForT, window) { window[int32(s[j])]++ j++ } if checkEqualMap(mapForT, window) &amp;&amp; (res == &quot;&quot; || len(res) &gt; j-i) { res = s[i:j] } window[int32(s[i])]-- i++ } return res} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { // è¿”å›true è¯´æ˜é‡Œé¢å·²ç»åŒ…å«äº†ä¸€ä¸ªå®Œæ•´çš„ t å­—ç¬¦ä¸² public boolean checkMap(HashMap&lt;Character, Integer&gt; mapForT, HashMap&lt;Character, Integer&gt; mapForS) { for (Character key : mapForT.keySet()) { if (!mapForS.containsKey(key) || mapForS.get(key) &lt; mapForT.get(key)) return false; } return true; } public String minWindow(String s, String t) { // è¿™éƒ½æ˜¯ä¸å­˜åœ¨çš„ if (s == null || t == null || s.length() &lt; t.length()) return &quot;&quot;; String minStr = null; HashMap&lt;Character, Integer&gt; mapForT = new HashMap&lt;&gt;(); for (char character : t.toCharArray()) { if (!mapForT.containsKey(character)) { mapForT.put(character, 1); } else { mapForT.put(character, mapForT.get(character) + 1); } } HashMap&lt;Character, Integer&gt; mapForS = new HashMap&lt;&gt;(); for (int i = 0; i &lt; t.length(); i++) { Character character = s.charAt(i); if (!mapForS.containsKey(character)) { mapForS.put(character, 1); } else { mapForS.put(character, mapForS.get(character) + 1); } } // æ»‘åŠ¨çª—å£å¤§å° int left = 0, right = t.length() - 1; do { while (checkMap(mapForT, mapForS) &amp;&amp; right - left + 1 &gt;= t.length()) { if (minStr == null || minStr.length() &gt; right - left + 1) { minStr = s.substring(left, right + 1); } mapForS.put(s.charAt(left), mapForS.get(s.charAt(left)) - 1); left++; } right++; if (right &gt;= s.length()) continue; if (!mapForS.containsKey(s.charAt(right))) { mapForS.put(s.charAt(right), 1); } else { mapForS.put(s.charAt(right), mapForS.get(s.charAt(right)) + 1); } } while (right &lt;= s.length() - 1 &amp;&amp; right - left + 1 &gt; t.length()); return minStr == null ? &quot;&quot; : minStr; }} K ä¸ªä¸åŒæ•´æ•°çš„å­æ•°ç»„æ‰¾åˆ° A é‡Œé¢çš„è¿ç»­å­æ•°ç»„ï¼Œå…¶ä¸­å­æ•°ç»„é‡Œé¢çš„æ•°æ®çš„ distinct åªæœ‰ K ä¸ª è¿™ä¸ªé¢˜ç›®ä¸€æƒ³å°±æ˜¯æ»‘åŠ¨çª—å£ ä½†æ˜¯ å¾ˆä¸å¥½è®¡ç®— ç­‰äº K çš„æ—¶å€™ æ•°ç»„æœ‰å¤šå°‘ä¸ª ä½†æ˜¯è®¡ç®— å°äºç­‰äº K çš„æ¯”è¾ƒå¥½è®¡ç®—ï¼Œå¯ä»¥ä¾æ®ä»¥ä¸‹è§„åˆ™ ä»¥ [1,2,1,2,3] ä¸ºä¾‹ï¼Œå·¦è¾¹ç•Œå›ºå®šçš„æ—¶å€™ï¼Œæ°å¥½å­˜åœ¨ 2 ä¸ªä¸åŒæ•´æ•°çš„å­åŒºé—´ä¸º [1,2],[1,2,1],[1,2,1,2]ï¼Œæ€»æ•°ä¸º 3ã€‚å…¶å€¼ä¸ºä¸‹æ ‡ 3 - 1 + 1ï¼Œå³åŒºé—´ [1..3] çš„é•¿åº¦ã€‚ å› ä¸ºï¼Œleft, right åŒæ—¶åœˆå®šäº†ä¸€ç»„æ»¡è¶³ &lt;= k çš„é¢˜æ„çš„é•¿åº¦èŒƒå›´ é‚£ä¹ˆï¼ŒåŒ…å« left çš„å­æ•°ç»„æ•°é‡è‚¯å®šæ˜¯ right - left + 1ï¼Œå› ä¸ºç›¸å½“äºæ¯æ¬¡ç»™æ•°ç»„é‡Œé¢æ·»åŠ ä¸€ä¸ªæ•°([1,2] [1,2,1] [1,2,1,2]) æ‰€ä»¥ right æ¯” left å¤šå‡ ä¸ªæ•° å°±èƒ½å½¢æˆå‡ ä¸ªå­æ•°ç»„ 12345678910111213141516171819202122232425262728func subarraysWithKDistinct(A []int, K int) int { return atMostK(A, K) - atMostK(A, K-1)}// å› ä¸ºæ±‚è§£ æ°å¥½K ä¸å¥½å¼„ æ±‚è§£ æœ€å¤§K æ¯”è¾ƒå¥½å¼„func atMostK(A []int, K int) int { i, j := 0, 0 // ä½œä¸ºä¸€ä¸ª set ä¿å­˜çª—å£å†…çš„æ‰€æœ‰ distinct æ•°æ® window := make(map[int]int) res := 0 for j &lt; len(A) { window[A[j]]++ j++ for len(window) &gt; K { window[A[i]]-- if window[A[i]] == 0 { delete(window, A[i]) } i++ } res += j - i + 1 } return res} æœ€å¤§è¿ç»­ 1 çš„ä¸ªæ•° IIIæœ€å¤§è¿ç»­ 1 çš„ä¸ªæ•°ï¼ŒA ä¸­åªæœ‰ 0 å’Œ 1ï¼Œå…¶ä¸­å¯ä»¥å˜æ¢æœ€å¤š K ä¸ª 0 æˆä¸º 1ï¼Œé—®æœ€é•¿çš„è¿ç»­ 1 çš„é•¿åº¦ä¸ºå¤šå°‘ æ»‘åŠ¨çª—å£ï¼Œçª—å£ä¸­æœ€å¤šå«æœ‰ K ä¸ª 0 å³å¯ 123456789101112131415161718192021222324252627282930func longestOnes(A []int, K int) int { // è¿”å›å€¼ res := 0 left, right := 0, 0 zeros := 0 for right &lt; len(A) { // ç”¨å¤–å±‚å¾ªç¯å¸¦åŠ¨ right ç§»åŠ¨ if A[right] == 0 { zeros++ } // è¿™ä¸ªæ—¶å€™è¦ç§»åŠ¨å·¦ä¾§çš„ left ä¿éšœ zeros å° for zeros &gt; K { if A[left] == 0 { zeros-- } left++ } // æ¯è½®éƒ½å»æ¯”è¾ƒå³å¯ res = max(res, right - left + 1) right++ } return res}func max(a, b int) int { if a &gt; b { return a } return b} ç»å¯¹å·®ä¸è¶…è¿‡é™åˆ¶çš„æœ€é•¿è¿ç»­å­æ•°ç»„ ç»™å®šä¸€ä¸ªæ•°ç»„ nums å’Œ limitï¼Œæ‰¾åˆ°æœ€é•¿çš„è¿ç»­æ•°ç»„ï¼Œå…¶ä¸­ä»»æ„ä¸¤ä¸ªæ•°çš„å·®å€¼ä¸è¶…è¿‡ limit ä¸Šé¢è¿™å¥è¯æ¢ä¸ªè¯´æ³•è¯´çš„å°±æ˜¯ æœ€å¤§å€¼å’Œæœ€å°å€¼ ä¹‹å·®ä¸è¶…è¿‡ limitï¼Œå› æ­¤å¦‚æœèƒ½å¤Ÿ o(1) çš„æ‹¿åˆ°çª—å£çš„ æœ€å¤§æœ€å°å€¼ï¼Œé‚£ä¹ˆå°±æ¯”è¾ƒæ–¹ä¾¿ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package classictype MaxMinQueue struct { stack1 MaxMinStack stack2 MaxMinStack}func (queue *MaxMinQueue) Push(val int) { queue.stack1.Push(val)}func (queue *MaxMinQueue) Shift() int { if queue.stack2.Len() == 0 { for queue.stack1.Len() &gt; 0 { queue.stack2.Push(queue.stack1.Pop()) } } return queue.stack2.Pop()}func (queue *MaxMinQueue) Max() int { if queue.stack1.Len() == 0 { return queue.stack2.Max() } else if queue.stack2.Len() == 0 { return queue.stack1.Max() } return max(queue.stack2.Max(), queue.stack1.Max())}func (queue *MaxMinQueue) Min() int { if queue.stack1.Len() == 0 { return queue.stack2.Min() } else if queue.stack2.Len() == 0 { return queue.stack1.Min() } return min(queue.stack2.Min(), queue.stack1.Min())}func (queue *MaxMinQueue) Len() int { return queue.stack1.Len() + queue.stack2.Len()}type MaxMinStack struct { // è¿™ä¸¤ä¸ªä¸ç”¨ slice ç”¨ list ä¹‹ç±»çš„é“¾è¡¨ å¯èƒ½ä¼šå¿«ä¸€ç‚¹å„¿ data []int maxes []int mins []int}func (ms *MaxMinStack) Push(val int) { ms.data = append(ms.data, val) if len(ms.maxes) &gt; 0 { ms.maxes = append(ms.maxes, max(ms.maxes[len(ms.maxes)-1], val)) } else { ms.maxes = append(ms.maxes, val) } if len(ms.mins) &gt; 0 { ms.mins = append(ms.mins, min(ms.mins[len(ms.mins)-1], val)) } else { ms.mins = append(ms.mins, val) }}func (ms *MaxMinStack) Pop() int { res := ms.data[len(ms.data)-1] ms.data = ms.data[:len(ms.data)-1] ms.maxes = ms.maxes[:len(ms.maxes)-1] ms.mins = ms.mins[:len(ms.mins)-1] return res}func (ms *MaxMinStack) Max() int { return ms.maxes[len(ms.maxes)-1]}func (ms *MaxMinStack) Min() int { return ms.mins[len(ms.mins)-1]}func (ms *MaxMinStack) Len() int { return len(ms.data)}// æ‰¾åˆ°ä¸€ä¸ªæœ€é•¿çš„è¿ç»­å­æ•°ç»„ å…¶ä»»æ„ä¸¤ä¸ªå…ƒç´ ä¹‹é—´çš„å·®å€¼ å°äºç­‰äº limitfunc longestSubarray(nums []int, limit int) int { // å°±æ˜¯ç»´æŠ¤ä¸€ä¸ª queue ä¸ºäº†æ–¹ä¾¿ åº”è¯¥åœ¨ o(1) çš„æ—¶é—´å†…è·å¾—å…¶ æœ€å¤§æœ€å°å€¼ left, right := 0, 0 window := &amp;MaxMinQueue{stack1: MaxMinStack{}, stack2: MaxMinStack{}} res := 0 for right &lt; len(nums) { window.Push(nums[right]) if window.Len() &gt; 0 &amp;&amp; window.Max() - window.Min() &lt;= limit { res = max(res, right - left + 1) } for window.Len() &gt; 0 &amp;&amp; window.Max() - window.Min() &gt; limit { window.Shift() left++ } right++ } return res} çˆ±ç”Ÿæ°”çš„ä¹¦åº—è€æ¿ç»™å®šä¸€ä¸ª grumpy ä»¥åŠ custormers åœ¨ grumpy == 0 çš„æ—¶å€™ å¯ä»¥åŠ ä¸Š custormers çš„å¯¹åº”å€¼ï¼Œé—®å¦‚æœæœ‰è¿ç»­çš„ X ä¸ª gurmpy å¯ä»¥ä¸º 0 æœ€å¤§ customers çš„å’Œä¸ºå¤šå°‘ è‡ªå·±çš„åšæ³• ç»´æŠ¤ä¸€ä¸ªå‰ç¼€å’Œæ•°ç»„ sumï¼Œè¡¨ç¤ºå‰ i ä¸ªçš„å’Œä¸ºå¤šå°‘ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç”¨æ»‘åŠ¨çª—å£å°†æ•°ç»„åˆ†ä¸ºä¸‰æ®µ [0-&gt;l](å¯ä»¥ç”¨ sum æ•°ç»„æ±‚å¾—) [l-&gt;r](å…¨éƒ¨å˜ä¸º 0 æ‰€ä»¥æ˜¯ç›´æ¥æ±‚å’Œçš„) [r-&gt;len](å¯ä»¥ç”¨ sum æ•°ç»„æ±‚å¾—) 123456789101112131415161718192021222324public int maxSatisfiedWithSumArray(int[] customers, int[] grumpy, int X) { // sum[i] ä¿å­˜ customers[i] ä¹‹å‰çš„æ‰€æœ‰æ»¡è¶³è¦æ±‚çš„å’Œ int[] sum = new int[customers.length + 1]; for (int i = 1; i &lt;= customers.length; i++) { sum[i] = sum[i - 1]; if (grumpy[i - 1] == 0) { sum[i] += customers[i - 1]; } } // ç»“æœ int res = 0; // ç»´æŠ¤ä¸€ä¸ªçª—å£ è¿™ä¸ªçª—å£é•¿åº¦ä¸º X å…¨éƒ¨è®¤ä¸ºæ˜¯å¯ä»¥åŠ çš„ int windowSum = 0; for (int i = 0; i &lt; X; i++) { windowSum += customers[i]; } for (int i = X; i &lt; customers.length; i++) { res = Math.max(res, sum[i-X] + windowSum + sum[customers.length] - sum[i]); windowSum = windowSum - customers[i - X] + customers[i]; } res = Math.max(res, sum[customers.length-X] + windowSum); return res;} é¢˜è§£ é¢˜è§£æ›´è¿›ä¸€æ­¥ï¼Œå°† customers æ•°ç»„æ ¹æ® grumpy çš„å–å€¼åˆ†ä¸ºä¸¤ç±»ï¼Œä¸€ç±»æ˜¯ grumpy ç­‰äº 1 é‚£ä¹ˆæ˜¯å¯ä»¥ç›´æ¥åŠ ä¸Šçš„ï¼Œä¸€ç±»æ˜¯ grumpy == 0ï¼Œå¯ä»¥åœ¨é•¿åº¦ä¸º X çš„æ»‘åŠ¨çª—å£ä¸­ increase åˆ° ç¬¬ä¸€ç±»çš„ 123456789101112131415161718192021public int maxSatisfied(int[] customers, int[] grumpy, int X) { // åˆ†ä¸¤æ­¥è®¡ç®— ä¸€ä¸ªè®¡ç®—æ»¡è¶³è¦æ±‚çš„æ‰€æœ‰å’Œ total å¦ä¸€ä¸ªçª—å£å¯ä»¥é¢å¤–å¢åŠ çš„å€¼ int total = 0; for (int i = 0; i &lt; customers.length; i++) { // grumpy[i] == 0 çš„æ—¶å€™ æ‰åŠ ä¸Š total += (1 - grumpy[i]) * customers[i]; } // éå†å¯ä»¥å¢åŠ çš„å€¼ æ‰¾åˆ°æœ€å¤§çš„ int window = 0; // çª—å£éå†å¯ä»¥å¢åŠ çš„å€¼ for (int i = 0; i &lt; X; i++) { // çª—å£å¯ä»¥å¢åŠ çš„å€¼ æ˜¯ grumpy[i] == 1 window += grumpy[i] * customers[i]; } int res = window; for (int i = X; i &lt; customers.length; i++) { window = window - grumpy[i-X] * customers[i-X] + grumpy[i] * customers[i]; res = Math.max(res, window); } return total + res;} äºŒè¿›åˆ¶é¢˜ç›®æ¨¡æ‹Ÿé™¤æ³•(https://leetcode-cn.com/problems/divide-two-integers/)ä¸èƒ½ä½¿ç”¨ä¹˜æ³•ã€é™¤æ³•å’Œ mod è¿ç®—ç¬¦ã€‚ é™¤æ³•çš„æœ¬è´¨ï¼Œä»¥ 10 / 3 ä¸ºä¾‹ 10 / 3 = 3 â€¦â€¦ 1 (å³ä¸º 3 ä¸ª 3 ç›¸ä¹˜ ä½™ 1) å³ä¸º 10 - (3 _ 2) - (3 _ 1) = 1 å…¶ç»“æœä¸º 2 + 1 ä¸º 3 ä¹Ÿå°±æ˜¯è¯´ä»»æ„ä¸€ç§é™¤æ³•å¯ä»¥ç”¨ä¸€ç»„é™¤æ•°çš„ 2 çš„æ¬¡æ–¹çš„ä¹˜ç§¯çš„ç»“æœæ¥è¡¨ç¤ºã€‚ å¦‚ 100 / 15 = 6 100 - (15 _ 4) - (15 _ 2) æ‰€ä»¥å¯ä»¥é‡‡ç”¨äºŒè¿›åˆ¶çš„æ–¹æ³•æ¥åšï¼Œæ¯æ¬¡ç”¨è¢«é™¤æ•°å‡å»æœ€å¤§çš„ä¸€ä¸ªé™¤æ•°çš„ 2 æ¬¡æ–¹çš„ä¹˜ç§¯ï¼Œå¾ªç¯ï¼Œç›´åˆ°å‰©ä¸‹ä½™æ•°æˆ–è€… 0 123456789101112131415161718192021222324252627func divide(dividend int, divisor int) int { if divisor == 0 { return 1 &lt;&lt; 31 - 1 } minus := -1 if (dividend &lt; 0 &amp;&amp; divisor &lt; 0) || (dividend &gt; 0 &amp;&amp; divisor &gt; 0) { minus = 1 } absDividend, absDivisor := int64(math.Abs(float64(dividend))), int64(math.Abs(float64(divisor))) res := 0 for absDividend &gt;= absDivisor { tmp, multi := absDivisor, 1 for (tmp &lt;&lt; 1) &lt; absDividend { tmp &lt;&lt;= 1 multi &lt;&lt;= 1 } absDividend -= tmp res += multi if minus &gt; 0 &amp;&amp; res &gt;= math.MaxInt32 { return math.MaxInt32 } else if minus &lt; 0 &amp;&amp; minus * res &lt;= math.MinInt32 { return math.MinInt32 } } return minus * res} 123456789101112131415161718192021222324252627class Solution { public int divide(int dividend, int divisor) { if(divisor == 0 || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1)) return Integer.MAX_VALUE; int sign; if ((dividend &gt; 0 &amp;&amp; divisor &gt; 0) || (dividend &lt; 0 &amp;&amp; divisor &lt; 0)) sign = 1; else sign = -1; int res = 0; long dvd=Math.abs((long)dividend); long dvs=Math.abs((long)divisor); while (dvd &gt;= dvs) { long temp = dvs, m = 1; while (temp &lt;&lt; 1 &lt; dvd) { temp &lt;&lt;= 1; m &lt;&lt;= 1; } res += m; dvd -= temp; } return sign * res; }} åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— IIæ•°ç»„ä¸­çš„æ•°ç»„åªæœ‰å‡ºç° 1 æ¬¡ï¼ˆä¸€ä¸ªæ•°å­—ï¼‰çš„å’Œ 3 æ¬¡çš„æ•°å­—ï¼Œæ‰¾åˆ°åªå‡ºç°ä¸€æ¬¡çš„é‚£ä¸ªæ•°å­— å…¶å®å°±æ˜¯è®¡ç®—æ¯ä¸€ä½æ•°å­—å‡ºç°çš„æ¬¡æ•° % 3 æ³¨æ„ goland é»˜è®¤çš„ int å¯èƒ½å€¼å¾—æ˜¯ int64 æ‰€ä»¥å¼ºåˆ¶æŒ‡å®šä¸º 32 ä¸ºé•¿åº¦çš„ int32 ä¸ç„¶æ²¡åŠæ³•å¤„ç†è´Ÿæ•°çš„æƒ…å†µ 123456789101112func singleNumber(nums []int) int { var res int32 for i := 0; i &lt; 32; i++ { var count int32 for _, num := range nums { count += (int32(num )&gt;&gt; i) &amp; 1 } res += (count % 3) &lt;&lt; i } return int(res)} åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— IIIä¸€ç»„æ•°å­— å…¶ä¸­åªæœ‰ä¸¤ä¸ªæ•°å­— å‡ºç°ä¸€æ¬¡ å…¶ä½™å‡ºç°ä¸¤æ¬¡ 12345678910111213141516171819202122232425262728func singleNumberIII(nums []int) []int { // å¦‚æœä¸¤ä¸ªå‡ºç°ä¸€æ¬¡çš„æ•° ä¸åŒ è‚¯å®šä¸ä¸º 0 sum := 0 for _, num := range nums { sum ^= num } // é‚£ä¹ˆæ ¹æ® sum çš„æŸä¸€ä¸ªä¸ä¸º 0 çš„ä½æ•°æ¥åˆ†ç¦»ä¸¤ç±»æ•° counter := 1 for sum &amp; 1 == 0 { sum &gt;&gt;= 1 counter &lt;&lt;= 1 } // æ‰¾åˆ°äº†è¿™ä¸ªä½æ•° æ ¹æ® ä½æ•° åˆ†æˆä¸¤ç»„å³å¯ num1, num2 := 0, 0 for _, num := range nums { // æ ¹æ®ä½æ•°åˆ†ç¦»ä¸¤ç±»æ•° if num &amp; counter == 0 { num1 ^= num } else { num2 ^= num } } return []int{num1, num2}} æ•°å­—æŒ‰ä½ä¸è¦æ±‚æ±‚ m -&gt; n çš„èŒƒå›´å†…çš„æ‰€æœ‰æ•°å­—çš„ æŒ‰ä½ä¸ çš„ç»“æœï¼Œå› ä¸ºèŒƒå›´æ¯”è¾ƒå¤§ï¼Œç›´æ¥ &amp; ä¼šè¶…æ—¶ è€ƒè™‘ 3 -&gt; 11 è¿™ä¸ªèŒƒå›´çš„æ•°å­—ï¼Œçº¢è‰²çš„ å°±æ˜¯ç›¸åŒçš„äºŒè¿›åˆ¶å‰ç¼€éƒ¨åˆ† å®é™…ä¸Šå°±æ˜¯æ‰¾åˆ°è¿™éƒ¨åˆ†å‰ç¼€ 001011 11 001010 10 001001 09 001000 08 000111 07 000110 06 000101 05 000100 04 000011 03 123456789101112131415func rangeBitwiseAnd(m int, n int) int { if m == n { return m } // è€ƒè™‘ [5,6,7] ä¸‰ä¸ªæ•° &amp; èµ·æ¥çš„è¯ å®é™…ä¸Šæ˜¯ è€ƒè™‘ æœ€å¤§å€¼ å’Œ æœ€å°å€¼çš„ å·¦ä¾§ç›¸ç­‰çš„éƒ¨åˆ†æ˜¯å¤šå°‘ // mov è®°å½•ç§»ä½äº†å¤šå°‘æ¬¡ ç„¶åå†ç§»åŠ¨å›æ¥ mov := 0 for m != n { m &gt;&gt;= 1 n &gt;&gt;= 1 mov++ } return m &lt;&lt; mov} åŠ¨æ€è§„åˆ’æœ€åä¸€å—çŸ³å¤´çš„é‡é‡ IIå…¶å®å°±æ˜¯é—®æ˜¯å¦èƒ½å¤Ÿå½¢æˆç›¸ç­‰çš„ä¸¤éƒ¨åˆ†, ç”¨ä¸€ä¸ª dp[i][j] è¡¨ç¤ºå‰ i ä¸ªçš„èƒ½å¦å½¢æˆå’Œä¸º j çš„æ•°å€¼ï¼Œåœ¨éå†çš„æ—¶å€™å°±å¯ä»¥æ‰¾åˆ°æœ€å¤§çš„å’Œä¸ºå¤šå°‘ï¼Œä¹‹åå°±å‡å»æœ€å¤§çš„å’Œå³å¯ 1234567891011121314151617181920212223242526272829303132333435package classic// è¿™é“é¢˜é¢˜å¹² è¦æ±‚ stones ä¸¤ä¸¤ç›¸æ’ å‰©ä¸‹ä¸€å—å„¿ ä¸ºå‰©ä¸‹çš„çŸ³å¤´ æœ€å°èƒ½å½¢æˆçš„é‡é‡// å…¶å®å°±æ˜¯é—®æ˜¯å¦èƒ½å¤Ÿå½¢æˆç›¸ç­‰çš„ä¸¤éƒ¨åˆ† å› ä¸ºç›¸ç­‰çš„è¯ æœ€åå½¢æˆçš„çŸ³å¤´ ä¸º 0func lastStoneWeightII(stones []int) int { sum := getStonesSum(stones) // dp[i][j] è¡¨ç¤ºå‰ i ä¸ªèƒ½å¦å½¢æˆ ä½•ä¸º j dp := make([][]bool, len(stones)+1) for i := 0; i &lt; len(dp); i++ { dp[i] = make([]bool, sum/2+1) // åˆä¸º0ä¸€å®šå¯ä»¥ dp[i][0] = true } maxSum := 0 for i := 1; i &lt;= len(stones); i++ { for j := 1; j &lt;= sum/2; j++ { // å› ä¸ºè¡¨ç¤ºçš„å‰ i èƒ½ä¸èƒ½å½¢æˆ j æ‰€ä»¥ i-1 èƒ½å½¢æˆçš„è¯ ä¹Ÿæ˜¯å¯ä»¥çš„ dp[i][j] = dp[i][j] || dp[i-1][j] if j &gt;= stones[i-1] { dp[i][j] = dp[i][j] || dp[i-1][j-stones[i-1]] } if dp[i][j] { maxSum = max(maxSum, j) } } } return sum - 2 * maxSum}func getStonesSum(stones []int) (sum int) { for _, w := range stones { sum += w } return} æœ€é•¿å­åºåˆ—å¥—é¢˜æœ€é•¿ä¸Šå‡å­åºåˆ—æ‰¾åˆ°éè¿ç»­çš„é€’å¢å­åºåˆ—ï¼Œé‚£ä¹ˆæˆ‘å°±åªéœ€è¦çŸ¥é“ åœ¨æˆ‘ä¹‹å‰çš„å°äºæˆ‘çš„æ•°å­—çš„ä¸Šå‡å­åºåˆ—é•¿åº¦ä¸ºå¤šå°‘ å³å®é™…ä¸Šåªéœ€è¦åœ¨è®¿é—®æ•°ç»„çš„æ—¶å€™ 0 â‰¤ i &lt; j &lt; nums.lengthï¼Œåªéœ€è¦çŸ¥é“ i ä¸‹æ ‡å¯¹åº”çš„æœ€é•¿çš„å­åºåˆ—æ˜¯å¤šå°‘å³å¯ã€‚ è¿™æ ·å°±å˜æˆäº†ä¸€ä¸ª dp é—®é¢˜ï¼Œå°é—®é¢˜å°±æ˜¯è§£å†³çš„ä»¥ nums[i] ç»“å°¾çš„æœ€é•¿çš„ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ 123456789101112131415161718func lengthOfLIS(nums []int) int { // dp[i] è¡¨ç¤º nums[i] ç»“å°¾çš„æœ€é•¿çš„é€’å¢å­åºåˆ—é•¿åº¦ä¸ºå¤šå°‘ dp := make([]int, len(nums)) // åˆå§‹åŒ– ä¸€ä¸ªæ•°å­—è‚¯å®šæ˜¯é€’å¢çš„ for i := 0; i &lt; len(nums); i++ { dp[i] = 1 } res := 0 for i, num := range nums { for j := 0; j &lt; i; j++ { if num &gt; nums[j] { dp[i] = max(dp[i], dp[j]+1) } } res = max(res, dp[i]) } return res} æœ€é•¿ä¸Šå‡å­åºåˆ—æ•°é‡ä¸ä¸Šé¢é‚£ä¸ªç±»ä¼¼ ä¹Ÿæ˜¯ä¸€ä¸ª dp é—®é¢˜ åªæ˜¯éœ€è¦åœ¨ dp éå†çš„æ—¶å€™ çŸ¥é“ å¯¹åº”æœ€é•¿é•¿åº¦ å¯¹åº”çš„ LIS æœ‰å¤šå°‘ä¸ª 1234567891011121314151617181920212223242526272829303132333435363738// æ‰¾åˆ° LIS å¯¹åº”çš„é•¿åº¦çš„å­åºåˆ—æœ‰å¤šå°‘ä¸ªfunc findNumberOfLIS(nums []int) int { // ä¿å­˜ nums[i] ç»“å°¾çš„ LIS çš„é•¿åº¦ dp := make([]int, len(nums)) // ä¿å­˜ nums[i] ç»“å°¾çš„ LIS çš„æœ€é•¿ LIS çš„é•¿åº¦ counts := make([]int, len(nums)) // åˆå§‹åŒ– for i := 0; i &lt; len(dp); i++ { dp[i] = 1 counts[i] = 1 } maxLen := 0 for i := 0; i &lt; len(nums); i++ { for j := 0; j &lt; i; j++ { // å½¢æˆ é€’å¢ if nums[j] &lt; nums[i] { if dp[i] &lt;= dp[j] { // è¯´æ˜ j çš„é•¿åº¦æ¯”è¿™ä¸ªé•¿ dp[i] = dp[j] + 1 counts[i] = counts[j] } else if dp[j]+1 == dp[i] { // é•¿åº¦ç›¸å·® 1 è¯´æ˜è¿™ä¸ªæ—¶å€™ counts è¦ + ä¸Š j çš„ counts[i] += counts[j] } } } maxLen = max(maxLen, dp[i]) } res := 0 for i, count := range counts { if maxLen == dp[i] { res += count } } return res} æ‘†åŠ¨åºåˆ—æ‰¾åˆ°æ‘†åŠ¨åºåˆ—ï¼ˆæ‘†åŠ¨åºåˆ—æ˜¯ä¸€å‡ä¸€é™çš„åºåˆ—ï¼Œå³å‰åç›¸å‡ä¸ºä¸€æ­£ä¸€è´Ÿï¼‰å‚è€ƒæ³¨é‡Šå³å¯ (è¿™ä¸ªé¢˜ç›®ä¸è¦æ±‚è¿ç»­ æ‰€ä»¥è¿˜éœ€è¦ä¸åœçš„ä¿å­˜å‰ä¸€ä¸ªçŠ¶æ€ ä¸ç”¨åˆå§‹åŒ–) 1234567891011121314151617181920212223242526272829// ä¸¤ä¸ªæ•°ç»„åˆ†åˆ«ä»£è¡¨ä¸Šå‡å’Œä¸‹é™åºåˆ—çš„æœ€å¤§é•¿åº¦// å› ä¸º wiggle çš„æ•°ç»„ æ˜¯ä¸€å‡ä¸€é™ çš„ up[i] è¡¨ç¤º æœ€åä¸€ä¸ª nums[i] æ˜¯ä¸Šå‡çš„è¶‹åŠ¿çš„æœ€å¤§å€¼func wiggleMaxLengthWithoutMemo(nums []int) int { if len(nums) == 0 { return 0 } // up[i] down[i] åˆ†åˆ«ä»£è¡¨ä¸Šå‡å’Œä¸‹é™åºåˆ—(æœ€åä¸€ä¸ªæ˜¯ä¸Šå‡æˆ–è€…ä¸‹é™)çš„ åœ¨ index = i æ—¶çš„æœ€é•¿é•¿åº¦ ups, downs := make([]int, len(nums)), make([]int, len(nums)) // åˆå§‹åŒ– ups[0] = 1 downs[0] = 1 for i := 1; i &lt; len(nums); i++ { if nums[i] &gt; nums[i-1] { // å¦‚æœ nums i æ˜¯ä¸Šå‡è¶‹åŠ¿ è¯´æ˜é‚£ä¹ˆ ä¹‹å‰å‰ä¸€ä¸ªæ˜¯ä¸‹é™çš„è¶‹åŠ¿çš„è¯ å¯ä»¥ åŠ ä¸€ // åŒæ—¶ ä¹Ÿå¯ä»¥ä¸è€ƒè™‘è¿™ä¸ª ä¸Šå‡è¶‹åŠ¿ è·Ÿå‰ä¸€ä¸ªæ¯”è¾ƒ ups[i] = max(downs[i-1]+1, ups[i-1]) // æ­¤æ—¶ç”±äºæ˜¯ä¸Šå‡çš„ æ‰€ä»¥æ²¡æœ‰ä¸‹é™çš„è¶‹åŠ¿ çŠ¶æ€ç›´æ¥è½¬ç§» downs[i] = downs[i-1] } else if nums[i] &lt; nums[i-1] { downs[i] = max(ups[i-1]+1, downs[i-1]) ups[i] = ups[i-1] } else { // ç›¸ç­‰çš„æƒ…å†µä¸‹æ˜¯ä¸å˜çš„ ups[i] = ups[i-1] downs[i] = downs[i-1] } } return max(ups[len(ups)-1], downs[len(downs)-1])} å› ä¸ºåªä¾èµ–å‰ä¸€ä¸ªçŠ¶æ€ å› æ­¤å¯ä»¥å‹ç¼©çŠ¶æ€ 1234567891011121314151617181920212223// ä¸¤ä¸ªæ•°ç»„åˆ†åˆ«ä»£è¡¨ä¸Šå‡å’Œä¸‹é™åºåˆ—çš„æœ€å¤§é•¿åº¦// å› ä¸º wiggle çš„æ•°ç»„ æ˜¯ä¸€å‡ä¸€é™ çš„ up[i] è¡¨ç¤º æœ€åä¸€ä¸ª nums[i] æ˜¯ä¸Šå‡çš„è¶‹åŠ¿çš„æœ€å¤§å€¼func wiggleMaxLength(nums []int) int { if len(nums) == 0 { return 0 } up, down := 1, 1 for i := 1; i &lt; len(nums); i++ { preDown, PreUp := down, up if nums[i] &gt; nums[i-1] { up = max(down+1, up) down = preDown } else if nums[i] &lt; nums[i-1] { down = max(up+1, down) up = PreUp } else { up = PreUp down = preDown } } return max(up, down)} ç±»ä¼¼æ‘†åŠ¨åºåˆ—çš„é¢˜ç›® 978. æœ€é•¿æ¹æµå­æ•°ç»„æ‰¾åˆ°ä¸€ä¸ªè¿ç»­çš„å­æ•°ç»„èƒ½å¤Ÿæ»¡è¶³ å½“ A çš„å­æ•°ç»„ A[i], A[i+1], â€¦, A[j] æ»¡è¶³ä¸‹åˆ—æ¡ä»¶æ—¶ï¼Œæˆ‘ä»¬ç§°å…¶ä¸ºæ¹æµå­æ•°ç»„ï¼š è‹¥ i &lt;= k &lt; jï¼Œå½“ k ä¸ºå¥‡æ•°æ—¶ï¼Œ A[k] &gt; A[k+1]ï¼Œä¸”å½“ k ä¸ºå¶æ•°æ—¶ï¼ŒA[k] &lt; A[k+1]ï¼›æˆ– è‹¥ i &lt;= k &lt; jï¼Œå½“ k ä¸ºå¶æ•°æ—¶ï¼ŒA[k] &gt; A[k+1] ï¼Œä¸”å½“ k ä¸ºå¥‡æ•°æ—¶ï¼Œ A[k] &lt; A[k+1]ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæ¯”è¾ƒç¬¦å·åœ¨å­æ•°ç»„ä¸­çš„æ¯ä¸ªç›¸é‚»å…ƒç´ å¯¹ä¹‹é—´ç¿»è½¬ï¼Œåˆ™è¯¥å­æ•°ç»„æ˜¯æ¹æµå­æ•°ç»„ã€‚ 123456789101112131415161718192021222324252627282930func maxTurbulenceSize(arr []int) int { // ä»ç„¶æ˜¯ä¸€å‡ä¸€é™ æ‰èƒ½ä½¿ç¬¦å·åå· up, down := 1, 1 res := 1 for i := 1; i &lt; len(arr); i++ { if arr[i] &gt; arr[i-1] { up = down+1 // å› ä¸ºæ˜¯è¦è¿ç»­çš„ ä¸€å‡ä¸€é™ æ‰€ä»¥è¿™ä¸ªåœ°æ–¹éœ€è¦é‡æ–°åˆå§‹åŒ–ä¸º 1 down = 1 } else if arr[i] &lt; arr[i-1] { down = up + 1 up = 1 } else { up, down = 1, 1 } // å› ä¸ºé‡æ–°åˆå§‹åŒ– æ‰€ä»¥éœ€è¦å¯¹æ¯ä¸€ä¸ªçŠ¶æ€è¿›è¡Œæ¯”è¾ƒä¿å­˜ res = max(res, max(up, down)) } return res}func max(a, b int) int { if a &gt; b { return a } return b} ä¿„ç½—æ–¯å¥—å¨ƒä¿¡å°é—®é¢˜æ ¹æ®ä¿¡å°çš„å®½åº¦å’Œé«˜åº¦ åˆ¤æ–­èƒ½å¤Ÿè£…ä¸‹çš„ä¿¡å°çš„æœ€å¤§é•¿åº¦æœ‰å¤šå°‘ é«˜åº¦å’Œå®½åº¦å‡å°äºå¦å¤–ä¸€ä¸ªä¿¡å°çš„ å¯ä»¥è£…è¿›å» å®é™…ä¸Šæ˜¯ä¸€ä¸ª æ‰¾åˆ°æœ€é•¿é€’å¢åºåˆ—çš„é—®é¢˜ æŒ‰ç…§å®½åº¦è¿›è¡Œæ’åºï¼Œè¿™æ ·ä»ä¸€ä¸ªç»´åº¦ä¸Šçœ‹ æ‰€æœ‰çš„ä¿¡å°éƒ½æ˜¯å®½åº¦æœ‰åºçš„ å†æ¬¡åŸºç¡€ä¸Š å¦‚æœè¦å‰ä¸€ä¸ªä¿¡å°èƒ½å¤Ÿè£…åœ¨åä¸€ä¸ªä¿¡å°é‡Œé¢ è¯´æ˜é•¿åº¦æ˜¯ä¸€ä¸ªé€†åºçš„ æœ€ååªéœ€è¦åœ¨è¿™ä¸ªæ’åºçš„æ•°ç»„é‡Œé¢ æ‰¾åˆ°é•¿åº¦çš„ä¸€ä¸ªæœ€é•¿é€’å¢åºåˆ—å³å¯ 123456789101112131415161718192021222324252627282930313233343536373839func maxEnvelopes(envelopes [][]int) int { // envelopes[0] ç›¸ç­‰ è¯´æ˜å®½åº¦ç›¸ç­‰ è¿™ä¸ªæ—¶å€™ åªéœ€è¦æ›´é•¿çš„æ’åœ¨åé¢å³å¯ // envelopes[0] ä¸ç­‰ è¯´æ˜å®½åº¦ä¸ç­‰ è¿™ä¸ªæ—¶å€™ åªéœ€è¦åªéœ€è¦æ ¹æ®é•¿åº¦å¤§å°ä»å¤§åˆ°å°æ’åºå³å¯ sort.Slice(envelopes, func(i, j int) bool { if envelopes[i][0] == envelopes[j][0] { return envelopes[i][1] &gt; envelopes[j][1] } else { return envelopes[i][0] &lt; envelopes[j][0] } }) // å› ä¸ºç°åœ¨è¿™æ ·æ’åºä¹‹å ä¿¡å°çš„å®½åº¦ ä¸€å®šæ˜¯æ»¡è¶³é¡ºåºçš„ é‚£ä¹ˆåªéœ€è¦åˆ¤æ–­é•¿åº¦ èƒ½å¤Ÿå½¢æˆçš„æœ€é•¿çš„é€’å¢å­åºåˆ—æ˜¯å¤šé•¿ dp := make([]int, len(envelopes)) // 1 ä¸ªæ•°å­—ä¹Ÿèƒ½æœ‰ä¸€ä¸ªé•¿åº¦ for i := 0; i &lt; len(dp); i++ { dp[i] = 1 } res := 0 for i := 0; i &lt; len(dp); i++ { tmp := 0 for j := 0; j &lt; i; j++ { if envelopes[i][1] &gt; envelopes[j][1] { tmp = max(tmp, dp[j]) } } dp[i] = tmp + 1 res = max(res, dp[i]) } return res}func max(a, b int) int { if a &gt; b { return a } return b} è§£ç æ–¹æ³•è¿™é“é¢˜æ˜¯å…¥é—¨çš„åŠ¨æ€è§„åˆ’ åªè¦çŸ¥é“ å‰ä¸€ä¸ªå’Œå‰å‰ä¸ªçš„çŠ¶æ€ï¼Œå°±å¯ä»¥è½¬ç§»åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€ 12345678910111213141516171819202122232425262728293031323334353637func numDecodings(s string) int { if len(s) == 0 { return 0 } // dp[i] è¡¨ç¤º s[0:i] ä¸åŒ…æ‹¬ièƒ½ç”Ÿæˆçš„æ•°é‡ // dp[i] = dp[i-1]+dp[i-2] // å› ä¸ºåªè¦å½“å‰çš„è¿™ä¸ª sting èƒ½å¤Ÿè¢« decoding è¯´æ˜åªè¦åŠ ä¸Šå‰é¢çš„æ•°é‡å³å¯ dp := make([]int, len(s) + 1) dp[0] = 1 // è¡¨ç¤ºçš„æ¯æ¬¡éå†çš„stringçš„å°¾éƒ¨ for i := 1; i &lt;= len(s); i++ { for j := max(i - 2, 0); j &lt; i; j++ { if canDecoding(s[j:i]) { dp[i] += dp[j] } } } return dp[len(s)]}func canDecoding(s string) bool { if len(s) &gt; 1 &amp;&amp; s[0] == '0' { return false } if num, err := strconv.Atoi(s); err != nil || num &gt; 26 || num &lt; 1 { return false } return true}func max(a, b int) int { if a &gt; b { return a } return b} å­åºåˆ—ä¸åŒçš„å­åºåˆ—1234567891011121314151617181920212223242526func numDistinct(s string, t string) int { // dp[i][j] è¡¨ç¤º s[i-1] å’Œ t[j-1] ä¹‹é—´æœ‰å¤šå°‘ç»„åˆ dp := make([][]int, len(s)+1) for i := 0; i &lt;= len(s); i++ { dp[i] = make([]int, len(t)+1) } // åˆå§‹åŒ– åªè¦ t æ˜¯ç©º é‚£ä¹ˆä¸€å®šå¯ä»¥ åœ¨ s ä¸­æ‰¾åˆ° for i := 0; i &lt;= len(s); i++ { dp[i][0] = 1 } for i := 1; i &lt;= len(s); i++ { for j := 1; j &lt;= len(t); j++ { if s[i-1] == t[j-1] { // åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ† å› ä¸ºå¯ä»¥ä¸ç®—å½“å‰çš„ s ä¸²çš„æœ€åä¸€ä¸ª ä¹Ÿå¯ä»¥ç®—ä¸Š // å› ä¸º s ä¸²çš„å‰é¢éƒ¨åˆ† å¯èƒ½å·²ç»åŒ¹é…åˆ°äº† dp[i][j] = dp[i-1][j-1] + dp[i-1][j] } else { dp[i][j] = dp[i-1][j] } } } return dp[len(s)][len(t)]} æ‰“å®¶åŠ«èˆç³»åˆ—é¢˜æ‰“å®¶åŠ«èˆ Iè¿™é“é¢˜æ˜¯ç»å…¸çš„ dp é—®é¢˜ã€‚é¢˜ç›®è¦æ±‚çš„æ˜¯ä¸èƒ½æŠ¢åŠ«ç›¸é‚»çš„ä½ç½®ï¼Œé‚£ä¹ˆè¿™ç§æ¡ä»¶ä¸‹çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ã€‚ ä¸€ä¸ªä½ç½®ä¼šæœ‰ä¸¤ä¸ªçŠ¶æ€ï¼Œæ‹¿å½“å‰è¿™ä¸ªåœ°æ–¹çš„å€¼ æˆ–è€… ä¸æ‹¿ ä¸‹ä¸ªä½ç½®çš„çŠ¶æ€å°±ä¼šç”±ä¸Šä¸€ä¸ªä½ç½®å†³å®š å¦‚æœå½“å‰ä½ç½®æ‹¿äº†å€¼çš„è¯ï¼Œä¸Šä¸€ä¸ªä½ç½®åªèƒ½ä¸æ‹¿ å¦‚æœå½“å‰ä½ç½®æ²¡æœ‰æ‹¿ï¼Œä¸Šä¸€ä¸ªä½ç½®åªéœ€è¦å–æ‹¿ or ä¸æ‹¿çš„ è¾ƒå¤§å€¼ ä¼˜åŒ–ä¸‹ dp æ•°ç»„ å…¶å®å¯ä»¥ç”¨ä¸€å¯¹å€¼è¡¨ç¤ºå‰é¢ä¸€ä¸ªå¾ªç¯ä¸­æ‹¿äº†çš„æœ€å¤§å€¼å³å¯ 12345678910111213141516func rob(nums []int) int { if len(nums) &lt;= 0 { return 0 } // ä¼˜åŒ–çš„ç›®çš„åœ¨äºå»æ‰æ•°ç»„ å› ä¸ºç°åœ¨ç›´æ¥æœ€å¤§çš„å°±æ˜¯ notRob, rob := 0, 0 res := 0 for _, num := range nums { rm := rob rob = notRob + num notRob = max(notRob, rm) res = max(notRob, rob) } return res} æ‰“å®¶åŠ«èˆ IIè¿™ä¸ªæ˜¯æ‰“åŠ«çš„å¾ªç¯æ•°ç»„ï¼Œå› ä¸º rob äº†ç¬¬ä¸€ä¸ª å°±ä¸èƒ½ rob æœ€åä¸€ä¸ª æ‰€ä»¥åˆ†åˆ«è®¿é—®ä» [1:len(nums)] å’Œ [0:len(nums)-1] ç„¶åæ¯”è¾ƒå¤§å°å³å¯ 1234567891011121314151617181920212223242526272829303132func rob(nums []int) int { if len(nums) &lt;= 0 { return 0 } if len(nums) == 1 { return nums[0] } // å› ä¸ºæ˜¯é¦–å°¾ç›¸è¿çš„ robFirst := getMaxRob(nums[:len(nums)-1]) notRobFirst := getMaxRob(nums[1:]) return max(robFirst, notRobFirst)}func getMaxRob(nums []int) int { notRob, rob := 0, 0 res := 0 for _, num := range nums { rem := rob rob = notRob + num notRob = max(rem, notRob) res = max(res, max(rob, notRob)) } return res}func max(a, b int) int { if a &gt; b { return a } return b} æ‰“å®¶åŠ«èˆ IIIè¿™æ¬¡æ˜¯æ ‘ï¼Œå®é™…ä¸Šè¿˜æ˜¯è¦çŸ¥é“å­èŠ‚ç‚¹ä¸Šçš„è¯ rob å’Œ notRob çš„çŠ¶æ€å³å¯ï¼Œç„¶åé€’æ¨åˆ°å½“å‰çš„çŠ¶æ€ 1234567891011121314151617181920212223242526272829303132333435363738394041func rob(root *TreeNode) int { var res int recursionRobTree(root, &amp;res) return res}// recursionRobTree è¿”å›å€¼æ˜¯ rob å½“å‰è¿™ä¸ª root è¿˜ä¸ ä¸ rob çš„å€¼func recursionRobTree(root *TreeNode, res *int) (int, int) { if root == nil { return 0, 0 } leftRob, leftNotRob := recursionRobTree(root.Left, res) rightRob, rightNotRob := recursionRobTree(root.Right, res) // å¦‚æœ rob å½“å‰è¿™ä¸ªroot èŠ‚ç‚¹çš„è¯ æ„å‘³ç€ ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸å¯ä»¥rob rob := leftNotRob + rightNotRob + root.Val // å¦‚æœ ä¸ rob è¿™ä¸ªèŠ‚ç‚¹çš„è¯ å­èŠ‚ç‚¹å¯ä»¥ rob ä¹Ÿå¯ä»¥ä¸ rob notRob := getArrayMax(leftRob + rightRob, rightRob + leftNotRob, rightNotRob + leftRob, rightNotRob + leftNotRob) *res = max(*res, rob) *res = max(*res, notRob) return rob, notRob}func getArrayMax(nums ...int) int { if len(nums) == 0 { return -1 } res := nums[0] for _, num := range nums { res = max(res, num) } return res}func max(a, b int) int { if a &gt; b { return a } return b} è´ªå¿ƒç®—æ³•è½¬æ¢ç½—é©¬å­—12345678910111213141516171819202122232425262728293031323334353637383940package classicimport ( &quot;strings&quot;)var ( memo = make(map[int]string) keys []int)func init() { memo[1] = &quot;I&quot; memo[4] = &quot;IV&quot; memo[5] = &quot;V&quot; memo[9] = &quot;IX&quot; memo[10] = &quot;X&quot; memo[40] = &quot;XL&quot; memo[50] = &quot;L&quot; memo[90] = &quot;XC&quot; memo[100] = &quot;C&quot; memo[400] = &quot;CD&quot; memo[500] = &quot;D&quot; memo[900] = &quot;CM&quot; memo[1000] = &quot;M&quot; keys = []int{1000,900,500,400,100,90,50,40,10,9,5,4,1}}func intToRoman(num int) string { res := strings.Builder{} for _, key := range keys { for num &gt;= key { res.WriteString(memo[key]) num -= key } } return res.String()} jumpGame12345678910111213141516func canJump(nums []int) bool { rightMost := 0 for i, num := range nums { // å¦‚æœå½“å‰çš„ä¸‹æ ‡å¤§äº rightMost è¯´æ˜è¿™ä¸ªç‚¹æ˜¯æ— æ³•åˆ°è¾¾çš„ ç›´æ¥è¿”å› false å³å¯ if i &gt; rightMost { return false } // ç»´æŠ¤ä¸€ä¸ªèƒ½å¤Ÿåˆ°è¾¾çš„æœ€è¿œè·ç¦» rightMost = max(rightMost, i + num) // æœ€è¿œè·ç¦»å¤§äºé•¿åº¦ å³å¯çŸ¥é“èƒ½å¤Ÿè¾¾åˆ° if rightMost &gt;= len(nums) - 1 { return true } } return false} é€’å½’æ‹¬å·ç”Ÿæˆ1234567891011121314151617181920212223// generateParenthesis å…¥å£å‡½æ•°func generateParenthesis(n int) []string { res := make([]string, 0) recursionGenerate(&amp;res, &quot;&quot;, n, n) return res}// é€’å½’ç”Ÿæˆfunc recursionGenerate(res *[]string, tmp string, left, right int) { if left == 0 &amp;&amp; right == 0 { *res = append(*res, tmp) return } // ç”±äºå·¦æ‹¬å·å¯ä»¥ç›´æ¥æ”¾åˆ°ç»“æœä¸Šï¼Œå› æ­¤å·¦æ‹¬å·ä¸ç”¨åˆ¤æ–­å…¶ä»–çš„ if left &gt; 0 { recursionGenerate(res, tmp+&quot;(&quot;, left-1, right) } // è€Œæœ‰æ‹¬å·éœ€è¦è·Ÿå·¦æ‹¬å·åŒ¹é…ï¼Œæ‰€ä»¥æœ‰æ‹¬å·éå†çš„æ—¶å€™ å¿…é¡»å·²ç»æœ‰å·¦æ‹¬å·è¢«æ”¾åˆ°äº†ç»“æœä¸­ // æ‰€ä»¥éœ€è¦åˆ¤æ–­ä¸€ä¸‹ right &gt; left if right &gt; left { recursionGenerate(res, tmp+&quot;)&quot;, left, right-1) }} 12345678910111213141516171819public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); recursion(res, n, n, &quot;&quot;); return res;}public void recursion(List&lt;String&gt; res, int left, int right, String tmp) { if (left == 0 &amp;&amp; right == 0) { res.add(tmp); return; } if (left &gt; 0) { recursion(res, left - 1, right, tmp + &quot;(&quot;); } if (right &gt; left) { recursion(res, left, right - 1, tmp + &quot;)&quot;); }} æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…è¿™é“é¢˜å¯ä»¥ç”¨é€’å½’çš„æ€æƒ³å»åšï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨ dp çš„æ–¹æ³•ã€‚å®é™…ä¸Šé€’å½’å°±æ˜¯ä»ä¸Šå‘ä¸‹çš„ dp 12345678910111213141516171819202122232425262728293031func isMatch(s string, p string) bool { return recursionIsMatch(s, p, 0, 0)}func recursionIsMatch(s, p string, sIndex, pIndex int) bool { // å®Œå…¨åŒ¹é… if sIndex == len(s) &amp;&amp; pIndex == len(p) { return true } // è¶Šç•Œ pattern åŒ¹é…å®Œäº†ä¸€å®šæœ‰é—®é¢˜ if pIndex == len(p) &amp;&amp; sIndex != len(s) { return false } if pIndex &lt; len(p)-1 &amp;&amp; p[pIndex+1] == '*' { // åŒ¹é… if pIndex &lt; len(p) &amp;&amp; sIndex &lt; len(s) &amp;&amp; (p[pIndex] == s[sIndex] || p[pIndex] == '.') { return recursionIsMatch(s, p, sIndex, pIndex+2) || // åŒ¹é…0æ¬¡ å› ä¸º * ä»£è¡¨ 0 -&gt; å¤šæ¬¡ recursionIsMatch(s, p, sIndex+1, pIndex+2) || // åŒ¹é…1æ¬¡ recursionIsMatch(s, p, sIndex+1, pIndex) // åŒ¹é…å¤šæ¬¡ } else { // å¦‚æœä¸åŒ¹é… åˆ™è·³è¿‡ return recursionIsMatch(s, p, sIndex, pIndex+2) } } // ç°åœ¨çš„å­—ç¬¦æ˜¯åŒ¹é…çš„ if pIndex &lt; len(p) &amp;&amp; sIndex &lt; len(s) &amp;&amp; (p[pIndex] == s[sIndex] || p[pIndex] == '.') { return recursionIsMatch(s, p, sIndex+1, pIndex+1) } return false} 123456789101112131415161718192021222324252627public boolean isMatch(String s, String p) { return recursion(s, p, 0, 0);}public boolean recursion(String s, String p, int sIndex, int pIndex) { if (pIndex == p.length() &amp;&amp; sIndex != s.length()) { return false; } if (sIndex == s.length() &amp;&amp; pIndex == p.length()) { return true; } if (pIndex &lt; p.length() - 1 &amp;&amp; p.charAt(pIndex + 1) == '*') { if (sIndex &lt; s.length() &amp;&amp; (p.charAt(pIndex) == '.' || p.charAt(pIndex) == s.charAt(sIndex))) { return recursion(s, p, sIndex, pIndex + 2) || // åŒ¹é…0æ¬¡ recursion(s, p, sIndex + 1, pIndex + 2) || // åŒ¹é…1æ¬¡ recursion(s, p, sIndex + 1, pIndex); // åŒ¹é…å¤šæ¬¡ } else { return recursion(s, p, sIndex, pIndex + 2); } } if (sIndex &lt; s.length() &amp;&amp; pIndex &lt; p.length() &amp;&amp; (p.charAt(pIndex) == '.' || p.charAt(pIndex) == s.charAt(sIndex))) { return recursion(s, p, sIndex + 1, pIndex + 1); } return false;} æ•°æ®ç»“æ„æ ˆå’Œé˜Ÿåˆ—é˜Ÿåˆ—-æ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼æœ€å¤§ queue çš„é˜Ÿåˆ— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960type MaxQueue struct { stack1 MaxStack stack2 MaxStack}func (queue *MaxQueue) Push(val int) { queue.stack1.Push(val)}func (queue *MaxQueue) shift() int { if queue.stack2.Len() == 0 { for queue.stack1.Len() &gt; 0 { queue.stack2.Push(queue.stack1.Pop()) } } return queue.stack2.Pop()}func (queue *MaxQueue) Max() int { if queue.stack1.Len() == 0 { return queue.stack2.Max() } else if queue.stack2.Len() == 0 { return queue.stack1.Max() } return max(queue.stack2.Max(), queue.stack1.Max())}func (queue *MaxQueue) Len() int { return queue.stack1.Len() + queue.stack2.Len()}type MaxStack struct { // è¿™ä¸¤ä¸ªä¸ç”¨ slice ç”¨ list ä¹‹ç±»çš„é“¾è¡¨ å¯èƒ½ä¼šå¿«ä¸€ç‚¹å„¿ data []int maxes []int}func (ms *MaxStack) Push(val int) { ms.data = append(ms.data, val) if len(ms.maxes) &gt; 0 { ms.maxes = append(ms.maxes, max(ms.maxes[len(ms.maxes)-1], val)) } else { ms.maxes = append(ms.maxes, val) }}func (ms *MaxStack) Pop() int { res := ms.data[len(ms.data)-1] ms.data = ms.data[:len(ms.data)-1] ms.maxes = ms.maxes[:len(ms.maxes)-1] return res}func (ms *MaxStack) Max() int { return ms.maxes[len(ms.maxes)-1]}func (ms *MaxStack) Len() int { return len(ms.data)} ä½¿ç”¨ä»£ç  123456789101112131415161718func maxSlidingWindow(nums []int, k int) []int { queue := MaxQueue{ stack1: MaxStack{}, stack2: MaxStack{}, } for i := 0; i &lt; k; i++ { queue.Push(nums[i]) } res := make([]int, 0) for i := k; i &lt; len(nums); i++ { res = append(res, queue.Max()) queue.shift() queue.Push(nums[i]) } res = append(res, queue.Max()) return res} æ ˆ-è®¡ç®—å™¨ä¸­å€¼è¡¨è¾¾å¼è½¬æ³¢å…°è¡¨è¾¾å¼ï¼ˆå®é™…ä¸Šæ˜¯ï¼‰ é“¾è¡¨åˆ é™¤å€’æ•°çš„ç¬¬ N ä¸ªèŠ‚ç‚¹1234567891011121314151617181920212223func removeNthFromEnd(head *ListNode, n int) *ListNode { // å› ä¸ºå¯èƒ½åˆ é™¤å¤´ç»“ç‚¹ æ‰€æœ‰åŠ äº†ä¸€ä¸ª newHead := new(ListNode) newHead.Next = head // fast æ˜¯å…ˆèµ°çš„ä¸€ä¸ªèŠ‚ç‚¹ pre æ˜¯åèµ°çš„ pre, fast := newHead, head for n &gt; 0 { // æœ‰é—®é¢˜ æ•°é‡ä¸å¤Ÿ if fast == nil { return nil } fast = fast.Next n-- } // ä¸¤ä¸ªæŒ‡é’ˆå¼€å§‹èµ° for fast != nil { fast = fast.Next pre = pre.Next } pre.Next = pre.Next.Next return newHead.Next} åˆå¹¶ k ä¸ªå·²ç»æ’åºçš„é“¾è¡¨ç±»ä¼¼å½’å¹¶æ’åº 1234567891011121314151617181920212223242526272829303132333435363738394041package classic// mergeKLists åˆå¹¶kä¸ªå·²ç»æŒ‰ç…§å‡åºæ’åˆ—çš„æ•°ç»„func mergeKLists(lists []*ListNode) *ListNode { return merge(lists,0, len(lists) - 1)}func merge(lists []*ListNode, start, end int) *ListNode { if start &gt; end { return nil } if start == end { return lists[start] } mid := (start + end) / 2 left, right := merge(lists, start, mid), merge(lists, mid + 1, end) return mergeTwoList(left, right)}func mergeTwoList(list1 *ListNode, list2 *ListNode) *ListNode { res := new(ListNode) rem := res for list1 != nil &amp;&amp; list2 != nil { if list1.Val &gt; list2.Val { res.Next = list2 list2 = list2.Next } else { res.Next = list1 list1 = list1.Next } res = res.Next } if list1 != nil { res.Next = list1 } if list2 != nil { res.Next = list2 } return rem.Next} ç¿»è½¬é“¾è¡¨ä¸€ç³»åˆ—åè½¬é“¾è¡¨æœ€ç®€å•çš„åè½¬é“¾è¡¨çš„æ€è·¯è‚¯å®šæ˜¯ç›´æ¥ç”¨ä¸€ä¸ª stackï¼ŒFILO çš„æœºåˆ¶æ¥åè½¬ï¼Œè€Œä¸é‡‡ç”¨é¢å¤–çš„ç©ºé—´å¯ä»¥ç”¨ä¸€ä¸‹çš„æ–¹æ³• 12345678910111213141516func reverseList(head *ListNode) *ListNode { // åè½¬åçš„å¤´èŠ‚ç‚¹ var pre *ListNode = nil for head != nil { // ç”¨ä¸€ä¸ª å±€éƒ¨å˜é‡ æ¥ä¿å­˜ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ next := head.Next // åè½¬å½“å‰éå†çš„ head èŠ‚ç‚¹ï¼ŒæŒ‡å‘å·²ç»åè½¬å®Œæ¯•çš„å¤´ç»“ç‚¹ head.Next = pre pre = head // é‡æ–°è®¾ç½® head å¤´ head = next } return pre} åè½¬é“¾è¡¨ IIåè½¬é“¾è¡¨ II æ˜¯åè½¬é“¾è¡¨ä¸‹è¡¨ä» m -&gt; n çš„ä¸€ä¸ªé“¾è¡¨ï¼Œå®é™…ä¸Šé‡‡ç”¨ä¸Šè¿°çš„åè½¬çš„æ“ä½œï¼Œå³å¯åè½¬ m -&gt; n ä¹‹é—´çš„èŠ‚ç‚¹ 1234567891011121314151617181920212223242526272829303132333435363738// ä¸»å‡½æ•°func reverseBetween(head *ListNode, m int, n int) *ListNode { // æ·»åŠ ä¸€ä¸ªæ–°çš„å¤´ç»“ç‚¹ï¼Œä¿éšœåŸæ¥çš„å¤´ç»“ç‚¹è¢«åè½¬æ—¶çš„ç»“æœ newHead := new(ListNode) newHead.Next = head cp := newHead // åˆ†åˆ«ä¿å­˜éœ€è¦åè½¬çš„èŠ‚ç‚¹ä¹‹å‰çš„ä¸€ä¸ªèŠ‚ç‚¹ä»¥åŠæœ€åéœ€è¦åè½¬çš„ä¸€ä¸ªèŠ‚ç‚¹ var preStartNode, endNode *ListNode = nil, nil for i := 0; cp != nil; cp, i = cp.Next, i + 1 { if i == m - 1 { preStartNode = cp } if i == n { endNode = cp } } // ä¿å­˜åè½¬å®Œæ¯•åçš„é“¾è¡¨éœ€è¦è¿æ¥åˆ°çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ afterEndNode := endNode.Next reverseHead, reverseEnd := reverseBetweenNodes(preStartNode.Next, afterEndNode) preStartNode.Next = reverseHead reverseEnd.Next = afterEndNode return newHead.Next}// reverseBetweenNodes reverseä¸¤ä¸ªnodeä¹‹é—´çš„é“¾è¡¨// å…¶ä¸­ startNode ä¸ºå¼€å§‹ç¿»è½¬çš„èŠ‚ç‚¹ endNodeNext ä¸ºç»“æŸç¿»è½¬çš„èŠ‚ç‚¹çš„åä¸€ä¸ªèŠ‚ç‚¹func reverseBetweenNodes(startNode, endNodeNext *ListNode) (*ListNode, *ListNode) { var newHead *ListNode = nil newEndNode := startNode for startNode != endNode { next := startNode.Next startNode.Next = newHead newHead = startNode startNode = next } return newHead, newEndNode} reverse K groupreverse K group çš„æ›´è¿›ä¸€æ­¥ï¼Œåœ¨ä¸Šé¢ä¸€é¢˜çš„åŸºç¡€ä¸Šï¼Œæ¯ K ä¸ªèŠ‚ç‚¹åè½¬ä¸€æ¬¡ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// reverseKGroup kä¸ªä¸€ç»„ç¿»è½¬func reverseKGroup(head *ListNode, k int) *ListNode { newHead := new(ListNode) newHead.Next = head var preStartNode, endNode *ListNode = newHead, nil counter := 0 mov := newHead for mov != nil { if counter == k { endNode = mov afterEnd := endNode.Next // è°ƒç”¨äºŒé¢˜ä¸­æ‰€è¿°çš„å‡½æ•°è¿›è¡Œåè½¬ reverseHead, reverseEnd := reverseBetweenNodes(preStartNode.Next, endNode.Next) preStartNode.Next = reverseHead reverseEnd.Next = afterEnd // å› ä¸ºåè½¬ä¹‹åè¦é‡æ–°è®°å½• preStartNode counter = 0 // åè½¬ä¹‹åçš„éœ€è¦å†æ¬¡åè½¬çš„å¤´æ˜¯ä¸Šæ¬¡åè½¬çš„å°¾ç»“ç‚¹ preStartNode = reverseEnd // é‡æ–°å®šä½ç§»æ ‡ mov = reverseEnd } mov = mov.Next counter++ } return newHead.Next}// reverseBetweenNodes reverseä¸¤ä¸ªnodeä¹‹é—´çš„é“¾è¡¨// å…¶ä¸­ startNode ä¸ºå¼€å§‹ç¿»è½¬çš„èŠ‚ç‚¹ endNodeNext ä¸ºç»“æŸç¿»è½¬çš„èŠ‚ç‚¹çš„åä¸€ä¸ªèŠ‚ç‚¹func reverseBetweenNodes(startNode, endNodeNext *ListNode) (*ListNode, *ListNode) { var newHead *ListNode = nil newEndNode := startNode for startNode != endNodeNext { next := startNode.Next startNode.Next = newHead newHead = startNode startNode = next } return newHead, newEndNode} æ ‘æ ‘çš„éå†ä¸­åºéå†123456789101112131415161718func inorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := list.New() for root != nil || stack.Len() != 0 { for root != nil { stack.PushBack(root) root = root.Left } if stack.Len() &gt; 0 { root = stack.Remove(stack.Back()).(*TreeNode) res = append(res, root.Val) root = root.Right } } return res} å‰åºéå†12345678910111213141516171819202122package classicimport &quot;container/list&quot;func preorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := list.New() for root != nil || stack.Len() &gt; 0 { for root != nil { res = append(res, root.Val) stack.PushBack(root) root = root.Left } if stack.Len() &gt; 0 { root = stack.Remove(stack.Back()).(*TreeNode) root = root.Right } } return res} ååºéå†12345678910111213141516171819202122232425262728293031func postorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := list.New() // æ ‡è¯†è¿™ä¸ªnodeæ˜¯ä¸æ˜¯ç¬¬äºŒæ¬¡è®¿é—® stackForFlag := list.New() for root != nil || stack.Len() &gt; 0 { for root != nil { stack.PushBack(root) stackForFlag.PushBack(false) root = root.Left } if stack.Len() &gt; 0 { root = stack.Remove(stack.Back()).(*TreeNode) flag := stackForFlag.Remove(stackForFlag.Back()).(bool) // è¯´æ˜æ˜¯ç¬¬äºŒæ¬¡è®¿é—® è¿™ä¸ªæ—¶å€™è¦è®¿é—®çˆ¶äº²èŠ‚ç‚¹ if flag { res = append(res, root.Val) root = nil } else { // ç¬¬ä¸€æ¬¡è®¿é—® stack.PushBack(root) stackForFlag.PushBack(true) root = root.Right } } } return res} å±‚æ¬¡éå† æ™®é€šå±‚æ¬¡éå† 123456789101112131415161718192021222324252627282930313233func levelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } tmp := make([]int, 0) queue := list.New() queue.PushBack(root) queue.PushBack(nil) for queue.Len() &gt; 0 { node := queue.Remove(queue.Front()) if node == nil { cp := make([]int, len(tmp)) copy(cp, tmp) res = append(res, cp) if queue.Len() == 0 { break } queue.PushBack(nil) tmp = make([]int, 0) continue } top := node.(*TreeNode) if top.Left != nil { queue.PushBack(top.Left) } if top.Right != nil { queue.PushBack(top.Right) } tmp = append(tmp, top.Val) } return res} zigzag çš„å±‚æ¬¡éå† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package classicimport &quot;container/list&quot;func zigzagLevelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } isLeft := true tmp := make([]int, 0) queue := list.New() queue.PushBack(root) queue.PushBack(nil) for queue.Len() &gt; 0 { top := queue.Remove(queue.Front()) if top == nil { cp := make([]int, len(tmp)) copy(cp, tmp) res = append(res, cp) if queue.Len() == 0 { break } isLeft = !isLeft tmp = make([]int, 0) queue.PushBack(nil) continue } node := top.(*TreeNode) if node.Left != nil { queue.PushBack(node.Left) } if node.Right != nil { queue.PushBack(node.Right) } // è¿™ä¸ªåœ°æ–¹å¯ä»¥è¿™æ ·åŠ å…¥ å°±ä¸ç”¨å† top == nil ä¸­é‡æ–°åè½¬æ•°ç»„ if isLeft { tmp = append(tmp, node.Val) } else { tmp = append([]int{node.Val}, tmp...) } } return res} å‰ç¼€æ ‘å®ç°ç”¨å­—ç¬¦ä¸²çš„å‰ç¼€æ¥ç´¢å¼•çš„ç»“æ„æ ‘ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Trie ä¹‹é—´é€šè¿‡ å­—ç¬¦ å…³è” ä¸Šä¸€ä¸ª trie ä¼šé€šè¿‡å­—ç¬¦ä½œä¸ºè¾¹è¿æ¥ä¸‹ä¸€ä¸ªèŠ‚ç‚¹type Trie struct { data []*Trie // å­˜å‚¨ç´¢å¼•ç»“æ„çš„æ•° å› ä¸ºåªåŒ…å« a-z çš„å­—æ¯ ç´¢å¼•ç›´æ¥æ•°ç»„å³å¯ ä¸ç„¶ç”¨ map ä¼šæ›´å¥½ isEnd bool // æ˜¯å¦ç»“æŸèŠ‚ç‚¹}/** Initialize your data structure here. */func Constructor() Trie { return Trie{ data: make([]*Trie, 26), isEnd: false, }}/** Inserts a word into the trie. */func (this *Trie) Insert(word string) { tmp := this for _, char := range word { if tmp.data[char-'a'] == nil { tmp.data[char-'a'] = &amp;Trie{ data: make([]*Trie, 26), isEnd: false, } } tmp = tmp.data[char-'a'] } tmp.isEnd = true}/** Returns if the word is in the trie. */func (this *Trie) Search(word string) bool { tmp := this for _, char := range word { if tmp.data[char-'a'] == nil { return false } tmp = tmp.data[char-'a'] } return tmp.isEnd}/** Returns if there is any word in the trie that starts with the given prefix. */func (this *Trie) StartsWith(prefix string) bool { tmp := this for _, char := range prefix { if tmp.data[char-'a'] == nil { return false } tmp = tmp.data[char-'a'] } return true} å›¾å¹¶æŸ¥é›†çš„æ•°æ®ç»“æ„å¹¶æŸ¥é›†ï¼Œè¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªæ ‘å½¢çš„ç»“æ„ å¦‚å›¾æ‰€ç¤ºï¼Œé’ˆå¯¹å›¾çš„ä¸€ä¸ªæå¤§è¿é€šåˆ†é‡ï¼Œä¼šå½¢æˆä¸€ä¸ªå¯¹åº”çš„æ ‘ç»“æ„ï¼ˆå¹¶æŸ¥é›†åªå…³æ³¨ä¸€ä¸ªè¿é€šåˆ†é‡æœ‰å¤šå°‘è¿æ¥ç‚¹ï¼Œä¸å…³æ³¨å†…éƒ¨çš„å…¶ä»–çš„ç»†èŠ‚ï¼‰ æ‰€ä»¥é’ˆå¯¹æŸ¥æ‰¾è¿é€šåˆ†é‡æœ‰å“ªäº›ï¼Œä»¥åŠè¿åŒé‡é—´çš„å…³ç³»æœ‰ä½œç”¨ å¹¶æŸ¥é›†å­˜å‚¨æ•°æ®çš„ç»“æ„123type Union struct { parents []int // å­˜å‚¨æ ‘çš„æ•°æ®ç»“æ„ parents[i] è¡¨ç¤ºè¿æ¥åˆ°è¯¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹çš„ç´¢å¼• å¦‚æœä¸èƒ½ç”¨ int æ¥è¡¨ç¤º å¯ä»¥è€ƒè™‘ map ç±»çš„æ•°æ®ç»“æ„} å¹¶æŸ¥é›†çš„æ“ä½œ union (è”åˆï¼Œå…³è”ä¸¤ä¸ªç‚¹) find (æŸ¥æ‰¾ï¼Œæ‰¾åˆ°å½“å‰ç‚¹çš„æœ€ç»ˆçš„çˆ¶èŠ‚ç‚¹) æ‰€ä»¥ï¼Œå®é™…ä¸Š å¦‚æœ r1 r2 ä¹‹é—´æœ‰è¿æ¥çº¿çš„è¯ï¼Œè¦å…³è” r1 r2 çš„æ“ä½œå°±æ˜¯ã€‚ å°±æ˜¯é€šè¿‡ find æ‰¾åˆ°åˆ†åˆ«çš„æ ¹èŠ‚ç‚¹ r1Root r2Root åœ¨é€šè¿‡ union æ–¹æ³•å…³è”ä¸¤ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå®é™…ä¸Šå°±æ˜¯å°† r2Root ä½œä¸ºä¸€ä¸ªå­èŠ‚ç‚¹ï¼ŒæŒ‚è½½åˆ° r1Root ä¸‹ æ‰€ä»¥æ•´ä½“çš„æ•°æ®ç»“æ„ä¸º 12345678910111213141516171819202122232425262728293031323334353637type unionFind struct { Parents []int Count int // è¡¨ç¤ºè¿é€šåˆ†é‡çš„å¤šå°‘}func NewUnionFind(size int) *unionFind { res := &amp;unionFind{ Parents: make([]int, size), Count: size, } // åˆå§‹åŒ–å¹¶æŸ¥é›†ä¸­çš„æ¯ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹éƒ½æ˜¯è‡ªå·± for i := 0; i &lt; size; i++ { res.Parents[i] = i } return res}func (u *unionFind) union(i, j int) { iRoot := u.find(i) jRoot := u.find(j) if iRoot != jRoot { u.Parents[jRoot] = iRoot // æ¯æ¬¡è¿æ¥ä¸€ä¸ªä¹‹å æœ€å¤§è¿é€šåˆ†é‡å°±è¦ -- u.Count-- }}func (u *unionFind) find(i int) int { if u.Parents[i] == i { return i } return u.find(u.Parents[i])}func (u *unionFind) GetCount() int { return u.Count} è¿é€šç½‘ç»œçš„æ“ä½œæ¬¡æ•°é¢˜ç›®æ‰€è¿°ï¼Œç»™å®šä¸€ä¸ªå›¾ï¼Œæ‰¾åˆ°å°†å…¶æ‰€æœ‰æœ€å¤§è¿é€šåˆ†é‡è¿é€šæ‰€éœ€æ›´æ”¹çš„æœ€å°‘çš„è¾¹çš„æ•°é‡ä¸ºå¤šå°‘ã€‚ å›¾çš„æ‰€æœ‰æœ€å°è¿é€šä¸ºä¸€ä¸ªæ ‘ï¼Œå³éœ€è¦ n ä¸ªèŠ‚ç‚¹æœ‰ n - 1 æ¡è¾¹ã€‚ æ‰€ä»¥é¢˜ç›®å…¶å®æ˜¯è¦æ‰¾åˆ°è¿™ä¸ªå›¾é‡Œé¢æœ‰å¤šå°‘ç‹¬ç«‹çš„è¿é€šåˆ†é‡ï¼Œç„¶ååˆ¤æ–­å…¶æ˜¯å¦å¯ä»¥è¿æ¥ ç¬¬ä¸€ç§æ€è·¯å°±æ˜¯ç›´æ¥ dfs éå†ï¼Œæ‰¾åˆ°æ‰€æœ‰çš„è¿é€šåˆ†é‡ã€‚é¦–å…ˆåˆ¤æ–­è¾¹çš„æ•°é‡æ˜¯å¦è¶³å¤Ÿ n - 1 è¿™ä¸ªæ—¶å€™ï¼Œå¦‚æœæœ‰å¤šä¸ªè¿é€šåˆ†é‡ï¼Œè¯´æ˜æŸä¸ªè¿é€šåˆ†é‡ä¸€å®šæœ‰å¤šçš„è¾¹ï¼Œéšæ„é€‰å–å…¶ä¸­çš„è¾¹å³å¯ 123456789101112131415161718192021222324252627282930313233343536373839404142434445package classic// makeConnected æ–¹æ³•æŸ¥çœ‹func makeConnected(n int, connections [][]int) int { // æœ€çŸ­çš„è¯è‚¯å®šæ˜¯å½¢æˆä¸€æ£µæ ‘ æ‰èƒ½è”é€šæ‰€æœ‰ // æ‰€ä»¥ è¾¹ è‡³å°‘è¦è¾¾åˆ° n - 1 çš„æ•°é‡ // è¿™ä¸ªæ—¶å€™ä¸èƒ½è¿é€š if len(connections) &lt; n-1 { return -1 } // map çš„é‚»æ¥è¡¨è¡¨ç¤º cMap := make(map[int][]int) for _, connection := range connections { if _, ok := cMap[connection[0]]; !ok { cMap[connection[0]] = make([]int, 0) } cMap[connection[0]] = append(cMap[connection[0]], connection[1]) if _, ok := cMap[connection[1]]; !ok { cMap[connection[1]] = make([]int, 0) } cMap[connection[1]] = append(cMap[connection[1]], connection[0]) } // åˆ°è¿™é‡Œçš„æ—¶å€™ ç”±äºè¾¹çš„æ•°é‡å¤Ÿ æ‰€ä»¥ä¸€å®šæ˜¯å¯ä»¥è¿é€šçš„ // è¿™ä¸ªæ—¶å€™ åªéœ€è¦çŸ¥é“æœ‰ m å—æ˜¯ä¸ç›¸è¿çš„ ç„¶åå°±çŸ¥é“éœ€è¦è¿æ¥çš„æ¬¡æ•°å°±ä¸º m - 1 memo := make([]bool, n) res := 0 for i := 0; i &lt; n; i++ { if !memo[i] { res++ dfs(memo, cMap, i) } } return res - 1}func dfs(memo []bool, cMap map[int][]int, start int) { memo[start] = true for _, next := range cMap[start] { if !memo[next] { dfs(memo, cMap, next) } }} å¹¶æŸ¥é›†ï¼Œæ‰¾åˆ°æ¯ä¸ªç¾¤ç»„çš„æ•°æ®çš„ä¸€ä¸ªä»£è¡¨ç‚¹ 12345678910111213141516171819202122232425262728293031323334353637383940414243// findRoot æ‰¾åˆ°æ ¹èŠ‚ç‚¹func findRoot(parents []int, index int) int { if parents[index] == -1 { return index } return findRoot(parents, parents[index])}// makeConnected å¹¶æŸ¥é›†func makeConnected(n int, connections [][]int) int { if len(connections) &lt; n - 1 { return -1 } // å¹¶æŸ¥é›†çš„ parents æ•°ç»„ï¼Œæ ‡è¯† å½“å‰ç´¢å¼•çš„ èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹çš„ç´¢å¼•æ˜¯è° // ç›¸åŒçš„æ•°æœ€åå‡èƒ½æ‰¾åˆ°åŒæ ·çš„çˆ¶èŠ‚ç‚¹ parents := make([]int, n) // åˆå§‹åŒ–æ‰€æœ‰çš„ä¸º -1 for i := 0; i &lt; n; i++ { parents[i] = -1 } // æ‰§è¡Œ union çš„æ“ä½œ for _, connection := range connections { sRoot := findRoot(parents, connection[0]) eRoot := findRoot(parents, connection[1]) // ä¸¤ä¸ªç‚¹ä¸Šæœ‰è¿æ¥çº¿ ä½†æ˜¯ç°åœ¨è¿˜æ²¡æœ‰è¿æ¥èµ·æ¥ // è®©å…¶æ ¹èŠ‚ç‚¹ç›¸è¿ if sRoot != eRoot { // å°† e èŠ‚ç‚¹è¿æ¥åˆ° s ä¸Š parents[eRoot] = sRoot } } // å‰©ä¸‹çš„è¿˜æ˜¯ -1 çš„å°±ä¸€å®šæ˜¯æ•´ä¸ªç¾¤é‡Œé¢çš„ä»£è¡¨èŠ‚ç‚¹ res := 0 for _, val := range parents { if val == -1 { res++ } } return res - 1} ç”±æ–œæ åˆ’åˆ†åŒºåŸŸé‡‡ç”¨å¹¶æŸ¥é›†ï¼Œä½†æ˜¯è¿™é“é¢˜æœ‰ç‰¹æ®Šçš„åœ°æ–¹ã€‚ é¢˜ç›®ä¸­æ‰€ç¤ºï¼Œé’ˆå¯¹ä¸€ä¸ªæ–¹æ ¼æœ‰ / å’Œ \\ ä¸¤ç§ï¼Œå¦‚ä¸‹ ---- ---- |\\ | | /| | \\| |/ | ---- ---- æ€»ä¹‹ï¼Œé’ˆå¯¹ä¸€ä¸ª æ–¹æ ¼ ï¼Œå¯ä»¥æŠŠä»–çœ‹æˆå››ä¸ªéƒ¨åˆ† é‚£ä¹ˆï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ å¦‚æœå½“å‰ char == â€˜ â€˜ è¡¨ç¤º 0 1 2 3 éƒ½æ˜¯è”é€šçš„ å¦‚æœ char == â€˜\\â€˜ è¡¨ç¤º 01 23 åˆ†åˆ«è¿é€š char == â€˜/â€˜ è¡¨ç¤º 03 12 åˆ†åˆ«è¿é€š å†…éƒ¨çš„è¿é€šå®Œæ¯•åï¼Œ è¿˜å¯ä»¥çŸ¥é“ 1 ä¸€å®šè·Ÿä¸‹ä¸€ä¸ª 3 è¿é€š 2 ä¸€å®šè·Ÿä¸‹ä¸€è¡Œçš„ 0 è¿é€š 1234567891011121314151617181920212223242526272829303132333435363738394041424344// regionsBySlashes é€šè¿‡æ–œæ åˆ’åˆ†func regionsBySlashes(grid []string) int { // n * n çš„çŸ©é˜µçš„é•¿åº¦ length := len(grid) // ä¸ºäº†ä½¿ç”¨ å¹¶æŸ¥é›† å°†ä¸€ä¸ª1*1 çš„æ­£æ–¹å½¢ï¼Œå³ ä¸€ä¸ª grid[i] æ ‡è¯†çš„åŒºåŸŸåˆ†æˆ å››ä¸ªåœ°æ–¹ // ç„¶åå†æ ¹æ® / \\\\ ä¸¤ä¸ªç¬¦å·çš„ä½ç½®è¿›è¡Œåˆå¹¶ æœ€åçœ‹æœ‰å‡ ä¸ªèŠ‚ç‚¹ unionSize := 4 * length * length u := NewUnionFind(unionSize) for i, str := range grid { for j, char := range str { // 0 å·ä½ç½® uIndex := 4 * (i*length + j) // åŒä¸€ä¸ªå•å…ƒæ ¼é‡Œé¢çš„è¿æ¥èµ·æ¥ switch char { // 0 1 2 3 éƒ½è¦è¿æ¥èµ·æ¥ case ' ': u.union(uIndex, uIndex + 1) u.union(uIndex + 1, uIndex + 2) u.union(uIndex + 2, uIndex + 3) case '\\\\': // åæ–œæ çš„è¯ 01 23 åˆ†åˆ«è¿æ¥ u.union(uIndex, uIndex + 1) u.union(uIndex + 2, uIndex + 3) case '/': // æ–œæ çš„è¯ 03 12 åˆ†è´è¿æ¥ u.union(uIndex, uIndex + 3) u.union(uIndex + 1, uIndex + 2) } // å•å…ƒæ ¼å¤–é¢çš„è¿æ¥èµ·æ¥ // ä¸ç®¡æ˜¯ \\\\ è¿˜æ˜¯ / è¿™ä¸ªåŒºåŸŸçš„1ä¸€å®šå¯ä»¥å’Œå³è¾¹ä¸‹ä¸€ä¸ªåŒºåŸŸ( j+ 1)çš„ 3 è¿æ¥ // è¿™ä¸ªåŒºåŸŸçš„ 2 ä¸€å®šå¯ä»¥å’Œä¸‹è¾¹(i + 1)ä¸‹ä¸€ä¸ªåŒºåŸŸçš„ 0 è¿æ¥ if j + 1 &lt; length { u.union(uIndex+1, 4*(i*length+j+1)+3) } if i + 1 &lt; length { u.union(uIndex+2, 4*((i+1)*length+j)) } } } return u.GetCount()} æ°´ä½ä¸Šå‡çš„æ³³æ± ä¸­æ¸¸æ³³è¿™é“é¢˜æ²¡æƒ³æ˜ç™½æœ€å¼€å§‹ï¼Œè‚¯å®šæ˜¯æ˜ç™½è¦çŸ¥é“åˆ°ä»€ä¹ˆæ—¶å€™ [0,0] è·Ÿ [n - 1, n - 1] çš„å³ä¸‹è§’ç›¸è¿ ç›¸è¿çš„åˆ¤æ–­å¯ä»¥é€šè¿‡å¹¶æŸ¥é›†å®ç° é‚£ä¹ˆå°±è¦è§£å†³å‡ ä¸ªé—®é¢˜ï¼š æ€ä¹ˆéå† å¹¶æŸ¥é›†è¿æ¥çš„æ¡ä»¶æ˜¯ä»€ä¹ˆ æ€ä¹ˆæŠŠäºŒç»´æ•°ç»„çš„ä½ç½®æŠ½è±¡åˆ°ä¸€ç»´ ä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢å…¥æ‰‹ é¢˜ç›®ä¸­æ‰€è¿° grid ä¸­çš„æ•°å€¼ä» [0, nn-1] çš„å”¯ä¸€æ•°å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªæ ¼å­çš„é«˜åº¦éƒ½æ˜¯ç‹¬ç«‹çš„ï¼Œå› æ­¤åªéœ€è¦éå†é«˜åº¦ï¼Œåœ¨éå†é«˜åº¦ä¸­å¦‚æœ [0, nn-1] ç›¸è¿ï¼Œå³å®Œæˆè¿æ¥ ç”±äºé¢˜ç›®ä¸­ å½“éå†çš„ä½ç½®è¾¾åˆ°ä¸€ä¸ªé«˜åº¦çš„æ—¶å€™ï¼Œä»–å¯ä»¥ç›´æ¥å’Œä¸Šä¸‹å·¦å³ä¸Šçš„ç›¸è¿ï¼Œä¹Ÿå°±æ˜¯è¯´éå†åˆ°é«˜åº¦æ›´é«˜çš„åœ°æ–¹èƒ½å¤Ÿç›´æ¥æ¯”é«˜åº¦æ›´ä½çš„åœ°æ–¹è¿æ¥ è€Œé¢˜ç›®ä¸­çš„ grid çš„æ£‹ç›˜çš„äºŒç»´æ•°ç»„å¯ä»¥é€šè¿‡ç®€å•çš„ n*x+y æŠ½è±¡åˆ°ä¸€ç»´ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package classicfunc union(parents []int, i, j int) { iRoot, jRoot := findRootOfParents(parents, i), findRootOfParents(parents, j) if iRoot != jRoot { parents[jRoot] = iRoot }}func findRootOfParents(parents []int, i int) int { if parents[i] == i { return i } return findRootOfParents(parents, parents[i])}func isConnectedParents(parents []int, i, j int) bool { return findRootOfParents(parents, i) == findRootOfParents(parents, j)}var ( // è¡¨ç¤ºä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ DIRECTIONS = [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}})func swimInWater(grid [][]int) int { if grid == nil { return -1 } n := len(grid) index := make([]int, n*n) for i := 0; i &lt; n; i++ { for j := 0; j &lt; n; j++ { // å› ä¸ºé¢˜ç›®ä¸­æ‰€è¿°ï¼Œgrid é‡Œé¢çš„æ•°å€¼ä» 0 -&gt; n * n - 1 // æ‰€ä»¥è®©é«˜åº¦ä½œä¸ºä¸‹æ ‡ç´¢å¼• æ–¹ä¾¿ä¸‹é¢éå† index[grid[i][j]] = n*i + j } } // grid çš„äºŒä½æ•°ç»„ å¯ä»¥è½¬ä¸º n * i + j çš„ä¸€ç»´åæ ‡ parents := make([]int, n*n) for i := 0; i &lt; n*n; i++ { parents[i] = i } for i := 0; i &lt; n*n; i++ { x, y := index[i]/n, index[i]%n for _, direction := range DIRECTIONS { newX, newY := x+direction[0], y+direction[1] // å› ä¸ºè¿™ä¸ªæ˜¯ä»é«˜åº¦ç›¸è·åªæœ‰1çš„åœ°æ–¹å¼€å§‹çš„ æ‰€ä»¥å¯ä»¥ç›´æ¥å…³è” // è¿™æ ·å½“ 0 n - 1 è¿æ¥åˆ°ä¸€èµ·çš„æ—¶å€™ è¯´æ˜å·²ç»è¾¾åˆ°çš„æœ€å°çš„é«˜åº¦ // åªæœ‰æ–°çš„èŠ‚ç‚¹çš„é«˜åº¦ å°äº å½“å‰çš„é«˜åº¦ æ‰æ˜¯å¯ä»¥æ¸¸è¿‡å»çš„ï¼ï¼ï¼ if !(newX &lt; 0 || newX &gt;= n || newY &lt; 0 || newY &gt;= n) &amp;&amp; grid[newX][newY] &lt;= i { // index çš„ç´¢å¼•ç”¨åœ¨è¿™ä¸ªåœ°æ–¹ union(parents, index[i], newX*n+newY) } if isConnectedParents(parents, 0, n*n-1) { return i } } } return -1} æ‹“æ‰‘æ’åº é€†åç»­æ’åˆ— éå†å‡ºåº¦ä¸º 0 çš„ç‚¹ è¯¾ç¨‹è¡¨è¿™é“é¢˜æœ¬è´¨ä¸Šå°±æ˜¯æ‹“æ‰‘æ’åº ç®€å•çš„åšæ³•å°±æ˜¯ç”¨ dfs å»åˆ¤æ–­æ˜¯å¦æˆç¯ 1234567891011121314151617181920212223242526272829303132333435363738394041func canFinish(numCourses int, prerequisites [][]int) bool { // æœ‰å‘å›¾ mapOfCourses := make([][]int, numCourses) for i := 0; i &lt; numCourses; i++ { mapOfCourses[i] = make([]int, 0) } for _, prerequisite := range prerequisites { mapOfCourses[prerequisite[1]] = append(mapOfCourses[prerequisite[1]], prerequisite[0]) } // ä¿å­˜å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹ è¿™æ ·å¯ä»¥é¿å…é‡å¤è®¿é—® totalMemo := make([]bool, numCourses) for i := 0; i &lt; numCourses; i++ { if !dfsCanFinish(mapOfCourses, make([]bool, numCourses), totalMemo, i) { return false } } return true}// é€šè¿‡ dfs çš„æ–¹æ³•åˆ¤æ–­æ˜¯å¦æˆç¯// ç”¨ memo æ¥è®°å½•ä¸€æ¬¡å¾ªç¯ä¸­è®¿é—®çš„èŠ‚ç‚¹func dfsCanFinish(mapOfCourses [][]int, memo, totalMemo []bool, start int) bool { if totalMemo[start] { return true } totalMemo[start] = true memo[start] = true for _, adj := range mapOfCourses[start] { if !memo[adj] { // æˆªæ–­ æœ‰ç¯ç›´æ¥è¿”å› if !dfsCanFinish(mapOfCourses, memo, totalMemo, adj) { return false } } else { // è¿™ä¸ªåœ°æ–¹å°±æ˜¯æ‰¾åˆ°äº†ç¯ return false } } memo[start] = false return true} æ‹“æ‰‘æ’åº éå†å…¥åº¦ä¸º 0 çš„ç‚¹ 1234567891011121314151617181920212223242526272829303132333435363738func canFinish(numCourses int, prerequisites [][]int) bool { // å…¥åº¦ä¸º 0 çš„ç‚¹ä¸ºèµ·ç‚¹ inDegree := make([]int, numCourses) for _, prerequisite := range prerequisites { // è®©æœ‰å‘å›¾çš„æ¥å—çº¿çš„ä¸€ç«¯ å…¥åº¦++ inDegree[prerequisite[0]]++ } // ä¿å­˜å…¥åº¦ä¸º 0 çš„ç‚¹ inDegreeEqualZero := list.New() for i, in := range inDegree { if in == 0 { inDegreeEqualZero.PushBack(i) } } // éå†å…¥åº¦ä¸º 0 çš„ç‚¹ // æ¯æ¬¡åˆ é™¤ä¸€æ¡è¾¹ åˆ¤æ–­ä¸‹ä¸€ä¸ªç‚¹ æ˜¯å¦å…¥åº¦ä¸º0 å…¥åº¦ä¸º 0 åŠ å…¥åˆ° map ä¸­ ä¸åœçš„éå† ç›´åˆ°æ²¡æœ‰ç‚¹ for inDegreeEqualZero.Len() &gt; 0 { node := inDegreeEqualZero.Remove(inDegreeEqualZero.Front()).(int) for _, prerequisite := range prerequisites { if node == prerequisite[1] { inDegree[prerequisite[0]]-- if inDegree[prerequisite[0]] == 0 { inDegreeEqualZero.PushBack(prerequisite[0]) } } } } for i := 0; i &lt; numCourses; i++ { // è¿™ä¸ªåœ°æ–¹è¯´æ˜è¿˜æœ‰ç‚¹ç›¸è¿ï¼Œå› æ­¤æ˜¯æ— æ³•å®Œæˆçš„ if inDegree[i] != 0 { return false } } return true} æ‚é¢˜é€’å¢çš„ä¸‰å…ƒå­åºåˆ—é¦–å…ˆæƒ³åˆ°å˜›ï¼Œç”¨ä¸¤ä¸ªæ•°ç»„åˆ†åˆ«å­˜å‚¨ä»å·¦åˆ°å³çš„æœ€å°å€¼å’Œæœ€å³åˆ°å·¦çš„æœ€å¤§å€¼ï¼Œé‚£ä¹ˆå¦‚æœ nums ä¸­ä¸€ä¸ªæ•° num å¤§äºè¿™ä¸ªæœ€å°å€¼å°äºè¿™ä¸ªæœ€å¤§å€¼ï¼Œæ˜¯ä¸€å®šå¯ä»¥çš„ 123456789101112131415161718192021222324252627282930313233343536func increasingTriplet(nums []int) bool { if len(nums) == 0 { return false } mins, maxes := make([]int, len(nums)), make([]int, len(nums)) mins[0] = nums[0] for i := 1; i &lt; len(nums); i++ { mins[i] = min(mins[i-1], nums[i]) } maxes[len(nums)-1] = nums[len(nums)-1] for i := len(nums) - 2; i &gt;= 0; i-- { maxes[i] = max(maxes[i+1], nums[i]) } for i, num := range nums { if num &gt; mins[i] &amp;&amp; num &lt; maxes[i] { return true } } return false}func max(a, b int) int { if a &gt; b { return a } return b}func min(a, b int) int { if a &lt; b { return a } return b} äºŒåˆ†æ‰¾å‡ºç¬¬ k å°çš„è·ç¦»å¯¹è·ç¦»å·®å®šä¹‰ä¸º æ•°ç»„ä¸­ ä»»æ„ä¸€å¯¹æ•°ä¹‹é—´çš„å·®çš„ç»å¯¹å€¼ å› æ­¤æ‰¾åˆ°ç¬¬ K ä¸ªæœ€å°è·ç¦»ï¼Œä¸€ä¸ªç›´è§‚çš„è§£æ³•å°±æ˜¯ï¼Œéå†æ‰€æœ‰çš„å·®ï¼Œæ”¾å…¥åˆ°åªæœ‰ k ä¸ªæ•°çš„å¤§é¡¶å †ä¸­ï¼Œé‚£ä¹ˆå †é¡¶éƒ½æ˜¯ç»“æœã€‚ï¼ˆmemory çˆ†äº†ï¼‰ 12345678910111213141516171819202122232425262728293031323334353637type IntHeap []intfunc (h IntHeap) Len() int { return len(h) }func (h IntHeap) Less(i, j int) bool { return h[i] &gt; h[j] }func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }func (h *IntHeap) Push(x interface{}) { // Push and Pop use pointer receivers because they modify the slice's length, // not just its contents. *h = append(*h, x.(int))}func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x}// æ‰¾åˆ° nums ä¸­ç¬¬kå°ä¸€å¯¹æ•°ä¹‹é—´çš„æœ€çŸ­è·ç¦»ï¼ˆè·ç¦»ä¸ºä¸¤æ•°ä¹‹å·®ï¼‰// heap outOfMemoryfunc smallestDistancePairWithHeap(nums []int, k int) int { hp := &amp;IntHeap{} heap.Init(hp) for i := 0; i &lt; len(nums); i++ { for j := i + 1; j &lt; len(nums); j++ { heap.Push(hp, int(math.Abs(float64(nums[i]-nums[j])))) if hp.Len() &gt; k { heap.Pop(hp) } } } return (*hp)[0]} å¦å¤–ä¸€ä¸ªæƒ³æ³•å°±æ˜¯äºŒåˆ† äºŒåˆ†çš„èŒƒå›´æ˜¯ä»å·®å€¼çš„èŒƒå›´å‡ºå‘ï¼Œå³ 0 -&gt; max(nums) - min(nums)ï¼Œé‚£ä¹ˆ max min å¯ä»¥ç›´æ¥æ’åºå–é¦–å°¾å³å¯ ä½†æ˜¯å¦‚ä½•ç»Ÿè®¡ï¼ŒäºŒåˆ†ä¸­å°äº mid çš„å·®å€¼çš„æ•°é‡ ä»¥ [1,2,2,3,4] ä¸ºä¾‹ï¼Œå›ºå®šå³è¾¹ç•Œä¸º 4 çš„æ—¶å€™ 1 -&gt; 4 ä¸­é—´å¯èƒ½å°äº k çš„æ•°å­—ç»„åˆä¸º [1,4] [2,4] [2,4] [3,4] å…¶ç»“æœä¸º j - i = 4 - 0 (4 çš„ä¸‹æ ‡ 4 1 çš„ä¸‹æ ‡ 1) 12345678910111213141516171819202122232425262728293031323334353637383940func smallestDistancePair(nums []int, k int) int { if len(nums) == 0 { return -1 } sort.Ints(nums) // i, j è¡¨ç¤ºçš„æ˜¯ nums ä¸­çš„ æ•°æ®å·® çš„èŒƒå›´ i, j := 0, nums[len(nums)-1] - nums[0] for i &lt; j { // mid è¡¨ç¤ºçš„æ˜¯ä¸­é—´çš„å·®å€¼ mid := i + (j - i) / 2 // æ‰¾åˆ°å°äºç­‰äº mid çš„æ•°å€¼å·®çš„æ•°é‡ count := findDistancePair(nums, mid) if count &gt; k { j = mid - 1 } else if count &lt; k { i = mid + 1 } else { // å› ä¸ºæ˜¯å°äºç­‰äº æ‰€ä»¥å¯èƒ½ mid æ˜¯è§£ ä¹Ÿå¯ä»¥æ˜¯åœ¨å·¦è¾¹ j = mid } } return i}func findDistancePair(nums []int, distance int) int { res := 0 // å›ºå®šå³è¾¹ç•Œ i, j := 0, 0 for j &lt; len(nums) { // ç»Ÿè®¡å‡ºæ¥çš„æ˜¯å°äºç­‰äº distance çš„æ•°é‡ for i &lt; j &amp;&amp; nums[j] - nums[i] &gt; distance { i++ } // å› ä¸ºæ˜¯é€’å¢çš„ å¦‚æœè¿™ä¸ªæ—¶å€™ 1,2,2,3,4 ç›¸å½“äºå›ºå®šå³è¾¹ç•Œ é‚£ä¹ˆæ’åºå®Œçš„æ•°ç»„ å·¦è¾¹èƒ½å¤Ÿå½¢æˆçš„æ»¡è¶³æ¡ä»¶çš„æ•°å¯¹ åº”è¯¥æ˜¯ j - i ä¸ª res += j - i j++ } return res} å­—å…¸æ ‘çŒœå­—è°œæš´åŠ›è§£æ³•ï¼Œç”¨ word å»åŒ¹é… puzzle çš„ set è¶…æ—¶äº†ã€‚ è€ŒåŸé¢˜ç›®ä¸­ words çš„æ•°é‡æ¯” puzzles çš„æ•°é‡é«˜ä¸€ä¸ªæ•°é‡çº§ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ å­—å…¸æ ‘ å‹ç¼© word çš„æ•°é‡ï¼Œç”¨ puzzle è¿›è¡Œæ¯”è¾ƒ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private class TrieTree { int currency; TrieTree[] child; public TrieTree() { this.currency = 0; // å› ä¸ºåªåŒ…å«å°å†™å­—æ¯ this.child = new TrieTree[26]; } public void add(char[] word) { TrieTree cur = this; for (char c : word) { if (cur.child[c - 'a'] == null) { cur.child[c - 'a'] = new TrieTree(); } cur = cur.child[c - 'a']; } // currency è¡¨ç¤ºæœ‰ä¸€ä¸ª word åˆ°è¾¾äº†è¿™ä¸ªåº• cur.currency++; }}public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { // å› ä¸ºå®é™…ä¸Šå¹¶ä¸åœ¨æ„ word çš„é¡ºåº è€Œä¸”æ ¹æ®é¢˜ç›®è¦æ±‚ word ä¸å®šé•¿ è€Œä¸”æ¯” puzzle å¤§ å› ä¸º puzzle æ˜¯ 7 ä¸ºå›ºå®šé•¿åº¦ // æ‰€ä»¥å›ºå®š word ä¸º å­—ç¬¦æ ‘ TrieTree root = new TrieTree(); // åŠ å…¥å­—å…¸æ ‘ä¸­ç›¸å½“äº å‹ç¼©äº† words for (String word : words) { // æ’åºå»é‡åŠ å…¥ å› ä¸ºè¿™æ ·æ‰èƒ½ç»Ÿè®¡ currency å¹¶è¿›è¡Œå‹ç¼© root.add(getCharArray(word)); } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(puzzles.length); for (int i = 0; i &lt; puzzles.length; i++) { res.add(0); } // æ¯”è¾ƒ puzzle ä¸ å­—å…¸æ ‘ // puzzle æœ€å¤§æ·±åº¦ä¸º 7 // æœ€ååªéœ€è¦åŠ ä¸Š currency å³å¯ for (int i = 0; i &lt; puzzles.length; i++) { char[] puzzleArray = getCharArray(puzzles[i]); char required = puzzles[i].charAt(0); res.set(i, recursionSearch(root, puzzleArray, 0, required)); } return res;}// puzzle å»åŒ¹é…å­—å…¸æ ‘ æ‰¾åˆ°ä¸€ä¸ª èŠ‚ç‚¹ è¿”å›å…¶ currency å³å¯¹åº”çš„ word æ•°é‡public int recursionSearch(TrieTree node, char[] puzzleArray, int pos, char required) { if (node == null) { return 0; } // puzzle æœ€æ·±å°±æ‰“åˆ°è¿™å„¿ if (pos == puzzleArray.length) { return node.currency; } // å¯ä»¥é€‰æ‹©ç”¨å½“å‰ pos è¿™ä¸ªä½ç½®æ¥åŒ¹é… ç„¶åéƒ½ ++ int res = recursionSearch(node.child[puzzleArray[pos] - 'a'], puzzleArray, pos + 1, required); // å› ä¸ºå»é‡äº† æ‰€ä»¥ required ç­‰äºçš„æ—¶å€™ ä¸€å®šè¦åŒ¹é… // ä¸ç­‰äºçš„æ—¶å€™ï¼Œå¯ä»¥ç»´æŒ node å¼•ç”¨ ç„¶åä¸åŒ¹é… è·³è¿‡ puzzle çš„è¿™ä¸ªå­—ç¬¦ ç»§ç»­å¾€ä¸‹èµ° if (puzzleArray[pos] != required) { // + æ˜¯å› ä¸º å¯ä»¥ç”¨å¤šæ¡è·¯èµ° å®é™…ä¸Šå°±æ˜¯è¦æˆ–è€…ä¸è¦ res += recursionSearch(node, puzzleArray, pos + 1, required); } return res;}public char[] getCharArray(String word) { char[] tmp = word.toCharArray(); Arrays.sort(tmp); int newIndex = 0; int l = 0, r = 0; while (r &lt; tmp.length) { while (r &lt; tmp.length &amp;&amp; tmp[r] == tmp[l]) { r++; } tmp[newIndex++] = tmp[l]; l = r; } char[] res = new char[newIndex]; System.arraycopy(tmp, 0, res, 0, newIndex); return res;}","link":"/2021/01/18/leetcode/"}],"tags":[{"name":"code","slug":"code","link":"/tags/code/"},{"name":"æ±‚èŒ","slug":"æ±‚èŒ","link":"/tags/%E6%B1%82%E8%81%8C/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"summary","slug":"summary","link":"/tags/summary/"},{"name":"init","slug":"init","link":"/tags/init/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"ç¬”è¯•","slug":"ç¬”è¯•","link":"/tags/%E7%AC%94%E8%AF%95/"},{"name":"concurrent","slug":"concurrent","link":"/tags/concurrent/"},{"name":"kmp","slug":"kmp","link":"/tags/kmp/"},{"name":"å­—ç¬¦ä¸²","slug":"å­—ç¬¦ä¸²","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"qrcode","slug":"qrcode","link":"/tags/qrcode/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"undergraduate","slug":"undergraduate","link":"/tags/undergraduate/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"å›¾ç®—æ³•","slug":"å›¾ç®—æ³•","link":"/tags/%E5%9B%BE%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"}],"categories":[{"name":"code","slug":"code","link":"/categories/code/"},{"name":"life","slug":"life","link":"/categories/life/"},{"name":"tutorial","slug":"tutorial","link":"/categories/tutorial/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","link":"/categories/%E7%AE%97%E6%B3%95/"}]}
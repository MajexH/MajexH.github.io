{"pages":[{"title":"关于我","text":"苦逼学生党 读研中","link":"/about/index.html"}],"posts":[{"title":"18年年终总结","text":"&emsp;&emsp;18 年年终总结虽然会迟到，但永远不会缺席 回顾 2018 年 考研 （是不是该算到 2017 呀）2333 考研复试 本科毕业 毕业设计&amp;答辩 读研 助教 实验室项目 学习前端基础 搭建博客（姑且现在算是搭了个雏形出来了） 补 java 基础（算了买了书 还没看完的感觉） 算法（算是准备开始补基础吧） spring boot &amp; spring cloud（了解下现在较“新”的微服务架构吧） 考研初试&emsp;&emsp;从 17 年上半年开始准备到 17 年 12 月 22 号考试,整个 17 年都在复习中度过。本来开始的准备如下： 17 年上半年过完数二的两门数学的第一遍 &amp; 英语的单词 暑假 \b 过第二遍强化 &amp; 复习政治 9 月份开始过数学的第三遍 &amp; 各科的往年试题（包括数一）&amp; 专业课 &emsp;&emsp;结果最后变成了： 上半年半摸鱼状态，结果最后只把高数的上半册给复习完做完题；英语的单词也大概背了一半 暑期学校还规定必须自主实习，自己找实习。于是乎整个暑假大部分是咕咕咕状态。毕竟找了老师实验室，接了一个活儿，从零开始入门 \bjava web。幸而在室友的帮助下还是顺顺利利的交差走人。 虽说暑假还去报了个数学的复习班，花费了 2K 大洋复习两周，感觉还非常一般，大部分自己看书做题的时候都能总结 \b 出来，只有一道题和一个极限四则运算的条件印象深刻。总之就是 \b 着实不太值，如若真需要补习，还不如报全程班（甚至线代是边上课边复习的）（每天上课都是坐最后面两排，然而不是因为去得晚，只是因为\b前面的是留给VIP和全程班的，每个位置上还有编号，真是太真实了） 从 9\b\b 月份中下旬开始着手第二遍数学复习 + 政治复习。每天上午 10 点起床（反正也不去图书馆抢位置）背两个小时单词，吃完饭去自习，晚上 10 点回来，12 点睡觉 期间找了一位 dalao 去 \b 一起复习，不得不说没开暖气之前的主楼和主南 10 月份和 11 月份是真的冷 11 月开题直接被否，1 月重开 最后不得不说肖秀荣老师 🐂🍺，甚至还记得考试前几天在主楼走道背肖四的感觉，不得不说最后还是挺稳的 emmm，因为我们系的专业课考试是 C 语言和数据结构，花了一周时间做了做往年的题目，最后结果也颇为满意 &emsp;&emsp;考研的 \b 初试还是全凭实力的，大家都在同一个起点上，做同一个卷子，颇有一种高考的感觉，可是却也回不到高考的状态了（虽说高考也不想再经历了）。最后总结初试的经历，感觉还是有几点可以说一下： 每年的考试范围都会在研招网上公布，要考研首先去了解自己考啥，具体都是啥 如果你对自己的初试有 \b 安排，那么你一定要了解一下学校在大三和大四的安排，因为你永远不知道学校会在什么时候给你扔一堆莫名其妙的事儿来 政治早点开始好，9 月后开始的我，那两个月痛不欲生，每天复习得第一件事儿就是背政治，背不下去了，各种数学题泡着。重复着政治=&gt;数学=&gt;政治的无限循环 因为时间的关系，我是不可能有大量的时间练习英语写作啥的，于是英二就靠着考研单词和最后两个月的突击写作练习撑起来，最后结果也算满意，本来也没打算拿高分，事实证明单词也确实重要 专业课，看自己的 \b 学校的情况吧 复试&emsp;&emsp;18 年 3 月初就是准备复试，各类专业课准备呀啥的，反正咱也没上机啥的。其他也没啥好说的，只是当时毕设老师人招满了，另外联系了一位导师，也就是我现在的导师。\b&emsp;&emsp;PS：如果你初试高，又联系了老师…… 本科毕设&emsp;&emsp;说实话，当我从毕设老师手里面第一次拿到这个题目的时候，觉得不难嘛。可各种技术都不太会，外加还要去针对当前项目提出一种可行的解决方案。当时的我确实做不到 现在好像也不一定。毕竟咱们软件工程，引用百度百科如下 软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。 百度百科baike.baidu.com/item/软件工程/25279 简言之就是需要针对用户需求做出用户满意软件制品。 &emsp;&emsp;虽说整个毕设过程中，开题、二次开题、中期和最终答辩都被怼出 shit 了，不过最终还是在学长的帮助下还是写了个 Demo 出来。\b 打心底里是十分感谢当时的那位学长的 从毕设来说。当时的第一版 Demo 是学长写出来的，也是学长给我讲了 \b 他对着这个东西的设计思路和想法。然后在此基础上慢慢完善了这个 Demo（虽然感觉没啥大用）。 从技术来说。当时用的是 Spring boot + Spring Security + Oauth2.0 完成的 Demo，因为整个项目是基于 Spring cloud 的微服务架构，所以使用了能够这些能够方便集成的框架。可以说从 Java Web 以及微服务架构的角度来说，学长给我开了一扇窗。 毕业&emsp;&emsp;\b 天之涯海之角来形容毕业的情况感觉十分贴切。本科的几位室友，一位已经远在美国求学，一位 \b 在同一学校读研。\b&emsp;&emsp;回沙河拍照那天，站在原来的寝室门口，\b 又想起本科刚入学的时候初入北京。独自一人来到学校，到最后毕业的时候，普航 julao、小强、九哥、男神、托儿、儿子……大学也已是给了我太多太多。 读研&emsp;&emsp;战战兢兢地度过了初试、复试、毕设后，最终还是顺利本科毕业读研了。研究生的整体生活给我的感觉是较忙的，老师的项目、学校的课程和考试等等，到寒假最开始的时候（就是现在）还在忙助教期末 \b 成绩的事儿。 项目&emsp;&emsp;第一次接到老师给的项目 \b 应该是在 4 月中旬（\b 巧了，那时候毕设还正开始做）。整体的内容大概是做 NLP（怎么大家都是机器学习，臣妾不会呀），对爬取到的文本的语义实体进行识别，如时间、人等。 &emsp;&emsp;毕竟是老师给的第一个项目，还是颇为重视，花了一个月从零入门机器学习。吴恩达的 coursera 上的和斯坦福大学的公开课程都强行看了一遍，最后得出的结论是 ———— 臣妾看不懂（数学实在是难，特别是概率论）。 &emsp;&emsp;于是转头直接寻找今年的 \bNLP 实体识别实现。还真找到了,16 年的论文，Bidirectional LSTM-CRF实现。于是想通过 python\b 实现这个 \b 思路，再一看 keras、tensorflow 等一堆东西，emmm，还是直接去找别人实现的吧。 &emsp;&emsp;就这样直到七月中旬，终于在把别人的 \b 实现扒下来改改的情况下，通过一个开源的 Word2Vec 的预训练向量集和一个小量的训练集，这东西终于能跑起来并且能识别一定量的 \b 实体了。 &emsp;&emsp;最终这个方案还是失败了。为什么呢？做了这多，到最后一步才发现————没有数据！！爬取的数据没人去手动清洗（工作量太大），而且数据量太小，也不能保证训练出来的正确性。但是项目总得继续，于是乎硬着头皮直接人工清理了爬取的数据，然后做个可视化。本来还想清洗完扔进去训练看看，可当清洗工作快结束时，才发现最开始的清洗方法错了，导致清洗的数据完全无法扔进去训练。于是我的工作就变成了可视化前端+后端。 &emsp;&emsp;对于这个项目，只能用心情复杂来形容了。 暑假&emsp;&emsp;暑假留下来参与了实验室的其他项目（可怜那时候还要去看机器学习），从学姐手里分到了一个还算 \b 不那么困难的部分（感谢下学姐的怜悯）。 &emsp;&emsp;暑假的项目在我的理解上感觉像一个 proxy，各类请求的转发和存储。\bKoa2 实现，于是边学 nodejs、es6、koa2 边写。不得不说 js 写起来就是比 java 感觉简单···毕设的 Demo 写得实在是太难受了。 助教&emsp;&emsp;这学期的另一个大事儿就是当了一门本科课的助教。其实读研之前曾经幻想过当助教（主要是当时也想复习点啥，比如算法？数据结构？）。可真正要去当助教的时候，才觉得十分蛋疼———因为研一又要上课、还有实验室的各种活儿。跟我搭档的另一位助教，经常自嘲为实验室最忙的人，大概是就是因为这些事儿吧。 &emsp;&emsp;当助教，每周都要批改、统计 180 份各位同学的作业。对我来说一个晚上才能勉强改完作业，再花一个晚上才能统计完成。然而助教最难受的地方是 \b 同学们的问题（虽然平时来问的同学不多，期末陡增）。毕竟是两年前的 \b 科目，好多细节都记不太清楚了，可研一的课程、实验室的活儿一做完，根本没啥时间和精力去复习这门课，我只能说对同学们说这门课的助教我尽力了。\b &emsp;&emsp;当然，最后统计期末成绩的 \b 时候还出了一点小纰漏 \b，几位 \b 同学的最后一次签到给计算掉了，只能真诚的给各位同学说一声对不起了（虽然他们也看不到就是了\b）。 学习&emsp;&emsp;整个 18 年可以说是被各种事情 drive 着去学习的一年 考研的时候被自主实习 drive 学了一波 Java Web 被毕设 drive\b 了解了一波 Spring Security、Oauth、Spring Cloud 被项目 drive 学了一波机器学习，虽然最后无疾而终，也让我明白我确实搞不懂机器学习 被项目 drive 学了一波前端，虽然到现在 css 依然是一块痛处 &emsp;&emsp;以上 18 年的学习也让我对自己 19 年的有了一定想法，主要分为面向工程扩充自己吧 工程 设计模式 算法、数据结构 框架 vue spring node 刷题 leetcode? (面向工作学习 23333)","link":"/2019/01/25/18summary/"},{"title":"hash-code","text":"简单实现了 hash 容器分别采用拉链法和开放寻址法 hashsetleetcode 例题，设计一个 hash 集合，不能使用 built-in 的 hash 类 这边使用了开放寻址法简单是实现了一个 hashset，但是没有实现整理以及清除。 开放寻址法，实际上是一个使用数组，根据 key 的 hashcode 进行定位存储。 针对 hash 碰撞，会线性的寻找下一个能够放入的地址放入，而如果 删除其中一个元素，直接将其引用删除的话，会造成碰撞链的断裂，因此删除是使用特殊的标识位来表示的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100 // 不能使用任何 built-in 的 hash 库 private static class Pair { Object val; boolean isDeleted; int hashcode; public Pair(Object val, boolean isDeleted, int hashcode) { this.val = val; this.isDeleted = isDeleted; this.hashcode = hashcode; } } private Pair[] objs; private int size; /** * Initialize your data structure here. */ public MyHashSet() { this.objs = new Pair[16]; } public void add(int key) { if (++size &gt;= this.objs.length) { // 先判断增长 grow(); } int addedIndex = getAddedIndex(key); if (addedIndex != this.objs.length) { this.objs[addedIndex] = new Pair(key, false, Integer.hashCode(key)); return; } // 这个时候也应该 grow 因为没有地方放置了 // 按道理说 这个时候应该去扫描前后 去除无用的引用 grow(); add(key); } private int getAddedIndex(int key) { int i = Integer.hashCode(key) &amp; (this.objs.length - 1); for (; i &lt; this.objs.length; i++) { if (this.objs[i] == null || (int) this.objs[i].val == key || this.objs[i].isDeleted) { return i; } } return i; } private void grow() { int newLen = this.objs.length &lt;&lt; 1; Pair[] objs = new Pair[newLen]; for (Pair old : this.objs) { if (old == null) continue; // 删除的就不管了 if (old.isDeleted) continue; int j = old.hashcode &amp; (newLen - 1); for (; j &lt; newLen; j++) { if (objs[j] == null) { objs[j] = old; break; } } } this.objs = objs; } // 获取 remove contains 的 index // 其实可以用 lambda 表达式来传入不同的函数 将两个 index 整合 private int getOtherIndex(int key) { int j = Integer.hashCode(key) &amp; (this.objs.length - 1); // 开放寻址法 继续往后找 for (; j &lt; this.objs.length; j++) { if (this.objs[j] != null &amp;&amp; (int) this.objs[j].val == key) { return j; } } return j; } public void remove(int key) { int j = getOtherIndex(key); if (j &lt; this.objs.length) { this.objs[j].isDeleted = true; --size; } } /** * Returns true if this set contains the specified element */ public boolean contains(int key) { int j = getOtherIndex(key); if (j &lt; this.objs.length) { return !this.objs[j].isDeleted; } return false; }} hashMapleet code 例题 采用拉链法处理，hash 碰撞连接到原来的链上。 同时现在是采用的头插法来处理的，头插法会在多线程情况下GG，最好不用这样用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157import java.io.BufferedWriter;import java.io.IOException;import java.io.OutputStreamWriter;import java.io.Writer;import java.util.Arrays;import java.util.HashMap;public class MyHashMap { // 拉链法 private static class Node { int key, val; int hashcode; Node next; public Node(int key, int val, int hashcode) { this.key = key; this.val = val; this.hashcode = hashcode; this.next = null; } @Override public String toString() { return &quot;Node{&quot; + &quot;key=&quot; + key + &quot;, val=&quot; + val + &quot;, hashcode=&quot; + hashcode + &quot;, next=&quot; + next + '}'; } } private int DEFAULT_CAPACITY = 16; private Node[] nodes; private int size; // 负载因子 private double factor = 0.75; private int threshold = (int) (DEFAULT_CAPACITY * factor); public MyHashMap() { this.nodes = new Node[16]; } /** * value will always be non-negative. */ public void put(int key, int value) { int hashcode = Integer.hashCode(key); int index = hashcode &amp; (this.nodes.length - 1); if (!headPut(index, hashcode, key, value, nodes)) return; if (++size &gt;= threshold) grow(); } // 返回加入成功或者失败 private boolean headPut(int index, int hashcode, int key, int value, Node[] nodes) { // 头插法插入 Node tmp = nodes[index]; while (tmp != null) { // 找到重复 key 跳出 if (tmp.key == key) { tmp.val = value; return false; } tmp = tmp.next; } Node newHead = new Node(key, value, hashcode); newHead.next = nodes[index]; nodes[index] = newHead; return true; } // 重新定位 private void grow() { int newCapacity = this.nodes.length &lt;&lt; 1; int newThreshold = (int) (newCapacity * this.factor); int oldCapacity = this.nodes.length; Node[] newNodes = new Node[newCapacity]; this.threshold = newThreshold; // 头插法比较简单 但是会有问题 // 实际上用一个 NodeHolder 抓住整个 node 保存 头尾 更方便 for (int i = 0; i &lt; oldCapacity; i++) { Node old = this.nodes[i]; while (old != null) { // 根据原来的 hashcode 进去在新数组的位置 下面这个是由数学特性得到的 int newIndex = (old.hashcode &amp; oldCapacity) == 0 ? i : i + oldCapacity; headPut(newIndex, old.hashcode, old.key, old.val, newNodes); old = old.next; } this.nodes[i] = null; } this.nodes = newNodes; } /** * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ public int get(int key) { int hashcode = Integer.hashCode(key); int index = hashcode &amp; (this.nodes.length - 1); Node tmp = this.nodes[index]; while (tmp != null) { if (tmp.key == key) return tmp.val; tmp = tmp.next; } return -1; } /** * Removes the mapping of the specified value key if this map contains a mapping for the key */ public void remove(int key) { int hashcode = Integer.hashCode(key); int index = hashcode &amp; (this.nodes.length - 1); Node tmp = this.nodes[index]; if (tmp == null) return; // 头是 key if (tmp.key == key) { this.nodes[index] = tmp.next; --size; return; } // 开始删除 Node mv = tmp.next; while (mv != null) { if (mv.key == key) { tmp.next = mv.next; --size; return; } mv = mv.next; tmp = tmp.next; } // 没有找到 } public static void main(String[] args) throws IOException { MyHashMap map = new MyHashMap(); Writer out = new BufferedWriter(new OutputStreamWriter(System.out)); out.write(&quot;[null,&quot;); map.put(504, 155); map.remove(89); out.write(&quot;,&quot; + String.valueOf(map.get(334))); out.flush(); }}","link":"/2021/03/13/hash-code/"},{"title":"hexo静态博客搭建（一）hexo简介&amp;环境","text":"一直以来都有搭建博客的想法，粗略了解了一下WordPress和hexo，\b在尝试过WordPress的安装部署后果断选择了hexo。准备从以下几个方面介绍下hexo的搭建过程 hexo简介 &amp; 环境 hexo命令 &amp; 主题 hexo自动部署 hexo简介我们首先来看看hexo官网对hexo的介绍 超快速度 支持 Markdown 一键部署 丰富的插件 \b简而言之，hexo就是 一个基于nodejs的博客引擎 支持ejs等模板引擎 通过渲染Markdown文件生成博客所需各类静态文件 有较为完整的\b生态支持，包含各种插件，满足大部分需求 所以对于熟悉nodejs的用户能够通过hexo快速搭建一个博客 hexo环境nodejs环境nvm + nrm 可以使用nvm进行nodejs版本切换和管理 国内环境下推荐使用淘宝的npm源cnpm或者使用nrm切换到淘宝源 全局安装hexo-cli1npm install hexo-cli -g 使用包管理器 osx环境下使用homebrew安装 1brew install nodejs git环境windows可以通过访问git官网下载安装包即可 各类linux系等建议通过包管理器下载","link":"/2019/01/26/hexo-1/"},{"title":"Hello World","text":"&emsp;&emsp;建立这个博客只是兴趣所致为了完成18年的既定目标 &amp; 找一个能够写些东西的地方（毕竟工作之余心情烦闷之时？！） &emsp;&emsp;指不定写些啥就咕咕咕了 &emsp;&emsp;谨以此hello world\b纪念下博客正式搭好","link":"/2019/01/23/hello-world/"},{"title":"hexo静态博客搭建（三）hexo自动部署","text":"经过前两步，一个能看的blog已经搭起来了，在本地调试完成后，还是需要一个地方部署这个blog。因为有一个服务器来科学上网，所以就吧这个blog部署到了同一个vps上（这两个应用都不是太吃资源）。所以接下来介绍如何将blog部署到一个远程的服务器上。 自动部署到VPS需要用到的hexo命令hexo是一个部署静态blog的工具，因此所有的文件最后都会被生成浏览器能认识的html、css、js文件。 12hexo cleanhexo deploy 因此需要在部署前使用hexo clean命令，清理已经生成的/public下的静态文件和db.json，再调用hexo deploy命令使用hexo提供的部署命令将本地的静态文件部署到远程服务器。 hexo deploy use rsynchexo deploy提供了多种方式来部署到远程，这里使用了rsync来部署。 需要在服务器端做什么需要注意的是，要求您提供的实际上是一个能通过SSH登陆远程主机的Linux用户。Hexo会自动处理关于rsync使用的一切操作。因此，您需要在远程主机上为您的Hexo站点建立一个用户，并允许其通过SSH登陆。不过，这里的port，的确是指rsync监听的端口，请确保防火墙打开了该端口。 hexo对于rsync的介绍 也就是说rsync需要我们提供一个可以通过ssh登录的用户，这样hexo可以使用该用户通过ssh将需要部署的文件移动到远程服务器上 本地设置在搞定了用户之后我们就需要在blog的配置文件_config.yml中配置deploy选项来启用rsync帮助我们来进行远程部署，如下图所示。 使用git hooks来自动调用hexo deploy在完成了deploy选项的设置后，可以通过hexo deploy命令一键将静态文件远程部署到服务器上，但是每次都需要手动调用下这个命令，同时因为blog放到了github上，所以为了偷个小懒就利用git hooks，在本地commit后，调用hexo deploy命令将本地的文件部署到远程。 首先进入到hooks文件中 1cd .git/hooks 添加以下内容到post-commit文件中，这样每次在本地commit后，都会出发这个hook，调用这个文件中的命令 1234567#!/bin/bashcd /path/to/your/blogecho &quot;----- 开始 -----&quot;hexo cleanhexo generatehexo deployecho &quot;----- 结束 -----&quot; warning:首先需要进入到你的blog的根目录下，这样hexo的命令才会被正确的调用","link":"/2019/05/17/hexo-3/"},{"title":"春招java后端实习岗笔试总结","text":"春招实习生投递小结春招实习生一共投了4家企业，包括字节、美团、阿里和快手，因为两边都相对较多，因此将笔试和面试分开吧 字节倒在了二面 美团刚刚完成了二面 阿里完成了三面(不过我觉得我跟他们需求的方向相对较远，因此希望渺茫) 快手，可能是投递得比较晚，至今(4月24日无任何消息) 因为觉得大部分希望渺茫，所以特地记录下春招的笔试和面试情况，希望有所帮助。 有几家是在牛客网提供的平台上笔试的，不过笔试的方式都是大同小异，保证入口class是Main即可，可以先去牛客网上试试 不保证自己的贴出的代码能够全部AC，仅供参考 阿里阿里的笔试是所有人统一时间参加笔试，我是在4月13日参加的晚上的笔试，抽到的笔试题都是跟图相关的 第一题题目描述一个数组，表示一组动物（动物的下标从1开始），数组中的数值表示仰慕的对象，这个动物可以给自己投票，或者跟自己仰慕的人投同样的票，如果数组中数值为0 那么他只能给自己投票，而且数组中的位置代表了这个动物的能力大小 后面的动物越低，他们只能仰慕前面的动物。 问：每个动物可能拿到的最大的投票数为多少 1234567例：输入[0,1,1,1,1]输出4 1 1 1 1 解释：第一个动物只能给自己投票，所以他给自己投票，而后面的动物仰慕1号动物，因此全部跟自己仰慕的对象投相同的票，即1投自己后，后面的2 3 4 5号动物全跟1投相同的票，投1，因此1号最多4票，其他的只有自己投自己。 例程（笔试中写的代码没有考虑到递归情况，只对了10%） 可能解法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.company;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Scanner;public class First { // 递归的去寻找后面能够投票的是哪些 public static int dfs(HashMap&lt;Integer, List&lt;Integer&gt;&gt; map, int start, boolean[] memo) { List&lt;Integer&gt; temp = map.get(start); memo[start] = true; int res = temp.size(); for (Integer admire : temp) { if (start &lt; admire &amp;&amp; !memo[admire]) res += dfs(map, admire, memo); } memo[start] = false; return res; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] admires = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { admires[i] = scanner.nextInt(); } HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); // 简历崇拜者图 for (int i = 1; i &lt; admires.length; i++) { if (!map.containsKey(i)) { map.put(i, new ArrayList&lt;&gt;()); } if (admires[i] != 0 &amp;&amp; admires[i] != i) { if (!map.containsKey(admires[i])) { map.put(admires[i], new ArrayList&lt;&gt;()); } List&lt;Integer&gt; temp = map.get(admires[i]); temp.add(i); } } System.out.println(map); for (int i = 1; i &lt;= n; i++) { System.out.println(dfs(map, i, new boolean[n + 1]) + 1); } }} 第二题题目描述给定三个参数，3个参数表示，城市数，路径数和目标城市，然后下面有路径数的输入i,j,k，分别表示从i城市到j城市花费的时间是k。 问：如果每个城市都有一个人，那么这些人，到这个目标城市，然后回来，在路上花费的时间的最小值 (ps:实际上就是个最短路径的问题，但是我当时根本就没咋弄过图算法，只了解基本的dfs，bfs和连通分量啥的，因此笔试的时候是用两边dfs做的，存在问题，最短路算法应该去复习一下) 可能解法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.company;import java.util.*;public class Second { static class Pair { public Integer key; public Integer value; public Pair(Integer key, Integer value) { this.key = key; this.value = value; } } public static int resolve(HashMap&lt;Integer, List&lt;Pair&gt;&gt; map, int start, int end, int size) { boolean[] memo = new boolean[size]; return dfs(map, start, end, memo, 0); } public static int dfs(HashMap&lt;Integer, List&lt;Pair&gt;&gt; map, int start, int end, boolean[] memo, int current) { if (start == end) return current; memo[start] = true; List&lt;Pair&gt; temp = map.get(start); int res = Integer.MAX_VALUE; for (Pair tempPair : temp) { if (!memo[tempPair.key]) { res = Math.min(res, dfs(map, tempPair.key, end, memo, current + tempPair.value)); } } memo[start] = false; return res; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(), x = scanner.nextInt(); HashMap&lt;Integer, List&lt;Pair&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; m; i++) { int a = scanner.nextInt(), b = scanner.nextInt(), l = scanner.nextInt(); if (!map.containsKey(a)) { map.put(a, new ArrayList&lt;&gt;()); } List&lt;Pair&gt; temp = map.get(a); temp.add(new Pair(b, l)); } int res = Integer.MIN_VALUE; for (int i = 1; i &lt;= n; i++) { res = Math.max(res, resolve(map, i, x, n + 1) + resolve(map, x, i, n + 1)); } System.out.println(res); }} 美团美团的笔试，我们同学投的前端和后端是一样的，美团的笔试环境跟牛客网差不多，注意一下即可 第一题题目描述给定两个整数n,m。n表示有多少个学生，m表示有多少门课程，接下来输入n行，每行m个，表示这个学生在这门课的得分是多少。 问：每门课获得最高成绩的人（可能有多个）一共有多少个，重复的人在不同的课程中拿第一门，算同一个人。 可能解法（笔试时AC）123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.*;public class MFirst { public static class Pair { public Integer index; public Integer credit; public Pair(int i, int i1) { this.index = i; this.credit = i1; } } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); HashSet&lt;Integer&gt; res = new HashSet&lt;&gt;(); int[][] credits = new int[n][m]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { credits[i][j] = scanner.nextInt(); } } PriorityQueue&lt;Pair&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; b.credit - a.credit); for (int j = 0; j &lt; m; j++) { for (int i = 0; i &lt; n; i++) { queue.add(new Pair(i, credits[i][j])); } if (queue.size() &gt; 0) { int max = queue.peek().credit; Pair temp; while (queue.size() &gt; 0 &amp;&amp; (temp = queue.poll()).credit == max) { res.add(temp.index); } } queue.clear(); } System.out.println(res.size()); }} 第二题问题描述给定一个输入，a、b、m和x。采用一个循环算法，如下 12while (true) x = (a * x + b) % m; 问循环几次，这个算法中x值会跟最开始一样 可能解法（因为没有注意到题目的数据范围，爆了int，AC了65%）1234567891011121314151617181920212223242526import java.util.HashSet;import java.util.Scanner;import java.util.Set;public class MSecond { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(), b = scanner.nextInt(), m = scanner.nextInt(); long x = scanner.nextLong(); int counter = 0; Set&lt;Long&gt; set = new HashSet&lt;&gt;(); while (true) { x = (a * x + b) % m; if (!set.contains(x)) { set.add(x); counter++; } else { break; } } System.out.println(counter); }} 第三题问题描述给定一个输入n和m，接下来输入n个数。 问：如果这个n个数（这n个数有可能重复）进行排列组合会产生n*n的组合（自己可以和自己组合），那么如果将这些组合从大到小排序（排序的规则是对于一个组合[i,j] 如果i相同，则按照j的大小排序，如果i不同，i大的排在前面），问第m小的一个组合是什么 12345678例输入：3 41 2 3输出(2,1) 可能解法(当时AC了)123456789101112131415161718192021222324252627282930import java.util.Arrays;import java.util.Scanner;public class MThird { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); int[] nums = new int[n]; for (int i = 0; i &lt; n; i++) { nums[i] = scanner.nextInt(); } Arrays.sort(nums); int divide; if (m % n == 0) { divide = m / n - 1; } else { divide = m / n; } int counter = 0, counter1 = 0; for (int num : nums) { if (nums[divide] &gt; num) counter1++; if (nums[divide] == num) counter++; } int temp = (m - counter1 * n) / counter; System.out.format(&quot;(%d,%d)\\n&quot;, nums[divide], nums[temp - 1]); }} 第四题问题描述给定一个输入n，k。n表示要输入的数组的数的数量，k表示其中的某个数，然后输入n个数。 问：如果要让k这个数成为中位数，那么需要再往这个数组里面添加几位数才行 12345678例输入4 11 2 2 3输出2 解释：要让1成为中位数，那么就需要再在1前面添加两个数即可成为新数组的中位数 可能的解法（TODO）我当时以为整个数组的输入顺序，包括现在的一切都不能改变，因此我只找了离现在的中心最近的k的位置，然后看看它需要几位数才能到中心（AC 10%） 实际上这道题是一个桶排序，只需要统计小于K的有多少个数，等于K的有多少个数，大于K的多少个数，然后再去跟mid比较，最后得到答案（感谢镇宇dalao） 我的解法 1234567891011121314151617181920212223import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class MFourth { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), k = scanner.nextInt(); int mid = (n + 1) / 2; int[] nums = new int[n]; int remember = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { nums[i] = scanner.nextInt(); if (nums[i] == k) remember = Math.min(remember, Math.abs(mid - i)); } int res = Integer.MAX_VALUE; System.out.println(res); }} 正确的解法(模仿镇宇dalao的思路来的 TODO) 1 第五题问题描述给定两个字符串s1,s2 问：s1子串与s2的的子序列的匹配个数（子串就是说是连续的，子序列就是说是不连续的） 解法方法当时第一反应就是dp，可是没有找到递推公式，普航julao AC了，请教了一下，大致理解了思路，就是用dp[i][j] 表示以s1[i]结尾子串和s2[j]结尾的子序列能够匹配的数量 转移方程的话就是需要考虑s1[i] == s[j],相等就说明我们只需要看dp[i - 1][k](k = 0 ………… j-1)的和+1即可 ，因此最后一位是匹配的，而不等，就直接赋值为0即可 讨论原文：dp[i][j]是s[i]为尾的的子串与t[j]为尾的的子序列的匹配个数 如果s[i] != t[j]那直接就是0了 如果不是的话 那就是以s[i-1]以及所有t[k]（0&lt;=k&lt;=j-1）的匹配个数的和（因为这些匹配的接上s[i] t[j]还是匹配的）再+1（只有这一个位置匹配前面全部不匹配的情况） 代码（TODO） 1","link":"/2020/04/24/interview-1/"},{"title":"hexo静态博客搭建（二）hexo命令&amp;主题","text":"简单说下常用的命令 hexo命令hexo 安装nodejs环境安装完成后，在全局下安装hexo\b-cli，命令如下 1npm install -g hexo-cli hexo-cli安装完毕后才可以执行hexo命令 hexo init1hexo init [folder] folder是当前博客目录，通过hexo init命令可以在指定的folder目录下自动克隆一个hexo项目模板（一个nodejs项目），并自动安装相应的依赖，其目录文件结构如下. ├── _config.yml - hexo的相关配置信息 ├── db.json ├── node_modules - nodejs依赖 ├── package.json - nodejs项目信息 ├── scaffolds - 发布模板 ├── source - 存放用户资源，如文章等 └── themes - 主题，会根据主题生成 、对应的页面 \bhexo server通过hexo init命令建立博客模板文件后，其自带了landscape主题，可以通过hexo server直接启动 hexo new1hexo new [layout] &lt;title&gt; 新建一个名为title的文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替 hexo publish1hexo publish [layout] &lt;filename&gt; hexo将文章组织为draft和post两种状态，因此在使用了hexo new draft someFile后需要通过hexo publish命令将处于draft下的文章正式发表，这样才能在blog中正常查看。 hexo generate &amp; hexo deployhexo generate会将markdown文件等一系列的文件编译转换成标准的静态文件。hexo deploy命令会将本地生成的静态文件一键部署到远程服务器。 hexo 主题hexo提供了丰富的主题，这个blog使用了icarus 安装 如果blog通过git来进行版本控制，可以直接通过git安装1git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 可以去其github页面上下载release包，解压到themes/icarus下 微调样式大部分对于样式的微调都能在issues页面找到 阅读页面三栏转二栏 添加about页面icarus将about页面挂载在了网页的/about页面123cd blog根目录/sourcemkdir abouttouch index.md 中文设置 icarus自带中文设置1vim blog根目录/_config.yml 将language项调整成zh-CN，hexo会自动加载themes/icarus下的i18n文件 导航栏中文设置修改/themes/icarus下的_config.yml将 添加comment插件icarus提供了对于gitalk、Valine等评论插件的支持，这个blog使用了valine对评论插件 valine申请创建应用申请leancloud 应用申请成功后将下列key填入icarus下的_config.yml中 添加valine人数统计在添加valine的comment组件的时候，发现valine支持文章的浏览数量统计，考虑添加valine阅读数量统计。找到layout/comment/valine.ejs，添以下到else block中 1234&lt;span id=&quot;&lt;Your/Path/Name&gt;&quot; class=&quot;leancloud-visitors&quot; data-flag-title=&quot;Your Article Title&quot;&gt; &lt;em class=&quot;post-meta-item-text&quot;&gt;阅读量 &lt;/em&gt; &lt;i class=&quot;leancloud-visitors-count&quot;&gt;1000000&lt;/i&gt;&lt;/span&gt; 123456(function () { var span = document.getElementsByClassName('leancloud-visitors')[0]; span['id'] = window.location.pathname; // 貌似 title 有bug // span.dataset.flagTitle = document.title;})(); span的id会作为valine统计的主键，所以直接填入每个location对象的pathname即可，即可做出阅读量统计","link":"/2019/03/06/hexo-2/"},{"title":"java多线程(一)","text":"一直以来，对于java的多线程变成都不是十分了解，趁着项目需要一个多线程的爬虫学习了一下，主要是一些基础的相关知识，以上。 Runnable和Thread踩的第一个坑是关于实现Runnable接口和继承Thread类来build一个新的可运行线程。 12345678910111213141516// Runnable接口定义public class MyRunnable implements Runnable { private int count = 5; @Override public void run() { System.out.println(this.count--); }}// Thread类定义public class MyThread extends Thread { private int count = 5; @Override public void run() { System.out.println(this.count--); }} 1234567// 启动public static void main(String[] args) { while (int i = 0; i &lt; 5; i++) { new MyRunnable().run(); // new MyThread().start(); }} 在main中分别启动两个类的5个线程，可以看到Runnable接口并没有实际上的并发的启动几个线程，而是在第一个线程执行完毕之后，再去执行第二个线程，阻塞式地执行完new出来的5个线程，究其原因，是因为Runnable接口实际上并不是实际的Thread的入口，Runnable接口只是定义了Thread的任务逻辑，也就是说Runnable接口中的run()方法只是实现了现在需要的业务逻辑，实际的多线程仍然需要通过Thread类开始。 多线程的执行在实际的线程执行的时候，较为传统的做法是通过new Thread(new Runnable()).start()来执行，然而新建线程实际上也是一个较为繁重的操作，以下是反编译的Thread类代码 123456789101112131415161718192021222324public synchronized void start() { if (this.threadStatus != 0) { throw new IllegalThreadStateException(); } else { this.group.add(this); boolean started = false; try { this.start0(); started = true; } finally { try { if (!started) { this.group.threadStartFailed(this); } } catch (Throwable var8) { } } }}private native void start0(); 以上可以看出，Thread类的start()方法，最终调用了native的start0()，最终通过JNI(java native interface)调用底层提供的pthread_create方法，最终进入linux系统提供的创建线程的接口。 在javase 1.5提供了一个Concurrent的包来提供方便运行的多线程类库，如提供运行的ExecutorService，提供线程安全的各类Blocking Queue、Blocking List、Concurrent List等，以及一些原子操作类库。 其主要通过ExecutorService来启动需要执行的线程 12345678910111213// 创建无限大的线程池，当任务到来的时候ExecutorService e1 = Executors.newCachedThreadPool();// 创建指定pool size的线程池ExecutorService e1 = Executors.newCachedThreadPool(int poolSize);// 创建一个指定pool size的定时线程池ExecutorService e3 = Executors.newScheduledThreadPool(int poolSize);// 创一个执行单个线程的ExecutorService e4 = Executors.newSingleThreadExecutor();// 通过submit方法可以将需要执行的Runnable Callable接口实现类启动e1.submit(() -&gt; { // do something}) 任务通过ExecutorService提交到指定的线程池，或者执行线程中异步的执行，即submit函数不会阻塞主线程的执行，最终子任务的逻辑会异步的在新线程中执行 但是如果主线程依赖子线程的运行结果，在submit方法执行后，返回了一个Future对象，Future对象可以在主线程中控制子线程 12345678910111213141516171819ExecutorService ex = Executors.newCachedThreadPool();Future f = ex.submit(() -&gt; { try { Thread.sleep(10000) } catch (Exception e) { e.printStackTrace(); }})// 获取子线程的运行结果f.get()// 在1s之后get没有返回执行结果 即没有执行完毕 则出发timeout 可以通过这种方式来对一些任务做超时处理try { f.get(1000, TimeUnit.MilliSeconds)} catch(TimeoutException | InterruptedException | ExecutionException e) { e.printStackTrace();}","link":"/2019/12/10/javaConcurrent/"},{"title":"kmp","text":"算法书上使用的是 有限状态机 来描述的 kmp 算法。 之前学习的是通过前后缀匹配的方式来做的 kmp 算法。 现在记录一下。 参考：阮一峰 blog 前后缀匹配实际上 kmp 的思想就是在字符串失配的时候，跳过一定的距离，就可以不用重置模式串的指针到开头。 如 字符串 a b a b a b a b c a 模式串 a b a b a b c a kmp a b a b a b c a 如上所示，在失配的时候(红色所示)，会找到前面字符串中相同长度的前缀和后缀(绿色所示)，这样在匹配的时候，就可以直接跳过这些长度的前后缀，向右移动 6 - 4 = 2 位长度即可。 那么实际上 kmp 的原始运算算法就可以得到了 1234567891011121314151617181920public int kmp(String origin, String pattern) { // 获得 kmp 数组 int[] next = getNext(String pattern); int i = 0, j = 0; while (i &lt; origin.length() &amp;&amp; j &lt; pattern.length()) { if (origin.charAt(i) == pattern.charAt(j)) { i++; j++; } else { // 因为有相同的前后缀 所以直接赋值 就找到模式串相等的前缀的位置 j = next[j]; } } // 返回开始的 index if (j == pattern.length()) return i - j; // 没有找到匹配 return -1;} 而 next 数组的求法，实际上是 pattern 字符串自己跟自己匹配，找到相等的前后缀的长度 以 a b a b a b c a 为例 字符串 前缀 后缀 匹配的最大长度 a [] [] 0 a b [a] [b] 0 aba [a, ab] [a, ba] 1（a 与 a 匹配） abab [a, ab, aba] [bab, ab, b] 2 (ab 匹配) ababa [a, ab, aba, abab] [baba, aba, ba, a] 3(aba 匹配) …… …… …… …… 上面的表格表示了前后缀的匹配情况，下一步就是求得这个前后缀匹配长度的 next 数组 12345678910111213141516171819public int[] getNext(String str) { int n = str.length(); int[] next = new int[n]; next[0] = -1; // 让模式串错位一个开始 kmp 的匹配过程 int k = -1, j = 0; while (j &lt; n - 1) { if (k == -1 || str.charAt(k) == str.charAt(j)) { k++; j++; next[j] = k; } else { // 根据已经匹配的长度 重新定位 k = next[k]; } } return next;}","link":"/2021/03/07/kmp/"},{"title":"签到二维码生成","text":"做这个东西的灵感来自于[lufer blog]('http://coder.lufer.cc/2018/06/11/%E7%8C%AB%E9%80%94%E6%A0%A1%E5%9B%AD%E7%AD%BE%E5%88%B0%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%BC%AA%E9%80%A0/')以及室友的微信小程序拆包帮助 做这个事儿的原因嘛，最近老师准备派出去出差去学习 2 周，但是人出去了，课还是要上的，尤其是杜博士的课又在最近开了。杜博士还是有点怕的，而好巧不巧杜博士又喜欢用微信小程序的猫途校园来进行二维码签到，所以才有了做这个东西的动力和原因。 猫途校园签到二维码生成去年已经有学长大致做过了这个二维码的伪造签到，粗略的看了一下，大概对面只是在二维码里面明文放了一个课程ID&amp;学生ID&amp;&amp;当前时间的三元组，通过在一两秒的时间内不断变换当前时间来变化二维码，达到必须在现场才能签到的目的。可是咱另外给你生成一个二维码不就行了嘛，23333。 问题这周，专门截图了一个签到二维码来扫码试试，扫码结果如下。 1x%97%C5%94joj%97%93%92%98ggf%60%60f%9C%C8%C6%C7%94a%95%8B%5B%98%C7%C6%9Bke%98%98chni%95%92%60foo%99%9Anm%99%89Wfjloqljnnikp%5D%u5F46%uC46F%uC8C6 嗯？！！这和说好的有点不太一样呀，不是说好的明文存储嘛。在看到%后面跟着数字的时候，果断猜想是使用了 js 的encodeURI()来转换了一下无法在浏览器路径栏里面识别的字符，然后果然···猜错了。 小程序反编译（这时候又要膜一波室友了）在尝试了常见了编码和加密方式都没办法拿到加密信息后，在室友的帮助下吧微信小程序反编译拿到了源代码。(微信小程序会在本地缓存一个.wxapkg的文件，该文件可以反编译出源代码，反编译工具)（以后就算他的加解密方法变了，仍然可以通过这种方法重新拿到他的加解密方法）。总值最后拿到的加解密方法如下。 1234567891011121314151617181920212223// 加密function encrypt(str) { for ( var t = String.fromCharCode(str.charCodeAt(0) + str.length), n = 1; n &lt; str.length; n++ ) { t += String.fromCharCode(str.charCodeAt(n) + str.charCodeAt(n - 1)); } return escape(t);}// 解密function decode(str) { str = unescape(str); for ( var t = String.fromCharCode(str.charCodeAt(0) - str.length), n = 1; n &lt; str.length; n++ ) t += String.fromCharCode(str.charCodeAt(n) - t.charCodeAt(n - 1)); return t;} 总体来说就是通过 js 来产生了 unicode 码的偏移，在加密时，除了第一位偏移了字符串长度的位数，其他的均是偏移了后一个位置的位数。唯一不懂的是escape()和unescape()方法，一查，这两方法都已废弃···，与之对应的是 encodeURI()和decodeURI()。于是将之前扫码拿到的字符串丢进去解码，可以得到 现在变成了一个四元组(&amp;分隔)，第三个是标准的 unix 时间戳，因此我们只需要拿到四元组的其他三个信息，然后自己生成一个时间戳，就可以生成跟他完全一样的二维码了。最后它每 3 秒钟生成一次二维码，不超过 5s 的时间差就接受该二维码。 自己写了个生成的页面，需要上传一个自己的签到截图，就会每 1s 中在页面中生成一个二维码和分享链接，把分享链接发送给在教室的大佬们帮忙签到即可。实例如下majexh.xyz/qrcode","link":"/2019/05/17/maotuQrcode/"},{"title":"一些吐槽","text":"4d5b354008a79032227bf4d2dcfc8ac348f0e256e558eca4a30f845895870ce8fb5e8f8fb0907b486c29aa2a1c5cfe43a0705892748bdafa18044d53171cc282a0158f686b95a14bcaf0529f57c540003c62a7154aa095f6ec434dc400a39f688aa811682f6add45ab148d3b3db137d2504a6ba23d02bf8e27fcf15870338c4189be78f818213f6d0522cdd8c983de66fb311b49504a97e808e3f21cb7db10b53ca9b3923add8b1fdbbabfa5505967f64ec0ff60944b56fae433a1a74f7511ca8f8484fd9e4c481bac1c5829892916b279fe4a04d6650e7345a86eec364bb88cc1ce5b9ec114091d2db12cf261a8b4c313c5279a406feac438b048099a81be4ccd0e527e5545c2addecac06e02f4259258e053a883f827d340a069c2e6dc79cba72c5e343b07f7fb171ed5d5a7f6959bbc4ec8b7d56865439f31bb687714f6aabb20f004b8f27c03a695740f8f25f1c4f0798638972112bcb01278020cb2f89b6f8dad32a32e44d30138ef398f48e664ac41e3ff2b7d229e32562a738bb1bb3666a21a1a15cbb514b0058c93ba847b27e2aa44b16ee36138e3471e09d4753074a8c22d35dc22984534e293d8710ab2390695a782c21421e260949d26f064bb2042b1eb9b6eb0ae2eb3c703f0bc8dfd570ae6e64bcf5d4108bde72bee146f5e74d4feaed1084dae44bc28f68195647dd0c66257794f96a29f123328ef4ce41794ad0221ae1a32a8d20ccb7ca9f48b046b66a992abdbd182a94fba8688137e73aad952d6551255bf24338bb63fc044529af044db22ff678bb676397f297d2b549c73ce8aa848a18af352b3bc5478ce6fab9a7310c71d441218457c40a7e16191c7a98ea448ff0e6a30fd22c5bdf1296217d60093d531fd138917a6c497ec6fef4cd3b7ce973d957b9f0083e175c3c392053854791752186d1ae1d0cfd23665ea1f81dfcc0d8c3a647cbee8698e8df8838632342bd3bed47ba0efcadaafcfb625dab57f98a2a0a7aaef180e83c39395a0f78ab3c0c20873785277ad190341831ae827000c9266e624852fbb029e4361bcbdead34af7a9e45a5503459f16bb7cffdd828c6cd17a7178b479d734860935147cc0b3a8752204e62c22332eb5ef60c1e940fb83cff797bfa0e0638b64ac3dd5033f877669bc3bd8fb00e190728a0e5ca524581466ebac3e6be2f356ad33f31c58e06fa9d381c4ca0d2c1f37262df51e24cfe0b82db1556c713298204522c5c1fd68f0b3d9c9624988c71e15374570ffa63ed576d998d0c667c90f4e2b6c14e43f4f0d7845b15afd741653752c4185d9753baacd2030daebe63adc3298129ca30acbbb20de0eae03e7537329e899bb8044499cdc58aaa0eb586261f0fa27d63372cd6b7c57735c0e8ec8735a514cb2ad3918bbe9424eb9acd8deaf9ca50518d905e79581401fd37da4b950e63f80269aa498b0f98dfad2786f19b2af0813f5c4877c8fcfcf6c8e105686cf5e206ec2ac3411b57299a22317cbf5aa898f3bd2b3a2d5aa983545c0a1d427f114405ae63f8d1929ccc6575f64a417cb61ebad62e5972f566504b0f1b0b434656fe94427f40b77526e4706d083378101c4cba3c1d1fa63c6005e34b0422a483e6e71eb2c0b6a77d7399bab425594cb11593f933f6ee0646b7fb1fd26e148b0908356d9ad990f1fa1cc5a6e0f1a2b7b5e50de6f4d27d8bd5d3c282fb8217891689671d82878fea61049e4d28e2b1a5212f3e19dcb1a48d982a2d4d2c6d9ac4fe5f9c0eb3ac13b31bbbe188340703d3821ae4fd53216c1238d96296f91ce3b70bd22f84cd96b047738bea76f779a9ab11180e23dd59e45dfdc8ca08770872c0b585cb2467618882ee089b0b497e01a1b889e2300a983e90cf7077703eed7bb3575435c612946c469de05bdaba01a37aede9c4d949cdfbde171917c49d933c790a6980a2c02fff811f725174c5c16f8799db9336a47d19e8c700627f5c55727b6faa41a0d6c2664044f0ed693536cd1f7d78fc7630c4e6e46ddc6d54854cae7da43dc257d4f183d728ad961fb3aed31255385cb403b3c6df996b7a57645ea608f8e452e5eeb9b38eb372434c1c66b7b203a4dfb80c55f5ab17ed7a94a84e955a2a91c76ee066cb72544cde387a7f8a20ac2c4d8e7653d2940780e637bfa5d6022b9d246d561c99f985bbc1a62aec6a1874a96ad20f0434ed6e77120ea669fdf4d685b09faf6e98c2ec5992d90676927f5fcf53c4601c666795731946e67b2d71f2d52cb6ae91e4155d735bc069610459d814103a0c72eec23569413a268853f5a8f4947e7430664a2648aa1c57cec3ca37559ffdb43ae1dee24c039b66bf660bfdd0ae7aecbb9b95dc1f1d6a2ab44f915fb1b7396d350b72bb8a4d42f60c085f40aaed15be042475efe8a59c2e087875f747c2f9d3820659e985a78e7e3f28a9b13142c033d7c5c303fe436286eb6aeff8030b6157d4208d4e863e089c6d85027dc20f94c372d9cc3f07733a1282a59390c6b7acfb5a7eea9968ea701e812fb5f1350d37e4544f67533ddd45b4092e404eac1439aea27efc5bf008d1660ba7563185f1f173e8e4b9c06befb0379e21fc595f97619944ae9ecfeb13ed9663c36886d68daebc3f7e711d9f25e75802119d69e3c3827f71bb43df7fab27e25b165a2b8a452394fec9e0728f4d25e129cbb36d31e7854bd9d4693e3a37d1820aef9084547dacf914f74f40b50a597dbff19ffd07ff6150de3e26d58a1109727b4bf8800d928bb38ac236dde1638567af7dd8ad952841930ddfabcba921bad528c9adae8276429c0bb17c0c94b050183a670302a5a248e5c8a08e3858d7fcc5090a543b33f71f516ff8f08a494dadafd151a657d906ef916a36a08f41f57b3e25ccb00b50340cb7e39c711ca8d34a9f4e016a338edc18e04a68dc0f04135ec3d3f31198d50853b3ff0edbbd9860ca9c81eafd302e5fc4437c60d5ebbdf68a38ce6c3f83c78405efc213fa97eb0c794b6dd05ffdc5f1fb077d586a2e6253c836517ad099ff05e0aebe0f3e6647feba34a82698baf06f712a85e78c96dcda8c0e8a638e33d608f42674b40b86baaa8a4733aa7b848e4e5e09a5c40e77fab935376631db73555c16b2b38a696a802e3a6e8ed370af64ca5a0faf274e092ed71d1c4db0c62e67b1c714963ec16ccda1959d8ba6712d350b0a9a2c3db51f456b3badd8906d8f0888f48333c51724a3680a615d0a2f3973ba48dddb52723d6291802348a199a59f8bc38017439d2209133740c6b9e8f78c0ea9df1d575db892f6e0ca9d4afbe629536872a8f01f0e2479f4b785b09702924e4a739666d0a5bb247f8f504401891ce00c527b7fad8b74faed7fd74fe93189601ec046d2527d2736c5719b72d96fd06a3670b0d230fbb15a90e8c433a1141061a5fc45cc34a000bd0bc202b9d14e53fd78368421f3222a55c5f0fcd26dbf2c544d8b2f13926bdaf1801762ccdb04725cc998788ec31d0737ef3bb5409261ebe4990e689b9a38dd3cbb4dc45e90a22642b2b87ffaaab1aba29af1fc44212f6c7e13f19cb0fe6be9cdb99baf0bb3108a2e85dfc0f8b67b35298ff1b4bbf61356a14b5ab9b89e0c31ac728216a6aacb5a53ef039c3cdd4daec86f5f41b3f641cd46f7e285793f2cb26128ca14b05546f9ec7966e0438f4db8c014b2c0273689378ed09e519f4e7267a1d5471814f277a955cb1baee7676a3b17c03988c2aee7bbd7ecac07b8b737049f1817f4a1ca9a76a98f5834eafe5d2c593b6ec5e4348a1c6d7d83a1005258a28677c254e9565c05ae2c57d157040dfc2098b7066cbb17b6a7d36b4f127dd6ca8bb0db615d760f8929aa53b75856b954c5fe0fae0bf5b5c210903dc14d09ac01622cd59fcb03dca7ca20bf5b0365978a91e3c3f5fde00d155aa0a68471c5ae2f65f788b8e58e865122c91db123aeb6de64a3addbf563b79427ad1c2c35537518c3e1b2da839c070bd7d3f9a16f91cf474dd55fac9d00922b7fd6701497dd88e9dcd75a1addeefc49046f0be0ddff92afd7dfca598ac58c7ad90b3a5e8a0e8f0294e866520e3e78a7c3a077e95d2d6a7703318832db8b3c5f54e8c4dc39c18ae57576777f0b4b697560c5ee566248f812cc6512388f6e12ed462da3116e81de74ede576d6b91e8d1294cdc7e312ffdda47448e004aa4e1bea540f68359a28dbef30dbcaf3a08b6eb4a8f7464ede227148bdfd07f1a1871330f0bee4b596223cf9f58de545ac9e7a1c9f3fa37048573a0a57208fb358ef319276887fec7dcff3df6d1cbe5c80320c0b47b25b4ee8aa456d4fe68d971a7254e964b039d2abdce999f682deab5f8638545e2fbce9f8ab351874332300c6c1f08c97d7f11788824c3489e92394b833ea2bc4831c023a48400d5282a4116ade049eb4072131ecd78b36e62ad5c7a4777f5985192a41fdc5f67f435c3cf88cd5c0e8bf6afe1aacdfda46518f3d2d35365ef414c90181d88d9f3d533453b60c5860fac4097303120b65858d92f7069590bfe95a16556c1a3d2959629c205dfb1f5e90fb506f0812e34a9a7f928d176a57edeef33f3ed331b5a7f646ea799ac6be92ae3a9deb6e0c5e22714462523f1d196e3a7353cf73bba326bc2c5f0f98c2beb226f2fe2d5e7979c5d7792cb5dc61d10e86feb5dcf7cc00fe4ebc69451c7d3203a25d90702bcc0c4c5c675fb3e7605cc0eeda56210a92f0f28550387c1519c1cf8205afad3608ac96f7d8e857e6712ea38b17017d7148224e99b6cf7612d24630d28b3b3fe278e18c9b036b7cdae3440f1c6f7a96965fa423d2196751763654fbae9688792a19fd12097390e2013f1eaf57bd1226338bec7dcf9e0ebbc8a570cea7856a08d6c00522b98aae7c48cbbea62773bf66cd08ce72b154ead879c762736ef874869c8d176587bf7f4bda03845c43d0cd84dda632181b3636f4a14b91a464416582f12ef6761b319507f9e74fc24d70c66bd4cf7bf6f0e7cae7a932a96b9aec9cee1873dd1d35a80a2aee1d9cc074925559b8bbf0e9f5772fac4d6738f36479f631390aea94a96812fe651d9b3d5896cd89910ce3cf78490d1c874434a43d7c9dd24fc54de74090cf0b302a21be8942f1057bef175edd1cf6229059e777f53effc833178e4c88ffa08f1ed647ce575e6abc26a5aade790b181c936861c5f8ed6722ec84a43a21832957972832684e7e6498689f3abb78f2f84823e272b25f9a6e425a845b8333a83d08d521be9a9af1fde78bd70de54ebc1e58293ae11038d32c3ca8ac5b833a72a95ab251bc2ae11a5a0c611ca8c96dadf3ecb8bf5a5d50e47a665680b67d3ff3c427d3b5d5094d5dfab2fdf1d3693635bc22c946a62a2d482dc072cae1ee671beb8df147d1b099d7da37d3c413af71a75e77a236a1be10f3bafc8f4231347ac2902f0570b76ac7fb90d4dc2530afdf4364d1229e98f2d4dc3360e438663877b0c087108e9068367ab663a1a0bffcb663d61f4047ef9f906034d879fef1eefe48d30427d1976972c8236a5243a67ea0025987da2e80f172b32a638975853f26f8bc932487be81722756babf1650e182c07bd4c76d33106261db6769f9cf75869b212542440d14a69b2f118c95980cc2e69d0df802fc20a7ae2bf2146753894b92ddb87c8de59fcd4047ab09b22595f7e410810b89d40b2a64741009b4be258e4d7a655f59d13042467eb37e18dd4e5bf2a07455af6b8717294a7cda59d31e3444edcae18bb561ada2824adb0ae0620d935d3ee724e6c5ae3ae79acad04ac56f2632301912fbca0de68b6befc0018c1277c3a42f081682b69bcee5c8441f47c45b9146693ec8a6b935e66c99b2db8441db819b29af1a7eb4807becc40999438bfcebc8d6c78ebaaa4fa15e603fed563f6b930fce0ad747d93572e68af2b5de135d1882f7e0b47c9b2511137c727318b879d17e1cca17d12d28dcbfae7fa81b2e7eef237d51b03678c9b906e2a6eab2a630600af09cb3d04eea3a12827af4535f7c50d954eb88b0b10e86051d8033d134061c6f67d1f986af3ce9da9c5fd3b563976a729d039fa72567c749d50d3b3ce746d11f508a1ebd7389599420c4e012e7dbd986a40288b9be6e2939bfb75b4eebd334405532822daa32e85e2ab375d70ed8d9ba2badcc4250dc848cd8ff3358726fd8d04fde49f9b5f273ba3b37e8e6df0f46884a4f3ee6dc227c91b8caf4a5492cc336c6b1be8f1f81435416a09e6d155a39cb181b06b187d4943981e888fd169cfdd7e097bfd7a8aa4c3f3a6185c963cee12328850f97ca6d536de86d7e74263e620a0994f32cc09dcf3a4eea5f589c9b767039ba7121dfc1187c9a99fccc4b3b341c8c41705f08f06dcd61c8d2ff73b63f91cb99b40eeb21f4e65690851578a07b9b31710bd0f9b71d98117767a57dcae11aabfe93b5fb87d680bef7a2de954da595d0c4f49ce5a2d45d87d51e15c7cba5c93401d85fe1297c123d60573b17193ea17430b57591a51e7afb2534b11028dfb5ef4607f3d9f5235f05021d395f72864ccc83becd4e109b6a8cce14ba86dd75b301ffd2acac7a9c9bb35cf6bfdeb1e8c8f56fe3167184214d04c5411717b5421300277b517f387bd1f3874119e57b22742242b81ab65018f104e0d6396ea17d1f1ca48611c02c927755a8a4c09bd63af2f7223fd4fc1d57ab53f603285dd9e9540da4082256187c50b2d9ca8d055a2cae61f1a2249f86231cb9e0ef13237efbce5a36a040e31221fc74572bac84fc8023384b47f6fde437045db25ea33e26df7abaf144efdb05ee1b96c95c6f088fb5027cc6d375301c9f9c7f8186f55e09e19f045cebd0dc7e8d4ad43bc2539cb619994a564807638ecd6211917d43a9afaeaafe58472314b9baa1ce9ba6495d90346af8f52c037936ea66d7393cf79dbcc0639ea6ed093df58055003226a44f1c3d4b21cb2b4925b30b567c888c0af70224cfb32dc70038df637cc1f23748c6cfe690a5be6fc76a3781a69db413bb92c7d3812cdea9e63d39865364ff9aeb8d1e8357184a4c5d08c7bf7303b01acef09d417552ac6d2bc1fe2132fb2d836437b55e1aed40809db2b2163e31f4ae78b3409ac6f79c96fbf391a9cd298843fcc572c8bbd1bf739b88e0dbabb3e82824a894e5465b7a67602d41e682f6f7dc0f1a0f1048cd945912e8cb3fdce312fb245653d56de7b49c66bd722f4d9a50f28b2e90954f86f93c4072c3881b7a108ab16e7c3a4b7df172741774772e22083963a16c5ca4c7b07611451a0c0603d89d731908352e97855983def85a6e0218e6753afdd787790763a91417dd396c19b74da6f3277e2f6e771977b0db1bc875269cb94b92c747c77edf79cb00e3cff95550e279e78b5cefd4dd2e4561b625550e3f80b75abd840f08e86fc233552b70e9cd6ddb71f2f5effdeb950e03fa3c261585252f76116550102073610820ae9f98ff86fd83cedacce9657480e913a93fa36020d52bb3835aafa92048bd7a52988ead550a0e03efd546b8826962ebbb07b57899067a9fe455ec3df86b0e57477fb87816ea63662f52df221f61ac52f208f140e9cb525bec09225ba6af0ab7854b236949a31a9d3855516bda811412a772cdbe62ad27fbaa0e012b97610b3ba6a8fe0edc5962a9fb7cca652a87efe81e0eefac379f229261e35c7cfe025ecc12a32518c8b28b1f69d5e3650e33da460ed186b4a913c5943d0274ae4d659ac0a91d2bc685d47b157034447aa7761c493f3663d22dda3a590588348942c689f401f17bcebea7ed399f445b2dbafb9c77d332bbd24e858657e6c7a7ee331aed150abc2aadd352e3abd59f7b77c62317e51bb21249fa8905e2608162307a418052299fa9ab051e9d2b0067300b0820b7a11fef103098d602bbeb456bb20e33dbbe32a476a27fdb71361d85ee9b2a264021439aa471410bef2686c03842434d14d8b93ca60c4c0281da4ae93748096df8b4e21f3c11b2c3e6f5b6ac96ac8079073d18bb0aaaeff933ea51cceac2746509b2c70574d14b31cce44099670e1e58a701c4d55132c5593927f1457ddda8110a76b3dcf0e10d77ddf21593e43eb98e6c09d628114da0aa06a8d162a1f8e4d5e1320c3824bcccf3c1ce3a4d9875ebc1fb38855a98d8c39d9015abca386c0b56b983261510c639e366990c1c89d3a1f74864f1ef13b15f94c2efd7fbb28bc6ea75c4ac66b6aef012ea577f579ad2d4e34543945c9c854ccda362f15a2d4189f2849495878f08d50277d3306953e5b64d6bbdd63d277a4e096ee586852eb2d58e16b923dd569abf53475f1a61f31bf22bcbb3af5c8 请输入密码查看.","link":"/2019/09/15/master-complaints/"},{"title":"sort","text":"排序算法简单实现了一下几种常见的内排序算法 希尔排序 归并排序 快速排序 堆排序 基数排序 桶排序 排序算法 平均执行效率 稳定性 备注 插入排序 o(n^2) 稳定 我觉得这个稳定性取决于实现的时候的停止条件 冒泡排序 o(n^2) 稳定 选择排序 o(n^2) 非稳定 因为选择最小 or 最大元素交换的时候回改变原来的顺序 希尔排序 o(nlogn) 稳定 希尔排序是一个根据步长的来的插入排序 快排 o(nlogn) 非稳定 分治的方法，递归的处理子数组，每次寻找到一个数字的位置 堆排序 o(nlogn) 非稳定 用大顶堆 or 小顶堆实现，调整堆的有序性需要 logn 的时间 归并排序 o(nlogn) 稳定 使用分治，每次合并两个已经有序的数组 希尔排序希尔排序实际上就是带步长的插入排序。不同于插入排序按照步长为 1 进行排序，希尔排序采用了缩进的步长。每次只在相同步长的一组数据中进行排序。 参考维基百科的解释，例如对于数组 []int{1,5,4,2,7,45,75,3,4,87} 排序，选取步长为 len() / 2，且每次步长缩进一半 其排序的过程如下 第一次分组 （步长为 5） 排序前 1 5 4 2 7 45 75 3 4 87 调用插入排序 对竖着的数组进行排序 1 5 3 2 7 45 75 4 4 87 第二次分组 (步长为 2) 排序前的数组为 {1,5,3,2,7,45,75,4,4,87}，因此分组为 1 5 3 2 7 45 75 4 4 87 插入排序 1 2 3 4 4 5 7 45 75 87 第三次分组 （步长为 1） 步长为 1 相当于插入排序 直接排序即可 123456789101112131415161718192021222324252627package sort// shell 排序是一个按照步长的排序// 其本质是一个优化了步长的插入排序func shellSort(nums []int) { if nums == nil || len(nums) == 0 { return } step := len(nums) / 2 // 步长不停的缩短 直到最后成为插入排序（但是插入排序这个时候已经基本有序 所以跟完全乱序的相比 会有比较大的性能提升） for step &gt;= 1 { // 插入排序 for i := step; i &lt; len(nums); i++ { exchange := nums[i] j := i - step // 将 i 位置的数 插入到 以 step 为步长的数组中间 for ; j &gt;= 0 &amp;&amp; exchange &lt; nums[j]; j -= step { nums[j + step] = nums[j] } // 上面已经把数据迁移完毕 只需要在 j+step 即结束迁移的位置 把需要插入的数据插入即可 nums[j + step] = exchange } step /= 2 }} 归并排序1234567891011121314151617181920212223242526272829303132333435363738394041424344package sortfunc mergeSort(nums []int, i, j int) { if i &gt;= j { return } mid := (i + j) / 2 mergeSort(nums, i, mid) mergeSort(nums, mid+1, j) // 这一步 i -&gt; mid mid + 1 -&gt; j 已经是有序的了 merge(nums, i, mid, j)}func merge(nums []int, i, mid, j int) { tmp, index := make([]int, j-i+1), 0 iStart, jStart := i, mid+1 for iStart &lt;= mid &amp;&amp; jStart &lt;= j { if nums[iStart] &gt; nums[jStart] { tmp[index] = nums[jStart] jStart++ } else { tmp[index] = nums[iStart] iStart++ } index++ } for iStart &lt;= mid { tmp[index] = nums[iStart] index++ iStart++ } for jStart &lt;= j { tmp[index] = nums[jStart] index++ jStart++ } for m, n := 0, i; m &lt; len(tmp); m, n = m+1, n+1 { nums[n] = tmp[m] }} 链表的归并排序其实思想跟普通的归并排序基本一样，但是需要注意的是。归并分链表的时候，要直接截断链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func sortList(head *ListNode) *ListNode { return mergeSort(head)}func mergeSort(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } mid := divideList(head) return mergeTwoListNode(mergeSort(head), mergeSort(mid))}func mergeTwoListNode(left, right *ListNode) *ListNode { res := new(ListNode) mov := res for left != nil &amp;&amp; right != nil { if left.Val &gt; right.Val { mov.Next = right right = right.Next } else { mov.Next = left left = left.Next } mov = mov.Next } if left != nil { mov.Next = left } if right != nil { mov.Next = right } return res.Next}// divideList 会把 list 分为两个 list// 会截断原来的 nodefunc divideList(node *ListNode) *ListNode { if node == nil || node.Next == nil { return node } fast := node.Next for fast != nil &amp;&amp; fast.Next != nil { fast = fast.Next.Next node = node.Next } mid := node.Next node.Next = nil return mid} 寻找逆序数对leet code 包含一个逆序数对的例题，315. 计算右侧小于当前元素的个数 找到当前数字右侧的小于这个数的数量，实际上就是去找到 当前这个数 大于 后面多少数的数量，一大一小，即构成逆序数对，所以可以用归并来做 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;public class CountRightSmaller_315 { public List&lt;Integer&gt; countSmaller(int[] nums) { int n = nums.length; int[] res = new int[n], indexes = new int[n]; // 保存原始数组的数组 好在 res 数组中定位 for (int i = 0; i &lt; n; i++) { indexes[i] = i; } mergeSort(nums, 0, n - 1, res, indexes); return Arrays.stream(res).boxed().collect(Collectors.toList()); } public void mergeSort(int[] nums, int i, int j, int[] res, int[] indexes) { if (i &gt;= j) return; int mid = i + (j - i) / 2; mergeSort(nums, i, mid, res, indexes); mergeSort(nums, mid + 1, j, res, indexes); merge(nums, i, mid, j, res, indexes); } public void merge(int[]nums, int start, int mid, int end, int[] res, int[] indexes) { int i = start, j = mid + 1; int[] tmp = new int[end - start + 1], tmpIndexes = new int[end - start + 1]; int index = 0; while (i &lt;= mid &amp;&amp; j &lt;= end) { if (nums[i] &lt;= nums[j]) { // 说明 j 之前相当于 i 来说都是逆序了 tmp[index] = nums[i]; res[indexes[i]] += j - mid - 1; tmpIndexes[index++] = indexes[i++]; } else { // nums[j] &lt; nums[i] tmp[index] = nums[j]; tmpIndexes[index++] = indexes[j++]; } } while (i &lt;= mid) { // 说明 j 之前相当于 i 来说都是逆序了 tmp[index] = nums[i]; res[indexes[i]] += j - mid - 1; tmpIndexes[index++] = indexes[i++]; } while (j &lt;= end) { tmp[index] = nums[j]; tmpIndexes[index++] = indexes[j++]; } index = 0; while (start &lt;= end) { nums[start] = tmp[index]; indexes[start++] = tmpIndexes[index++]; } } public static void main(String[] args) { System.out.println(new CountRightSmaller_315().countSmaller(new int[]{-1, -1})); }} 快速排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546package sortfunc QuickSort(nums []int, i, j int) { if i &gt;= j { return } p := partition(nums, i, j) QuickSort(nums, i, p-1) QuickSort(nums, p+1, j)}func partition(nums []int, start, end int) int { base := nums[start] i, j := start, end+1 for true { i++ for i &lt; len(nums) &amp;&amp; nums[i] &lt; base { i++ } j-- for j &gt;= 0 &amp;&amp; nums[j] &gt; base { j-- } if i &gt;= j { break } swap(nums, i, j) } swap(nums, start, j) return j}func swap(nums []int, i, j int) { if nums[i] == nums[j] { return } nums[i] = nums[i] ^ nums[j] nums[j] = nums[i] ^ nums[j] nums[i] = nums[i] ^ nums[j]} 堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package sortfunc defaultCompare(a, b int) bool { return a &gt; b}// Heap 根据输入的 compare 构建不同的堆// 默认小顶堆 -&gt; 从大到小排列type Heap struct { nums []int compare func(a, b int) bool}// shiftDown 移动顶层的向下func (h *Heap) shiftDown(k, n int) { for 2*k+1 &lt;= n { j := 2*k + 1 // 注意这个地方 大顶堆的时候 因为需要把小的东西往下沉 所以需要选择的是 子节点中 的较大值 // 小顶堆的时候 由于需要把大的东西往下沉 所以需要选取的是较小值 （因为比较小值小 这个节点一定比两个节点都小） if j+1 &lt;= n &amp;&amp; h.compare(h.nums[j],h.nums[j+1]) { j++ } if h.compare(h.nums[j], h.nums[k]) { break } swap(h.nums, k, j) k = j }}// popUp 最下面的浮动到最上面func (h *Heap) popUp(k int) { for k &gt;= 0 { var father int if k%2 == 1 { father = k / 2 } else { father = k/2 - 1 } if h.compare(h.nums[k], h.nums[father]) { break } swap(h.nums, father, k) k = father }}func NewHeap(nums []int) *Heap { return &amp;Heap{nums: nums, compare: defaultCompare}}func NewHeapWithCompare(nums []int, compare func(a, b int) bool) *Heap { return &amp;Heap{nums: nums, compare: compare}}func (h *Heap) Sort() { n := len(h.nums) - 1 // 首先将输入构造成堆 for i := n / 2; i &gt;= 0; i-- { h.shiftDown(i, n) } // 这样排序是吧最小的排在后面 for n &gt;= 0 { swap(h.nums, 0, n) n-- h.shiftDown(0, n) }}func swap(nums []int, i, j int) { if nums[i] == nums[j] { return } nums[i] = nums[i] ^ nums[j] nums[j] = nums[i] ^ nums[j] nums[i] = nums[i] ^ nums[j]} 基数排序基数排序的思维很简单，就是根据数字的每一位来排序 首先排序个位，根据个位数字 分别放到 编号 0-9 的桶里面 然后再排序十位，最后直到最大的数字也为 0 即可停止 1234567891011121314151617181920212223242526272829303132333435363738394041424344func maximumGap(nums []int) int { if len(nums) &lt; 2 { return 0 } biggest := nums[0] for _, num := range nums { biggest = max(biggest, num) } // 基数排序的桶 分为 0 - 9 lists := make([][]int, 10) base := 1 for biggest &gt; 0 { // 每次循环前都重置 for i := 0; i &lt; 10; i++ { lists[i] = make([]int, 0) } // 排序数组 for _, num := range nums { i := num / base % 10 lists[i] = append(lists[i], num) } // 根据每轮的顺序 重新赋值 nums 数组 for i, index := 0, 0; i &lt; 10; i++ { for j := 0; j &lt; len(lists[i]); j++ { nums[index] = lists[i][j] index++ } } biggest /= 10 base *= 10 } res := 0 for i := 0; i &lt; len(nums)-1; i++ { res = max(res, nums[i+1]-nums[i]) } return res} 桶排序桶排序也很简单 直接根据最大小值分桶 然后根据其数值放到不同的桶里面 排序 只需要遍历桶的 下标即可 1234567891011121314151617181920212223242526272829303132333435363738func maximumGapWithBucket(nums []int) int { if len(nums) &lt; 2 { return 0 } smallest, biggest := math.MaxInt32, math.MinInt32 for _, num := range nums { smallest = min(smallest, num) biggest = max(biggest, num) } // 桶排序 counts := make([]int, biggest - smallest + 1) for _, num := range nums { counts[num-smallest]++ } res := 0 var pre *int for i, num := range counts { // 表示没有数字 if num == 0 { continue } if pre == nil { tmp := i pre = &amp;tmp continue } // 比较 res = max(res, i - *pre) tmp := i pre = &amp;tmp } return res}","link":"/2021/02/24/sort/"},{"title":"简单图算法","text":"图算法简单实现了无向图、无向加权图、有向图、有向加权图的几种算法，包括: 遍历 dfs bfs 应用 环图 拓扑排序 双色问题 最小生成树 prim krusal 最短路径 Dijkstra 拓扑排序遍历 bellemanFord 图的数据结构以下均使用邻接表标识 无向图 无向图设计得有点尴尬 其实没必要 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class UndirectedGraph&lt;T&gt; implements Graph&lt;T&gt; { public HashMap&lt;T, UndirectedNode&lt;T&gt;&gt; map; public UndirectedGraph() { this.map = new HashMap&lt;&gt;(); } public Set&lt;T&gt; keys() { return map.keySet(); } // 无向图 两遍都要加 public void addEdge(T from, T to) { if (!map.containsKey(from)) { map.put(from, new UndirectedNode&lt;&gt;(to)); } UndirectedNode&lt;T&gt; temp = map.get(from); // 说明加入了重复边 if (!temp.addNode(to)) return; if (!map.containsKey(to)) { map.put(to, new UndirectedNode&lt;&gt;(from)); } UndirectedNode&lt;T&gt; tempTo = map.get(to); tempTo.addNode(from); } public Node&lt;T&gt; adjacent(T from) { return this.map.getOrDefault(from, null); }}public class UndirectedNode&lt;T&gt; implements Node&lt;T&gt; { public T to; public UndirectedNode&lt;T&gt; next; public UndirectedNode(T to) { this.to = to; this.next = null; } /** * * @param to * @return boolean 表示是否加入成功 */ public boolean addNode(T to) { // 加入第一个节点的时候的判断 if (this.to == to) return true; UndirectedNode&lt;T&gt; temp = this.next; // 加入第二个节点时的判断 if (temp == null) { this.next = new UndirectedNode&lt;&gt;(to); return true; } while (temp.next != null) { if (temp.to == this.to) return false; temp = temp.next; } temp.next = new UndirectedNode&lt;&gt;(to); return true; }} 有向图 12345678910111213141516171819202122232425262728293031323334353637public class DirectedGraph { public int getCapacity() { return capacity; } private int capacity; private List&lt;LinkedList&lt;Integer&gt;&gt; nodes; public DirectedGraph(int capacity) { this.capacity = capacity; this.nodes = new ArrayList&lt;&gt;(capacity); for (int i = 0; i &lt; capacity; i++) { nodes.add(new LinkedList&lt;&gt;()); } } public LinkedList&lt;Integer&gt; adj(int node) { return this.nodes.get(node); } public void addEdge(int from, int to) { this.nodes.get(from).add(to); } public DirectedGraph reverse() { DirectedGraph reversed = new DirectedGraph(this.capacity); for (int from = 0; from &lt; this.capacity; from++) { for (Integer to : adj(from)) { if (to != null) { reversed.addEdge(to, from); } } } return reversed; }} 加权无向图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class UndirectedWeightGraph { public int getCapacity() { return capacity; } private int capacity; // 邻接表 private List&lt;LinkedList&lt;Edge&gt;&gt; nodes; public UndirectedWeightGraph(int capacity) { this.capacity = capacity; this.nodes = new ArrayList&lt;&gt;(capacity); for (int i = 0; i &lt; capacity; i++) { this.nodes.add(new LinkedList&lt;&gt;()); } } public LinkedList&lt;Edge&gt; adj(int node) { return this.nodes.get(node); } public void addEdge(int from, int to, int weight) { Edge edge = new Edge(from, to, weight); this.nodes.get(from).add(edge); this.nodes.get(to).add(edge); }}public class Edge { public int from; public int to; public int weight; public Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } // 根据传入的值 返回不同的 from to public int other(int in) { // 根据传入的端点 找到链接的另外一个断点 if (in == from) { return to; } return from; } @Override public String toString() { return &quot;Edge{&quot; + &quot;from=&quot; + from + &quot;, to=&quot; + to + &quot;, weight=&quot; + weight + '}'; }} 加权有向图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class Edge { int from, to; int weight; public Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } public int getFrom() { return from; } public void setFrom(int from) { this.from = from; } public int getTo() { return to; } public void setTo(int to) { this.to = to; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } @Override public String toString() { return &quot;Edge{&quot; + &quot;from=&quot; + from + &quot;, to=&quot; + to + &quot;, weight=&quot; + weight + '}'; }}public class DirectedWeightGraph { public int getCapacity() { return capacity; } int capacity; List&lt;List&lt;Edge&gt;&gt; nodes; public DirectedWeightGraph(int capacity) { this.capacity = capacity; this.nodes = new ArrayList&lt;&gt;(this.capacity); for (int i = 0; i &lt; capacity; i++) { this.nodes.add(new LinkedList&lt;&gt;()); } } // 有向图只用加入一遍 public void addEdge(int from, int to, int weight) { this.nodes.get(from).add(new Edge(from, to, weight)); } public void addEdge(Edge edge) { this.nodes.get(edge.from).add(new Edge(edge.from, edge.to, edge.weight)); } public List&lt;Edge&gt; adj(int node) { return this.nodes.get(node); } // 返回所有的边 public List&lt;Edge&gt; edges() { List&lt;Edge&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) { res.addAll(this.nodes.get(i)); } return res; }} 图的遍历方法以无线图为例，有向图和无向图的遍历基本一样 DFS DFS 即使用栈的思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DFS { public static &lt;T&gt; void DFSWithRecursion(Graph&lt;T&gt; graph) { Set&lt;T&gt; memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!memo.contains(start)) DFSWithRecursion(graph, start, memo); } } public static &lt;T&gt; void DFSWithoutRecursion(Graph&lt;T&gt; graph) { Set&lt;T&gt; memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!memo.contains(start)) DFSWithOutRecursion(graph, start, memo); } } public static &lt;T&gt; void DFSWithRecursion(Graph&lt;T&gt; graph, T start, Set&lt;T&gt; memo) { System.out.println(start); UndirectedNode&lt;T&gt; node = (UndirectedNode&lt;T&gt;) graph.adjacent(start); memo.add(start); while (node != null) { if (!memo.contains(node.to)) DFS.DFSWithRecursion(graph, node.to, memo); node = node.next; } } public static &lt;T&gt; void DFSWithOutRecursion(Graph&lt;T&gt; graph, T start, Set&lt;T&gt; memo) { LinkedList&lt;T&gt; stack = new LinkedList&lt;&gt;(); stack.add(start); memo.add(start); while (stack.size() != 0) { T top = stack.removeLast(); System.out.println(top); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) graph.adjacent(top); while (temp != null) { if (!memo.contains(temp.to)) { stack.add(temp.to); memo.add(temp.to); } temp = temp.next; } } }} BFS bfs 使用队列的思想 12345678910111213141516171819202122232425262728public class BFS { public static &lt;T&gt; void BFS(Graph&lt;T&gt; graph) { Set&lt;T&gt; memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!memo.contains(start)) BFS(graph, start, memo); } } public static &lt;T&gt; void BFS(Graph&lt;T&gt; graph, T start, Set&lt;T&gt; memo) { LinkedList&lt;T&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); memo.add(start); while (!queue.isEmpty()) { T first = queue.removeFirst(); System.out.println(first); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) graph.adjacent(first); while (temp != null) { if (!memo.contains(temp.to)) { queue.add(temp.to); memo.add(temp.to); } temp = temp.next; } } }} 图遍历方法的应用无向图连通分量12345678910111213141516171819202122232425262728293031323334353637// 连通分量public class Connected&lt;T&gt; { // 如果连个端点属于一个连通分量 // 他们的id应该是一样的 public HashMap&lt;T, Integer&gt; ids; public int count = 0; public Graph&lt;T&gt; graph; public Set&lt;T&gt; memo; public Connected(Graph&lt;T&gt; graph) { this.ids = new HashMap&lt;&gt;(); this.graph = graph; this.memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!this.memo.contains(start)) { dfs(start); count++; } } } public void dfs(T start) { this.memo.add(start); ids.put(start, this.count); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) this.graph.adjacent(start); while (temp != null) { if (!memo.contains(temp.to)) dfs(temp.to); temp = temp.next; } } public boolean connected(T from, T to) { return ids.get(from).equals(ids.get(to)); }} 成环检测1234567891011121314151617181920212223242526272829303132public class CheckCycle&lt;T&gt; { // memo 记录在dfs的过程中的节点 public Set&lt;T&gt; memo; public Graph&lt;T&gt; graph; public boolean hasCycle = false; public CheckCycle(Graph&lt;T&gt; graph) { this.graph = graph; this.memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!this.memo.contains(start)) { dfs(start, start); } } } public void dfs(T start, T parent) { memo.add(start); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) graph.adjacent(start); while (temp != null) { if (!memo.contains(temp.to)) dfs(temp.to, start); // 因为是无向图 因此在访问的时候 会在子节点上 重新访问父节点过来的那条边 因此这样记录父节点即可 else if(temp.to != parent) hasCycle = true; temp = temp.next; } }} 拓扑排序拓扑排序对于排队、课程安排之类的有帮助，其基于有向图实现 首先要做的就是有向图成环检测，因此成环是没有 拓扑排序 的 有向图成环检测 1234567891011121314151617181920212223public void DFS(DirectedGraph g) { boolean[] memo = new boolean[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { if (!memo[i]) { DFSRecursion(g, i, memo, new boolean[g.getCapacity()]); } } }private void DFSRecursion(DirectedGraph g, int start, boolean[] memo, boolean[] marked) { memo[start] = true; System.out.printf(&quot;%s &quot;, start); marked[start] = true; for (int i : g.adj(start)) { if (!marked[i]) { DFSRecursion(g, i, memo, marked); } else { // 已经成环 this.cycle = true; } } marked[start] = false;} 拓扑排序 有两种方法 逆后续排列。因为要找到 v-&gt;w 这种拓扑结果，那么在访问完 V 之后 访问 W 即其连接节点，用 stack 来保存访问顺序，再弹出栈 就可以得到 v -&gt; w 的顺序 12345678910111213141516171819202122232425262728public static List&lt;Integer&gt; topologySortWithRecursion(DirectedGraph g) { // 作为一个栈 List&lt;Integer&gt; stack = new ArrayList&lt;&gt;(); boolean[] memo = new boolean[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { if (!memo[i]) { // 根据一个出发点 找到其 拓扑排序 topologySortRecursion(g, stack, i, memo); } } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // 输出 stack for (int i = stack.size() - 1; i &gt;= 0; i--) { res.add(stack.get(i)); } return res;}private static void topologySortRecursion(DirectedGraph g, List&lt;Integer&gt; res, int start, boolean[] memo) { memo[start] = true; for (int adj : g.adj(start)) { if (!memo[adj]) { topologySortRecursion(g, res, adj, memo); } } res.add(start);} 遍历入度为 0 的点，因为能够作为开始节点的点，一定入度为 0，那么不停的遍历，删除边，维护一个入度为 0 的点的 collection 既可找到访问顺序 123456789101112131415161718192021222324252627282930313233343536// 2. 不停地遍历入度为 0 的点 然后删除public static List&lt;Integer&gt; topologySortIteration(DirectedGraph g) { int[] inDegree = new int[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { for (int adj : g.adj(i)) { inDegree[adj] += 1; } } Deque&lt;Integer&gt; inDegreeEqualsZero = new LinkedList&lt;&gt;(); // 找到为 0 的点 for (int i = 0; i &lt; g.getCapacity(); i++) { if (inDegree[i] == 0) { inDegreeEqualsZero.offer(i); } } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while (!inDegreeEqualsZero.isEmpty()) { int top = inDegreeEqualsZero.poll(); res.add(top); for (int adj : g.adj(top)) { inDegree[adj] -= 1; if (inDegree[adj] == 0) { inDegreeEqualsZero.offer(adj); } } } return res;} 有向图的强连通分量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class DirectedGraphStrongConnected { public static List&lt;Integer&gt; KosarajuConnected(DirectedGraph g) { // 保存的强连通分量的 id // ids[i] 表示 i 节点属于哪个 强连通分量 id List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(g.getCapacity()); for (int i = 0; i &lt; g.getCapacity(); i++) { ids.add(-1); } // 遍历的时候的强连通分量 id int count = 0; // 先得到 反图 的拓扑排序 List&lt;Integer&gt; order = TopologySort.topologySortWithRecursion(g.reverse()); boolean[] memo = new boolean[g.getCapacity()]; for (int node : order) { if (!memo[node]) { recursionDFS(g, node, count, memo, ids); count++; } } // 根据拓扑排序 DFS return ids; } private static void recursionDFS(DirectedGraph g, int start, int count, boolean[] memo, List&lt;Integer&gt; ids) { memo[start] = true; ids.set(start, count); for (int adj : g.adj(start)) { if (!memo[adj]) { recursionDFS(g, adj, count, memo, ids); } } } public static void main(String[] args) { DirectedGraph g = new DirectedGraph(13); g.addEdge(1, 2); g.addEdge(3, 1); g.addEdge(6, 3); g.addEdge(4, 7); g.addEdge(2, 0); g.addEdge(11, 8); g.addEdge(10, 1); g.addEdge(0, 7); g.addEdge(0, 6); System.out.println(KosarajuConnected(g)); }} 最小生成树最小生成树都是基于贪心的思路和想法。由于需要生成的无向加权图的树（v-1 条边）的路径和最短，所以实际上是一个不断遍历最短路径边的贪心策略。 prim 算法 lazy 版本 在遍历所有的边的时候，不主动删除队列中的无效边，所以为 lazy 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MinTree { // 最小生成树 指的是无向图中，能够生成的边的权重总和最小的树 // prime 的最小生成树实际上是一个贪心算法 // 通过 PriorityQueue 不停地生成权重最小的边 // lazyPrim 指的是在遍历的过程中 pq 中的边 是访问时才失效 public static Deque&lt;Edge&gt; lazyPrim(UndirectedWeightGraph g) { // 存储所有的边 PriorityQueue&lt;Edge&gt; minQueue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a.weight)); // 保存被访问过的节点 boolean[] marked = new boolean[g.getCapacity()]; // 保存返回的结果 Deque&lt;Edge&gt; res = new LinkedList&lt;&gt;(); // 保证 g 整体是连通的 // 随意选取一个节点作为开始节点 addEdgeToPQ(marked, minQueue, 0, g); while (!minQueue.isEmpty()) { // 抓到的一定是最短的路径 Edge top = minQueue.poll(); int from = top.from, to = top.to; // from to 两个断点都已经访问过 说明在两个端点之间已经找到最短的了 if (marked[from] &amp;&amp; marked[to]) continue; // 否则就找到最短的 res.add(top); // 将两个端点的 edge 加入到 queue 中 if (!marked[from]) addEdgeToPQ(marked, minQueue, from, g); if (!marked[to]) addEdgeToPQ(marked, minQueue, to, g); } return res; } public static void addEdgeToPQ(boolean[] marked, PriorityQueue&lt;Edge&gt; minQueue, int start, UndirectedWeightGraph g) { marked[start] = true; for (Edge e : g.adj(start)) { if (!marked[e.other(start)]) { // 另外一个断点没有访问过 minQueue.add(e); } } }} 及时版本 在遍历的时候，不再以边作为 优先队列 的遍历对象，而是采用对点进行遍历，在遍历的图中，不停的更新 优先队列 中点对应的最短边，以此减少调整堆的时间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private static class Pair { int node; int weight; public Pair(int node, int weight) { this.node = node; this.weight = weight; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Pair pair = (Pair) o; return node == pair.node; } @Override public int hashCode() { return Objects.hash(node); }}// 实时的 prim 算法 与 lazy 不同的是// 在 v 这个节点 加入 pq 的时候 其余的非树阶段 应该只加入 到 树中最短的边// 相对来说 可以减少时间 因为 一个图的话 一般是 边比点多// 这个算法只用在 优先队列中保存点public static Edge[] prim(UndirectedWeightGraph g) { // 仍然使用一个 pq 保存最短的点 （到这个点的最短距离） PriorityQueue&lt;Pair&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(e -&gt; e.weight)); // edge[i] 保存 i 到 edge.to 的最短边长 Edge[] edgeTo = new Edge[g.getCapacity()]; boolean[] marked = new boolean[g.getCapacity()]; pq.add(new Pair(0, 0)); while (!pq.isEmpty()) { Pair top = pq.poll(); inTimeAddEdgeToPQ(g, top.node, marked, edgeTo, pq); } return edgeTo;}private static void inTimeAddEdgeToPQ(UndirectedWeightGraph g, int node, boolean[] marked, Edge[] edgeTo, PriorityQueue&lt;Pair&gt; pq) { marked[node] = true; for (Edge adj : g.adj(node)) { int otherNode = adj.other(node); // 已经找到了 if (marked[otherNode]) continue; // 说明还没有找到到这个点的最短距离 或者 // 现在的 edge 的 weight 更短 更新 if (edgeTo[otherNode] == null || adj.weight &lt; edgeTo[otherNode].weight) { edgeTo[otherNode] = adj; Pair p = new Pair(otherNode, adj.weight); for (Pair tmp : pq) { // remove 掉已经失效的边 if (tmp.node == otherNode) { pq.remove(tmp); } break; } pq.add(p); } }} krusal 算法 与 lazy prim 算法类似，其也是遍历所有的边并加入到 优先队列 中，但是遍历的时候采用的方法是通过 并查集 判断点是否已经找到了最短的距离，在找到最短距离后，会判断两个点相连，知道结果边集合大小扩展到 v-1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MinTreeKruskal { // 使用 并查集 来判断加入的边是否成环 public static List&lt;Edge&gt; kruskalUseUnion(UndirectedWeightGraph g) { List&lt;Edge&gt; res = new ArrayList&lt;&gt;(); Union uf = new Union(g.getCapacity()); PriorityQueue&lt;Edge&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt((e) -&gt; e.weight)); pq.addAll(g.getEdges()); // 最小生成树 只能有 V - 1 个 （V 为 node 数） while (!pq.isEmpty() &amp;&amp; (res.size() &lt; g.getCapacity() - 1)) { Edge e = pq.poll(); assert e != null; int from = e.from, to = e.to; // 之前已经连接了最短的边 所以不用再连接了 if (uf.connected(from, to)) continue; // 连接两条边 uf.union(from, to); res.add(e); } return res; }}public class Union { // 并查集 int[] parents; public Union(int capacity) { this.parents = new int[capacity]; for (int i = 0; i &lt; capacity; i++) { // 初始化 this.parents[i] = i; } } public void union(int n1, int n2) { int rootOfN1 = find(n1); int rootOfN2 = find(n2); if (rootOfN1 == rootOfN2) return; // n1 root 连接到 n2 root 上 this.parents[rootOfN1] = rootOfN2; } // 找到跟节点 private int find(int node) { if (this.parents[node] == node) { return node; } return find(this.parents[node]); } public boolean connected(int i, int j) { // 判断两个 root 是否相等 int rootOfI = find(i); int rootOfJ = find(j); return rootOfI == rootOfJ; }} 最短路径最短路径其实跟上述的算法类似，也是一个类似贪心的策略，但是在遍历最短边的时候，或同时使用 relax 的操作，保障一个点经过一个中间点可能比直接到目标点的距离短这个问题。 Dijkstra 算法 基本与 prim 算法一样，只是加入了 relax 的操作 其只能处理非负的有向图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static class Pair { int node; int weight; public Pair(int node, int weight) { this.node = node; this.weight = weight; }}// dijkstra 与 in time 的 prim 算法类似// 这些是找到单源最短路的public static Edge[] dijkstraMinPath(DirectedWeightGraph g, int start) { // 保存最短路径的边 Edge[] edgeTo = new Edge[g.getCapacity()]; // 保存最短路径的长度 int[] distTo = new int[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { distTo[i] = Integer.MAX_VALUE; } distTo[start] = 0; PriorityQueue&lt;Pair&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt((e) -&gt; e.weight)); pq.add(new Pair(start, 0)); // 每次都找现在最短的路径 然后 relax 路径 while (!pq.isEmpty()) { Pair min = pq.poll(); relax(g, min.node, pq, edgeTo, distTo); } return edgeTo;}// relax 节点private static void relax(DirectedWeightGraph g, int node, PriorityQueue&lt;Pair&gt; pq, Edge[] edgeTo, int[] distTo) { for (Edge adj : g.adj(node)) { // 因为 edgeTo 保存的是之前遍历的最短的路径 // 所以 如果通过现在这个点 + adj.weight 的距离 比 edgeTo 的短 就需要更新 if (distTo[adj.to] &gt; distTo[node] + adj.weight) { edgeTo[adj.to] = adj; distTo[adj.to] = distTo[node] + adj.weight; // 添加新的 或者 更新原来的节点的最小值 Pair p = new Pair(adj.to, distTo[adj.to]); // 更新 pq for (Pair tmp : pq) { if (tmp.node == adj.to) { pq.remove(tmp); } break; } pq.add(p); } }} 拓扑排序处理无环图 由于拓扑排序的性质，是从入度为 0 的点不断向外延伸，所以，如果根据 拓扑排序 的顺序访问图中的点，那么后面的点是一定不会再访问已经访问过的点，所以不会出现 relax。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 采用 dfs 做的 topologySort// 保证无环public static int[] topologySort(DirectedWeightGraph g) { boolean[] marked = new boolean[g.getCapacity()]; Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; g.getCapacity(); i++) { // marked 标识标记过的点 if (!marked[i]) { dfs(g, marked, i, stack); } } int[] res = new int[stack.size()]; int i = 0; while (!stack.isEmpty()) { res[i++] = stack.removeLast(); } return res;}public static void dfs(DirectedWeightGraph g, boolean[] marked, int start, Deque&lt;Integer&gt; stack) { marked[start] = true; for (Edge adj : g.adj(start)) { if (!marked[adj.to]) { dfs(g, marked, adj.to, stack); } } stack.addLast(start);}// 使用拓扑排序的单源最短路经// 只能处理无环的情况// 拓扑排序只能针对无环图// 由于 拓扑排序是从 无入度的点开始// 如果找最短路径从这儿开始的话 这个点 一定不会再次被访问到 所以只放松一次// 同理 解决单点无环图的最长路径 可以把 weight 取负 再来最短路径即可public static Edge[] topologyMinPath(DirectedWeightGraph g, int start) { int[] topologyPath = TopologySort.topologySort(g); Edge[] res = new Edge[g.getCapacity()]; // 初始化距离 int[] dst = new int[g.getCapacity()]; Arrays.fill(dst, Integer.MAX_VALUE); dst[start] = 0; for (int node : topologyPath) { relax(g, res, dst, node); } return res;}private static void relax(DirectedWeightGraph g, Edge[] res, int[] dst, int node) { for (Edge adj : g.adj(node)) { // 如果之前遍历的 到 adj.to 的距离 比从 node 经过 adj 到达 adj.to 的距离长 说明该更新了 if (dst[adj.to] &gt; dst[node] + adj.weight) { res[adj.to] = adj; dst[adj.to] = dst[node] + adj.weight; } }} BellmanFord 算法 能过处理负数的图，但是不能处理负数环（因为负数环能够达到任意短的负数）。 其核心思想是遍历 V 次 图，这样保障每个点都被遍历 V 次，找到最短的路径。 但是可以优化的点是，只有在上次被更改了长度的点才能加入队列中。 // 这个算法只能处理没有负权重环的有向图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 因为带有负权重环的图可以得到任意短的权重 是无效的public static Edge[] bellmanFordMinPath(DirectedWeightGraph g, int start) { // 所以 如果遍历所有的点 同时 relax 所有的 边 就可以得到一个结果 // 其效率为 o(v + e) // 但是 可以考虑一个问题 就是只有在上轮循环中更新过的点 才有可能使 距离更短，所以 用一个 queue 来保存这样的点 // 转上轮对 dst 数组有贡献的点 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // 结果 Edge[] edgeTo = new Edge[g.getCapacity()]; // 距离初始化 int[] dst = new int[g.getCapacity()]; Arrays.fill(dst, Integer.MAX_VALUE); dst[start] = 0; // 因为 queue 里面不能有重复节点 所以用这个来判断 boolean[] inQueue = new boolean[g.getCapacity()]; // 执行 relax 的次数 int cost = 0; // 最开始的节点 queue.add(start); // TODO 这个时候还要检查负权重环 // 这个地方只需要检查是否是成环即可 while (!queue.isEmpty()) { relax(g, queue.remove(), dst, edgeTo, queue, inQueue); } return edgeTo;}// 在放松的时候同时更新 queueprivate static void relax(DirectedWeightGraph g, int node, int[] dst, Edge[] edgeTo, Queue&lt;Integer&gt; queue, boolean[] inQueue) { for (Edge adj : g.adj(node)) { int to = adj.to; // 更新 if (dst[to] &gt; dst[node] + adj.weight) { edgeTo[to] = adj; dst[to] = dst[node] + adj.weight; if (!inQueue[node]) { inQueue[node] = true; // 这有这轮已经更新过的 到 to 的更短距离 其他才可能更短 queue.add(to); } } // TODO 检查负权重环 }}","link":"/2021/03/07/graph/"},{"title":"design-pattern","text":"常见的设计模式的简单总结和简单实现，为以后做个参考 观察者模式观察者模式简单实现只需要让 subject 在更新的时候 通知 观察者，基本结构如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// 观察者public interface Observer { // 观察者的更新方法 void update();}// 需要被观察的主题public interface Subject { void registerObserver(Observer ob); void unregisterObserver(Observer ob); void notifyAllObserver();}public class SubjectImpl implements Subject { List&lt;Observer&gt; obs; public SubjectImpl() { this.obs = new ArrayList&lt;&gt;(); } @Override public void registerObserver(Observer ob) { for (Observer registered : obs) { if (ob == registered) return; } this.obs.add(ob); } @Override public void unregisterObserver(Observer ob) { this.obs.remove(ob); } // 在更改某个数值 或者需要通知的时候 可以将结果通知给注册的 observer public void setXXX() { this.notifyAllObserver(); } @Override public void notifyAllObserver() { for (Observer registered : obs) { registered.update(); } }}public class ObserverImpl implements Observer { @Override public void update() { System.out.println(&quot;update&quot;); }}public class Main { public static void main(String[] args) { Subject s = new SubjectImpl(); for (int i = 0; i &lt; 10; i++) { s.registerObserver(new ObserverImpl()); } s.notifyAllObserver(); }} java 内置的观察者模式Observable (Subject) 类与 Observor 接口 This class and the Observer interface have been deprecated. The event model supported by Observer and Observable is quite limited, the order of notifications delivered by Observable is unspecified, and state changes are not in one-for-one correspondence with notifications. For a richer event model, consider using the java.beans package. For reliable and ordered messaging among threads, consider using one of the concurrent data structures in the java.util.concurrent package. For reactive streams style programming, see the java.util.concurrent.Flow API.上述两个类 已经在 JDK9 中被废弃。愿意是因为其无法控制通知的顺序(因为调用的父类是 notify 方法，而且是从后向前遍历 observer 的)，而且由于 Observable 是一个类形式提供，难以扩展。 12345678910111213141516171819202122232425262728293031public class ObserverImpl implements Observer { @Override public void update() { System.out.println(&quot;update&quot;); }}public class SubjectImplUseJDK extends Observable { public Object msg; public void setMsg(Object msg) { this.msg = msg; // 1. 要先设置更改 setChanged(); // 2. 被动的传递消息 notifyObservers(msg); }}public class Main { public static void main(String[] args) { SubjectImplUseJDK b = new SubjectImplUseJDK(); for (int i = 0; i &lt; 10; i++) { b.addObserver(new ObserverImplUseJDK()); } b.setMsg(&quot;test&quot;); }} 装饰器装饰器可以方便的扩展原来的类不具备的方法。 符合 开闭原则 （对扩展开放，对修改关闭） 简单例子通过子类持有基类的引用，通过构造器对原始的对象进行运行时增强。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public abstract class Base { // 基类提供抽象方法 public abstract void base();}public class OneImpl extends Base { // 持有 Base 类型的属性 private Base base; public OneImpl(Base base) { this.base = base; } @Override public void base() { // 对原始的 base 做一个增强 base.base(); System.out.println(&quot;one&quot;); }}// 还可以用 abstract 进一步加强public abstract class TwoAbstract extends Base { public abstract void anotherAbstract();}public class TwoImpl extends TwoAbstract { private Base base; public TwoImpl(Base base) { this.base = base; } @Override public void base() { base.base(); System.out.println(&quot;Two&quot;); } @Override public void anotherAbstract() { System.out.println(&quot;another&quot;); }} java 中的例子java i/o 类 InputStream 及其子类，可以使用装饰器增强方法 一个 new BufferedInputStream(new FileInputStream(file));的调用流程分析如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// inputStream 的基类public abstract class InputStream implements Closeable { // 子类实现其方法 // 返回下一个字符 public abstract int read() throws IOException; // 基类提供的共有方法 读取 off + len 的 byte 到 byte中 public int read(byte b[], int off, int len) throws IOException { Objects.checkFromIndexSize(off, len, b.length); if (len == 0) { return 0; } int c = read(); if (c == -1) { return -1; } b[off] = (byte)c; int i = 1; try { for (; i &lt; len ; i++) { // 关键在这儿进行了动态绑定 实现了增强 c = read(); if (c == -1) { break; } b[off + i] = (byte)c; } } catch (IOException ee) { } return i; }}public class BufferedInputStream extends FilterInputStream { // 继承的 FilterInputStream 中包含了一个 inputStream 的实例引用 public BufferedInputStream(InputStream in) { this(in, DEFAULT_BUFFER_SIZE); } // 实现的 read 方法 public synchronized int read() throws IOException { // 读取的位置上的数字超过了 buffer 中已经保存的 if (pos &gt;= count) { // 调用 read 方法进行读取 fill(); if (pos &gt;= count) return -1; } return getBufIfOpen()[pos++] &amp; 0xff; } private void fill() throws IOException { /** * …… 读取已经设置游标等方法 **/ // 读取 buffer 完毕 count = pos; // 调用持有的 inputStream 的引用进行 read // 关键在这儿进行了增强 会在读取后 赋值 到 buffer 中 int n = getInIfOpen().read(buffer, pos, buffer.length - pos); if (n &gt; 0) count = n + pos; }}public class FileInputStream extends InputStream { public int read() throws IOException { return read0(); } private native int read0() throws IOException;} 工厂模式抽象对象的新建过程 简单工厂 简单工厂可以看做是对 new Object() 的简单抽象 工厂方法 上面是一个简单的例子，子类将会实现 abstract 的抽象工厂方法，将创建细节在子类中实现，提供一个抽象的工厂方法。 进一步，可以将其分为两类 Object （产品对应的接口） concreateObject(对应的具体产品实现类) abstract creator(抽象的工厂方法) creatorImpl(实现对 concreateObject 的初始化) 抽象工厂依赖倒置原则依赖抽象，不能依赖具体类。 因此，抽象工厂针对产品，也是对产品的抽象进行维护和管理，不能对具体产品进行管理，所以需要抽象一下两个部分 抽象工厂 抽象产品（具体的产品依赖这个 base 的抽象产品） 实现 针对产品和工厂进行抽象 甚至可以嵌套抽象工厂 进一步抽象 product 的初始化流程。 这样 client 只需要针对参数等情况 分发到不同的 factory 即可 单例模式全局共享一个变量 java 的单例模式 懒汉式 由于 类加载 是线程安全的，所知直接放到 中初始化 12345678910public class LazySingleton { private static final Object singleton = new Object(); // 保证不被初始化 private LazySingleton(){} public static Object getSingleton() { return singleton; }} 饿汉式 需要的时候再创建，为了保障多线程安全，创建的时候加锁 1234567891011121314public class HungrySingleton { private static final Object singleton; // 保证不被初始化 private HungrySingleton(){} public static Object getSingleton() { synchronized (HungrySingleton.class) { if (singleton == null) { singleton = new NeedSingletonClass(); } return singleton; } }} 双重校验锁 双重校验锁，初始化的时候使用 synchronized 保障线程安全，同时使用 volatile 保障指令不被重排序。 123456789101112131415161718192021public class DoubleCheckSingleton { // 防止指令重排序 因为 Object 对象生成有多个步骤，为了保障 // 其他线程能够使用该完整对象 private static volatile Object singleton; public static Object getSingleton() { // 防止多个线程堵塞 提高多线程性能 if (singleton == null) { synchronized(DoubleCheckSingleton.class) { // 在多个线程堵塞在时，防止 singleton 被重复初始化 if (singleton == null) { singleton = new Object(); } } } return singleton; }} 静态内部类 1234567891011121314151617// 使用静态内部类来保障安全// 原理是因为 静态内部类是懒加载的public class StaticClassSingleton { private StaticClassSingleton() {}; private static class InnerStaticClass { public static NeedSingletonClass singletonClass = new NeedSingletonClass(); } // 这儿是懒加载，在 innerStaticClass 里面的静态内部类被加载的时候 // 执行内部类的 &lt;clinit&gt; 方法进行初始化 // final 是为了保证这个方法不会被重写或者重载 public static final NeedSingletonClass getInstance() { return InnerStaticClass.singletonClass; }} 命令模式命令模式是为了封装不同的操作的不同 api 做的 如线程池等的实现、工作队列等也是跟命令模式相关 123456789101112131415161718192021222324252627282930313233343536373839404142public class Client { private CommandManager manager; public Client(CommandManager manager) { this.manager = manager; } public void execute(int id, Object args) { this.manager.execute(id, args); }}// 对不同 API 的调用封装成同一个 APIpublic interface Command { // 封装命令的细节 void execute(Object args);}public class CommandExecutor { void up() { System.out.println(&quot;executor up !&quot;); }}// 管理并初始化所有的 command 对象public class CommandManager { private Command[] commands; public CommandManager() { this.commands = new Command[1]; this.commands[0] = new CommandImpl(new CommandExecutor()); } // 根据传入的 command id 与 args 具体执行 public void execute(int commandID, Object args) { this.commands[commandID].execute(args); }} 适配器模式为了适配两种不同的方法的对象，让一种能够适应另一种添加的类 接口适配：实现对应的接口，通过组合的方式实现适配。 类适配：通过组合继承（java 不可能） 12345678910111213141516171819202122232425262728// 客户端调用的接口public interface Duck { void spark();}public class Dog { public void bark() { System.out.println(&quot;!!!!!!!!&quot;); }}public class DuckAdapter implements Duck { private Dog dog; public DuckAdapter(Dog dog) { this.dog = dog; } @Override public void spark() { this.dog.bark(); }} 外观模式 外观模式是一个向外暴露简单接口，对内进行包装的设计模式。用于封装复杂的逻辑,以减少对象之间的依赖。 最少知识原则: 减少对象间的交互，因此只应该调用以下范围的方法。 对象本身 方法参数传递的对象 此方法创建或实例化的对象 对象的任何组件 模板方法模板方法用于封装统一的抽象步骤。通过在父类中定义算法的运行流程，提供算法的默认实现并交给不同的子类进行重载完成。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public interface Action { // 定义下面将要使用的接口 void act();}// 定义抽象的流程public abstract class AbstractProcess implements Action { // 保障子类的行为有一定的共同性 // 提供 action 的默认实现 public void actionOne() { System.out.println(&quot;One&quot;); } // 提供 action 的默认实现 public void actionTwo() { System.out.println(&quot;Two&quot;); } // 可以再次提供 abstract 的默认实现 public abstract void actionThree(); // 可以在子类中实现 hook 方法 hook 住 act 执行的过程 public abstract void hook(); @Override public void act() { // 封装整体的算法调用逻辑 // 根据运行时 动态的选择方法表里面的方法 actionOne(); actionTwo(); actionThree(); hook(); }}// 这样可以保证底层组件 只需要关注实现方法细节 不需要关注其他public class ProcessImpl extends AbstractProcess { @Override public void actionThree() { System.out.println(&quot;process&quot;); } @Override public void hook() { System.out.println(&quot;hook&quot;); }} 迭代器模式迭代器模式用来提供统一的访问元素的接口，可以不用知道元素存储的具体细节访问。 通过 iterator 暴露统一的 遍历 接口。客户端通过保存所有数据的 Items 实现类创建对应的 iterator 完成数据的遍历操作。 单一责任：一个类应该只有一个引起变化的原因，所以需要把 Items 与 Iterator 分开实现。 简单的 iterator 实现 使用一个数值来表明现在访问到的位置 12345678910111213141516171819202122232425262728293031323334package iterator;// 作为 iterator 的基类public interface BaseIterator { boolean hasNext(); Object next();}package iterator;public class ArrayIterator implements BaseIterator { // 保存遍历的下标 private int index; // 遍历的数组 private int[] nums; public ArrayIterator(int[] nums) { this.nums = nums; this.index = 0; } @Override public boolean hasNext() { return this.index &lt; nums.length; } @Override public Object next() { return this.nums[this.index++]; }} 在树状结构中进行迭代的方式相当于组合迭代器，问如果在 [1,[2,3,[2,34],3]] 这种中间实现 iterator 该如何处理。 例题- 扁平化嵌套列表迭代器 空数组即 [[]] 返回 null 的解法使用递归的思想，在 iterator 中保存每次遍历的 iterator 这样在遇到深层次的嵌套的时候，会在每一个 iterator 中保存 下一层次的引用，最后得到结果 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117import java.util.*;public class NestedIteratorNew implements Iterator&lt;Integer&gt; { // 给定一个 nexted 的数组 // 问如何去遍历它 // 这儿使用组合的方式去生成 nextedList 然后再用 stack 存储遍历的 iterator private static interface NestedInteger { // @return true if this NestedInteger holds a single integer, rather than a nested list. public boolean isInteger(); // @return the single integer that this NestedInteger holds, if it holds a single integer // Return null if this NestedInteger holds a nested list public Integer getInteger(); // @return the nested list that this NestedInteger holds, if it holds a nested list // Return null if this NestedInteger holds a single integer public List&lt;NestedInteger&gt; getList(); } // 提供的默认实现类 private static class NestedIntegerImpl implements NestedInteger { private int num; private List&lt;NestedInteger&gt; list; private boolean isNum; public NestedIntegerImpl(int num) { this.num = num; this.isNum = true; } public NestedIntegerImpl(List&lt;NestedInteger&gt; list) { this.list = list; this.isNum = false; } @Override public boolean isInteger() { return this.isNum; } @Override public Integer getInteger() { return this.num; } @Override public List&lt;NestedInteger&gt; getList() { return this.list; } } // stack 来保存每次转换的出来的 iterator 相当于 next 调用的时候去找到的是 stack top 里的 iterator Deque&lt;Iterator&lt;NestedInteger&gt;&gt; stack; public NestedIteratorNew(List&lt;NestedInteger&gt; nestedList) { this.stack = new LinkedList&lt;&gt;(); // 初始化加入的节点 this.stack.addLast(nestedList.iterator()); } @Override public Integer next() { if (hasNext()) { Iterator&lt;NestedInteger&gt; iterator = this.stack.peekLast(); NestedInteger i = iterator.next(); if (!i.isInteger()) { stack.addLast(i.getList().iterator()); return next(); } return i.getInteger(); } return null; } @Override public boolean hasNext() { if (this.stack.size() &gt; 0) { Iterator&lt;NestedInteger&gt; top = this.stack.peekLast(); if (top.hasNext()) return true; // 这个时候 top 的 iterator 访问完毕了 去访问下面的 iterator this.stack.removeLast(); // 只需要递归的调用 访问 栈即可 return hasNext(); } return false; } public static void main(String[] args) { List&lt;NestedInteger&gt; test = new ArrayList&lt;&gt;();// List&lt;NestedInteger&gt; one = new ArrayList&lt;&gt;();// one.add(new NestedIntegerImpl(1));// one.add(new NestedIntegerImpl(1));// test.add(new NestedIntegerImpl(one));// test.add(new NestedIntegerImpl(2));// List&lt;NestedInteger&gt; three = new ArrayList&lt;&gt;(); test.add(new NestedIntegerImpl(new ArrayList&lt;&gt;()));//// three.add(new NestedIntegerImpl(1));// three.add(new NestedIntegerImpl(1));// test.add(new NestedIntegerImpl(three));// test.add(new NestedIteratorNew.NestedIntegerImpl(new ArrayList&lt;&gt;()));// test.add(new NestedIteratorNew.NestedIntegerImpl(2));// test.add(new NestedIteratorNew.NestedIntegerImpl(new ArrayList&lt;&gt;() {{// List&lt;NestedInteger&gt; two = new ArrayList&lt;&gt;();// two.add(new NestedIteratorNew.NestedIntegerImpl(new ArrayList&lt;&gt;()));// add(new NestedIteratorNew.NestedIntegerImpl(two));// add(new NestedIteratorNew.NestedIntegerImpl(3));// }})); NestedIteratorNew it = new NestedIteratorNew(test); while (it.hasNext()) { System.out.println(it.next()); } }} 空数组不返回的结果由于上一个方法不能保证返回的时候，嵌套空数组返回 null。 所以，实际上只能在 hasNext() 调用的过程中去处理这种事情，保证每次从 stack 栈中获取的都是数字，不会存在 null 这种情况。 所以需要在 hasNext() 调用的过程中进行铺平操作，递归的调用，直到栈顶是一个带有数字的 iterator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.util.*;public class NestedIteratorNotReturnNull implements Iterator&lt;Integer&gt; { // 为了不返回 null 所以要在 hasNext 中就将所有数据准备好 private Deque&lt;Iterator&lt;NestedInteger&gt;&gt; stack; public NestedIteratorNotReturnNull(List&lt;NestedInteger&gt; nestedList) { this.stack = new LinkedList&lt;&gt;(); this.stack.addLast(nestedList.iterator()); } @Override public boolean hasNext() { // 拉平所有的 iterator while (!this.stack.isEmpty()) { // 已经拉平了一个状态了 Iterator&lt;NestedInteger&gt; top = this.stack.peekLast(); if (!top.hasNext()) { this.stack.removeLast(); continue; } // 每次处理一个 NestedInteger next = top.next(); if (next.isInteger()) { // 已经找到了一个数字 直接返回 this.stack.addLast(Collections.singletonList(next).iterator()); return true; } this.stack.addLast(next.getList().iterator()); } return false; } @Override public Integer next() { // hasNext 中已经将数据和结果准备好 return stack.peekLast().next().getInteger(); } private static interface NestedInteger { // @return true if this NestedInteger holds a single integer, rather than a nested list. public boolean isInteger(); // @return the single integer that this NestedInteger holds, if it holds a single integer // Return null if this NestedInteger holds a nested list public Integer getInteger(); // @return the nested list that this NestedInteger holds, if it holds a nested list // Return null if this NestedInteger holds a single integer public List&lt;NestedInteger&gt; getList(); } // 提供的默认实现类 private static class NestedIntegerImpl implements NestedInteger { private int num; private List&lt;NestedInteger&gt; list; private boolean isNum; public NestedIntegerImpl(int num) { this.num = num; this.isNum = true; } public NestedIntegerImpl(List&lt;NestedInteger&gt; list) { this.list = list; this.isNum = false; } @Override public boolean isInteger() { return this.isNum; } @Override public Integer getInteger() { return this.num; } @Override public List&lt;NestedInteger&gt; getList() { return this.list; } }} 状态模式（状态机）状态模式抽象状态操作，进行统一的调配，这样可以方便修改添加功能。因为这样才能满足对扩展开放，对修改关闭的效果。 以书上的例子为例，这个有以下几个状态及其转换关系 抽象 state 状态 123456789101112package status;public interface State { void insertQuarter() throws Exception; void turnCrank() throws Exception; void ejectQuarter() throws Exception; void dispense() throws Exception;} 实现各种状态 123456789101112131415161718192021222324252627282930313233package status;public class HasQuarterState implements State { // 暴露 context 是为了能够在 state 中操作 context 进行状态转移 private Context context; public HasQuarterState(Context context) { this.context = context; } @Override public void insertQuarter() throws Exception { throw new RuntimeException(&quot;无法重复投币&quot;); } @Override public void turnCrank() throws Exception { this.context.setCurrentState(context.getSoldState()); } @Override public void ejectQuarter() throws Exception { // 操作 context 进行状态转移 this.context.setCurrentState(context.getNoQuarterState()); } @Override public void dispense() throws Exception { throw new RuntimeException(&quot;还未 turn crank 无法获取&quot;); }} context 实现对于 state 的管理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package status;public class Context implements State { private final State noQuarterState; private final State hasQuarterState; private final State soldOutState; private final State soldState; private State currentState; private int count; public Context(int count) { this.count = count; this.hasQuarterState = new HasQuarterState(this); this.noQuarterState = new NoQuarterState(this); this.soldOutState = new SoldOutState(this); this.soldState = new SoldState(this); this.currentState = this.noQuarterState; } // 表示剩余资源的数量 进行减一操作 public void releaseCount() { this.count--; } public int getCount() { return count; } public void setCurrentState(State currentState) { this.currentState = currentState; } public State getNoQuarterState() { return noQuarterState; } public State getHasQuarterState() { return hasQuarterState; } public State getSoldOutState() { return soldOutState; } public State getSoldState() { return soldState; } // 暴露 state 的操作 @Override public void insertQuarter() throws Exception { this.currentState.insertQuarter(); } @Override public void turnCrank() throws Exception { this.currentState.turnCrank(); } @Override public void ejectQuarter() throws Exception { this.currentState.ejectQuarter(); } @Override public void dispense() throws Exception { this.currentState.dispense(); } @Override public String toString() { return &quot;Context{&quot; + &quot;currentState=&quot; + currentState + &quot;, count=&quot; + count + '}'; } public static void main(String[] args) { State c = new Context(5); try { c.insertQuarter(); c.turnCrank(); c.dispense(); System.out.println(c); c.insertQuarter(); c.ejectQuarter();// c.turnCrank(); } catch (Exception e) { System.out.println(e.getMessage()); } }} 代理模式代理模式也是对一个对象进行增强的模式，我理解的话。 通过持有真实的对象，向外暴露相同的方法，对数据进行动态增强。 java 动态代理java 会在运行时创建代理类(返回生成类的 byte[] 并使用类加载器加载)，通过继承 Proxy 类实现 Subject 接口的方式实现。具体可以参考下面的文章 责任链模式责任链设计模式是一种对链式调用更高级的抽象，能够把链式函数执行的控制权下放到链中间，在执行链的过程中，可以在调用下一个链式过程前和后处理进行额外的处理。java 中实现的主体逻辑也采用下面的方法实现。 主要分为两个部分 处理函数，即承担链式函数逻辑的实现 管理部分，即管理链调用过程的部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package chain;@FunctionalInterfacepublic interface Process { void process(Chain c);}import java.util.ArrayList;import java.util.List;public class Chain { List&lt;Process&gt; handlers; int index; public Chain() { this.index = -1; this.handlers = new ArrayList&lt;&gt;(); } public void register(Process ...processes) { this.handlers.addAll(Arrays.asList(processes)); } public void next() { this.index++; // 为了保证链式函数中没有被显式调用 .next() 的地方也能够被执行 while (this.index &lt; this.handlers.size()) { this.handlers.get(this.index).process(this); this.index++; } } public static void main(String[] args) { Process p1 = (c) -&gt; { System.out.println(&quot;first start&quot;); c.next(); System.out.println(&quot;first end&quot;); }; Process p2 = (c) -&gt; { System.out.println(&quot;second start&quot;); c.next(); System.out.println(&quot;second end&quot;); }; Chain c = new Chain(); c.register(p1); c.register(p2); c.next(); }} golang gin 中的链实现gin gin 也是使用责任链的方式来处理对某一个请求的链式调用的。可以通过如下的方法实现一个链式调用的过程。 12345router.GET(&quot;/example&quot;, func(c *Context) {}, func(context *Context) { }) 其中 Context 是一个被复用的上下文，保存 http 请求的 header、writer、body 等信息。在运行时被动态的添加对应的 handlerChain 到 context 中进行链式调用执行。 TODO：字符匹配的前缀树。goland 使用一个 radix 树来存储请求路径，每个 request method 会包含一个对应的 tree。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// serveHttp 的入口func (engine *Engine) handleHTTPRequest(c *Context) { httpMethod := c.Request.Method rPath := c.Request.URL.Path unescape := false if engine.UseRawPath &amp;&amp; len(c.Request.URL.RawPath) &gt; 0 { rPath = c.Request.URL.RawPath unescape = engine.UnescapePathValues } if engine.RemoveExtraSlash { rPath = cleanPath(rPath) } // Find root of the tree for the given HTTP method // 1. 找到对应的 tree 上的节点 t := engine.trees for i, tl := 0, len(t); i &lt; tl; i++ { if t[i].method != httpMethod { continue } root := t[i].root // Find route in tree value := root.getValue(rPath, c.params, unescape) if value.params != nil { c.Params = *value.params } if value.handlers != nil { // 2. 将当前的 tree 上注册的 handler 填充到 context 中 c.handlers = value.handlers c.fullPath = value.fullPath // 3. 执行 handler chain c.Next() c.writermem.WriteHeaderNow() return } if httpMethod != &quot;CONNECT&quot; &amp;&amp; rPath != &quot;/&quot; { if value.tsr &amp;&amp; engine.RedirectTrailingSlash { redirectTrailingSlash(c) return } if engine.RedirectFixedPath &amp;&amp; redirectFixedPath(c, root, engine.RedirectFixedPath) { return } } break } if engine.HandleMethodNotAllowed { for _, tree := range engine.trees { if tree.method == httpMethod { continue } if value := tree.root.getValue(rPath, nil, unescape); value.handlers != nil { c.handlers = engine.allNoMethod serveError(c, http.StatusMethodNotAllowed, default405Body) return } } } c.handlers = engine.allNoRoute serveError(c, http.StatusNotFound, default404Body)} 所以其实，gin 中将表示和实际执行分为了两个部分 执行 链的执行包含在 context 中，通过 context.next() 调用链的下一个方法 12345678910func (c *Context) Next() { // 使用 index 标识现在访问到的节点下标 c.index++ // 使用 for 循环，这样可以保证在 handler 中不显示调用 next 方法 // 也能执行完调用链 for c.index &lt; int8(len(c.handlers)) { c.handlers[c.index](c) c.index++ }} 表示 链自身的标识，由于链需要在调用的时候调用下一个方法，所以需要一个 context 的引用进行调用，golang 使用 type 给了对应的 chain alias，实际其就是一个 handlerFunc 的切片 12345// HandlersChain defines a HandlerFunc array.type HandlersChain []HandlerFunc// HandlerFunc defines the handler used by gin middleware as return value.type HandlerFunc func(*Context) 链的注册，是通过 routerGroup 管理，每个 routerGroup 对应一个大链接下的小链接 1234567891011121314151617181920212223242526272829303132333435// POST is a shortcut for router.Handle(&quot;POST&quot;, path, handle).// 1. 首先将当前针对一个 request method 的方法的链式调用注册func (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes { return group.handle(http.MethodPost, relativePath, handlers)}// 2. 与之前注册到 group 上的 handler 进行合并func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes { absolutePath := group.calculateAbsolutePath(relativePath) handlers = group.combineHandlers(handlers) group.engine.addRoute(httpMethod, absolutePath, handlers) return group.returnObj()}// 3. 添加 handler 的绝对路径 与 对应的 handlerChain 到 radix tree 结构中func (engine *Engine) addRoute(method, path string, handlers HandlersChain) { assert1(path[0] == '/', &quot;path must begin with '/'&quot;) assert1(method != &quot;&quot;, &quot;HTTP method can not be empty&quot;) assert1(len(handlers) &gt; 0, &quot;there must be at least one handler&quot;) debugPrintRoute(method, path, handlers) root := engine.trees.get(method) if root == nil { root = new(node) root.fullPath = &quot;/&quot; engine.trees = append(engine.trees, methodTree{method: method, root: root}) } root.addRoute(path, handlers) // Update maxParams if paramsCount := countParams(path); paramsCount &gt; engine.maxParams { engine.maxParams = paramsCount }} js koa 中的洋葱模型实现js 的实现就简单很多了，koa 的实现可以参考 koa-compose 其本质思想与上面一个差不多，但是由于 js 支持闭包，也支持将 func bind 一个运行时，因此其在调用的时候，传递的是注册到 chain 中的下一个 function，所以直接执行即可。但是也因此，其必须要调用显示的 next() 方法。 12345678910111213141516171819202122232425262728293031323334function compose (middleware) { if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!') for (const fn of middleware) { if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!') } /** * @param {Object} context * @return {Promise} * @api public */ // compose 执行完毕后，相当于把这个闭包结构声明完毕 return function (context, next) { // last called middleware # // 用闭包来保存当前调用的到 middleware 中的哪一个 let index = -1 // 返回 middleware 的入口 return dispatch(0) // 只需要 compose 结束后 执行该方法即可 function dispatch (i) { if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try { // fn 会执行当前的 middleware 同时将 下一个 dispatch 传递给新的 fn 方法作为第二个参数调用 return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); } catch (err) { return Promise.reject(err) } } }}","link":"/2021/03/09/design-pattern/"},{"title":"leetcode","text":"leetcode 例题记录下 leetcode 值得记录的例题 kmp 算法kmp 算法的原始实现方法在另一篇里面已经写过，实际上就是通过记录模式串的相同的前后缀长度来跳过模式串重新匹配的距离。 123456789101112131415161718192021222324252627282930313233343536373839public int[] getNext(String pattern) { int[] next = new int[pattern.length()]; next[0] = -1; // 模式串相差一进行匹配 int k = -1, j = 0; while (j &lt; pattern.length() - 1) { // 匹配相同的字符 if (k == -1 || pattern.charAt(k) == pattern.charAt(j)) { k++; j++; next[j] = k; } else { k = next[k]; } } return next;}public int match(String s, String pattern) { int[] next = getNext(pattern); int i = 0, j = 0; while (i &lt; s.length() &amp;&amp; j &lt; pattern.length()) { if (s.charAt(i) == pattern.charAt(j)) { i++; j++; } else { // 失配 重新定位 j = next[j]; } } if (j == pattern.length()) { return i - j; } else { return -1;// 没有找到 }} 最短回文串给定一个字符串，问在字符串左边添加一些字母后，形成一个回文串，问形成的回文串中，最短的回文串什么。 超时解法 最开始的暴力思维，想得就是遍历这个字符串，找到中间可以作为分隔线的地方（因为回文串其实可以看成在一个分隔点的左右镜像），然后遍历所有的分割线，比较生成的最短回文串。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution { // 只能在字符串前面添加 public String shortestPalindrome(String s) { if (s.equals(&quot;&quot;)) return &quot;&quot;; String min = null; // 作为 palindrome 的中心点 进行遍历 for (int i = 0; i &lt;= s.length() / 2; i++) { String odd = odd(i, s); String even = even(i, s); String tmp = &quot;&quot;; if (odd.equals(&quot;&quot;) &amp;&amp; even.equals(&quot;&quot;)) { continue; } if (odd.equals(&quot;&quot;)) tmp = even; if (even.equals(&quot;&quot;)) tmp = odd; if (!odd.equals(&quot;&quot;) &amp;&amp; !even.equals(&quot;&quot;)) { tmp = even.length() &gt; odd.length() ? odd: even; } if (min == null) min = tmp; else if (min.length() &gt; tmp.length()) { min = tmp; } } return min; } private String odd(int i, String s) { int left = i - 1, right = i + 1; // 考虑最后的 palindrome 是奇数长度情况 boolean canPalindrome = true; while (left &gt;= 0 &amp;&amp; right &lt; s.length()) { if (s.charAt(left) != s.charAt(right)) { // 不能形成 canPalindrome = false; break; } left--; right++; } String tmp = &quot;&quot;; if (!canPalindrome) return tmp; // 左边为 -1 说明右边长要把右边的加载左边 if (left == -1) { StringBuilder builder = new StringBuilder(s.substring(right)); tmp = builder.reverse().toString() + s; } return tmp; } private String even(int i, String s) { int left = i - 1, right = i; // 考虑最后的 palindrome 是奇数长度情况 boolean canPalindrome = true; while (left &gt;= 0 &amp;&amp; right &lt; s.length()) { if (s.charAt(left) != s.charAt(right)) { // 不能形成 canPalindrome = false; break; } left--; right++; } String tmp = &quot;&quot;; if (!canPalindrome) return tmp; // 左边为 -1 说明右边长要把右边的加载左边 if (left == -1) { StringBuilder builder = new StringBuilder(s.substring(right)); tmp = builder.reverse().toString() + s; } return tmp; }} 前后缀思维 其实考虑一个最长的回文串的，肯定是把输入串的逆向输入串拼接到原始字符串的左边。 那么，如果这个逆向的字符串有一部分跟输入串的前一部分是重合的就可以缩短整个长度。 比如 abaaa 与其逆 aaaba 在红色的地方重合 即 abaaa 的前缀 a 与 aaaba 的后缀 a 重合 所以 只需要遍历得到这个相同的前后缀即可。 下述算法，由于需要判断 equals 因此其执行效率趋近 o(n^2) 12345678910111213public String shortestPalindrome(String s) { String reverse = new StringBuilder(s).reverse().toString(); // 因为从后向前 可以直接返回 找到的第一个 一定是最长的相同前后缀 for (int i = s.length(); i &gt;= 0; i--) { // 前缀等于后缀 if (s.subString(0, i).equals(reverse.subString(s.length() - i))) { // 这个时候只需要加上 reverse 去除后缀的部分 return reverse.subString(0, s.length() - i) + s; } } return &quot;&quot;;} kmp 思维 上面采用前后缀的方式其实已经接近了 kmp 的思维方式，不过是比较朴素的解法，因为这个时候还可以进一步得到，实际上就是求原串的最长回文前缀，因为这样逆串，反转过来后，与其回文前缀相等的部分，可以直接消去。 那么可以直接拼接成一个最长的字符串，即 s + &quot;#&quot; + reverse 那么只需要找到这个字符串结尾的部分相等的前后缀长度，即可以在返回结果的时候删除重复的部分。所以可用 kmp 的 next 数组求法找到最长的前后缀，既可以将时间复杂度进一步降低。 12345678910111213141516171819202122232425262728293031public class ShortestPalindromeNew_214 { // keep 春招就考的这个 public String shortestPalindrome(String s) { String reverse = new StringBuilder(s).reverse().toString(); String addedStr = s + &quot;#&quot; + reverse; int len = getMaxMatchLen(addedStr); return reverse.substring(0, reverse.length() - len) + s; } // 找到从末尾开始的前后缀的最长匹配长度 public int getMaxMatchLen(String s) { int[] next = new int[s.length() + 1]; next[0] = -1; int k = -1, j = 0; while (j &lt; s.length()) { if (k == -1 || s.charAt(k) == s.charAt(j)) { k++; j++; next[j] = k; } else { k = next[k]; } } return next[s.length()]; }} 单调栈找出最具竞争力的子序列找到其中的一个子序列，满足其字符串比较是最小的结果。 brute-force 其实查看题意的话，最主要的就是不停的找到最小的数字 如果最小的数字 右侧的数字数量大于等于剩下要找的数量，说明继续向右侧寻找最小数 如果小于要找的数量，说明现在最小的数及其右侧所有的数字已经组成答案的一部分，因为这个最小数字形成的这个子序列一定是当前这个最小的 重复寻找上述过程，直到所有的数字被填充 因此上述过程是一个递归的过程（递归超时，实际上如果能够保存 i -&gt; j 的最小值的位置的话，就不用在递归中每次寻找了，应该能节约很多时间） 1234567891011121314151617181920212223242526272829303132// 同一个位置上的数字更小的 int[] 更具竞争力// 问长度为 k 的 int[] 的最有竞争力的结果是什么// 找到最小的 看后面的数 是否满足剩下的大小 不然就往前找 找到剩下的最小的public int[] mostCompetitiveBruteForce(int[] nums, int k) { if (k &gt; nums.length) return new int[k]; if (k == nums.length) return nums; int[] res = new int[k]; recursion(nums, res, 0, nums.length - 1, 0, res.length - 1); return res;}// 直接使用递归 每次找到 i-&gt;j 的最小值 然后判断去什么其他地方填充即可public void recursion(int[] nums, int[] res, int i, int j, int n, int m) { if (n &gt; m) return; int min = i; for (int k = i; k &lt;= j; k++) { if (nums[k] &lt; nums[min]) min = k; } // 剩下的数字不足以填满 m if (j - min + 1 &lt;= m - n + 1) { for (int k = j; k &gt;= min; k--) { res[m--] = nums[k]; } recursion(nums, res, i, min - 1, n, m); return; } // 还足够填满 从剩下的里面取较小的数字 然后填满 res[n++] = nums[min]; recursion(nums, res, min + 1, j, n, m);} 单调栈 实际上题目寻找的是最小的数字形成的结果，那么可以用一个单调栈来保存前面的访问的数组，如果当前访问的数字比之前的数字小的话，说明应该从这个数字之后开始寻找，其结果也就是把之前的数组弹出栈 12345678910111213141516171819202122232425262728public int[] mostCompetitive(int[] nums, int k) { if (k &gt; nums.length) return new int[k]; if (k == nums.length) return nums; int[] res = new int[k]; // 单调栈 Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { int num = nums[i]; // 如果当前数字比 stack 里面的要小 说明概要弹出 // 或者num 后剩下的长度不够了就不能弹出了 while (!stack.isEmpty() &amp;&amp; stack.peekLast() &gt; num &amp;&amp; k - stack.size() &lt; nums.length - i) { stack.removeLast(); } if (stack.size() &lt; k) { stack.addLast(num); } } k--; while (k &gt;= 0) { res[k] = stack.removeLast(); k--; } return res;} 下一个更大元素 II 示例 输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2； 数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 用单调栈来保存之前遍历过的路径，之后访问的数字如果比路径上的数字大的话，说明对于栈中保存的路径上的数字下一个更大的数是当前访问的数。 12345678910111213141516171819public int[] nextGreaterElements(int[] nums) { // 优化循环 int n = nums.length; int[] res = new int[n]; // 添加的默认值 Arrays.fill(res, -1); // 单调栈保存 nums 中的下标 Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); // 因为是循环数组 所以遍历到最后一个的时候 还要看其左侧的 // 所以相当于是两倍长度 for (int i = 0; i &lt; 2 * n - 1; i++) { // stack 里面放置的都是比 nums[i % n] 小的数 在其被弹出的时候 说明之后第一个比他大的数 就是访问的 nums[i % n] while (!stack.isEmpty() &amp;&amp; nums[i % n] &gt; nums[stack.peek()]) { res[stack.pop()] = nums[i % n]; } stack.push(i % n); } return res;} 移调 k 位数字 问如果在原始字符串中，移掉 k 位数字，最后形成的最小字符串是什么 如果 k 大于等于原来字符串的长度，那么就相当于删除了所有的数字，直接返回 “0” 即可 考虑 k 小于的情况 既然要删除数字，先考虑删除一个数字的情况，如 45 中删除一个数字，那么结果就是删除5 保留4，考虑 54 也是删除5 保留4 那既然如此，也就是说，从字符串中删除一个数字的话相当于删除的数字之前的一个数替代当前这位数，那么要使结果更小，替代的这个数一定要小于之前的删除的那个数，即 Dk &lt; D(k-1) 删除 Dk 每次遍历删除一个数字 12345678910111213141516171819202122232425262728public String removeKdigitsDeleteOne(String num, int k) { // 移除所有的数字 if (k &gt;= num.length()) return &quot;0&quot;; while (k &gt; 0) { num = deleteOne(num); k--; } // 去除前导 0 StringBuilder builder = new StringBuilder(); int i = 0; while (i &lt; num.length()) { if (num.charAt(i) != '0') break; i++; } while (i &lt; num.length()) { builder.append(num.charAt(i++)); } return builder.length() == 0 ? &quot;0&quot; : builder.toString();}private String deleteOne(String num) { for (int i = 1; i &lt; num.length(); i++) { // 现在可以删除 i - 1 这个位置的数了 if (num.charAt(i) &lt; num.charAt(i - 1)) return num.substring(0, i - 1) + num.substring(i); } // 删除最后一个数字 return num.substring(0, num.length() - 1);} 单调栈 每次去删除的一个数字的时间效率太低，因此可以考虑用一个单调栈来保存小于当前数的数字，当遍历到的下标大于单调栈的尾时，说明前面的数字该删除了 123456789101112131415161718192021222324252627282930313233public String removeKdigits(String num, int k) { // 移除所有的数字 if (k &gt;= num.length()) return &quot;0&quot;; // 删除数字的话 一定要删除的是 前面一个数字 大于 后面一个数字的地方 // 因为这样才能在删除后保证剩下的形成更小的结果 Deque&lt;Character&gt; queue = new LinkedList&lt;&gt;(); for (char c : num.toCharArray()) { // 单调栈中保存之前的结果 while (!queue.isEmpty() &amp;&amp; queue.peekLast() &gt; c &amp;&amp; k &gt; 0) { queue.removeLast(); k--; } queue.add(c); } // 剩下的 一定是一个从小到大的序列 while (k &gt; 0) { k--; queue.removeLast(); } StringBuilder builder = new StringBuilder(); while (!queue.isEmpty()) { if (queue.peekFirst() == '0') queue.removeFirst(); else break; } while (!queue.isEmpty()) { builder.append(queue.removeFirst()); } return builder.length() == 0 ? &quot;0&quot; : builder.toString();} 滑动窗口最小覆盖子串滑动窗口 当前遍历的字符串没有包含所有字符的时候，右移右游标 然后左移左游标，直到不再包含该字符串 在移动窗口的时候不听比较即可 123456789101112131415161718192021222324252627282930313233func checkEqualMap(mapForT, window map[int32]int) bool { for k, v := range mapForT { if count, ok := window[k]; !ok || count &lt; v { return false } } return true}func minWindow(s string, t string) string { i, j := 0, 0 res := &quot;&quot; mapForT := make(map[int32]int) for _, char := range t { mapForT[char]++ } window := make(map[int32]int) for j &lt; len(s) || i &lt; j { for j &lt; len(s) &amp;&amp; !checkEqualMap(mapForT, window) { window[int32(s[j])]++ j++ } if checkEqualMap(mapForT, window) &amp;&amp; (res == &quot;&quot; || len(res) &gt; j-i) { res = s[i:j] } window[int32(s[i])]-- i++ } return res} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { // 返回true 说明里面已经包含了一个完整的 t 字符串 public boolean checkMap(HashMap&lt;Character, Integer&gt; mapForT, HashMap&lt;Character, Integer&gt; mapForS) { for (Character key : mapForT.keySet()) { if (!mapForS.containsKey(key) || mapForS.get(key) &lt; mapForT.get(key)) return false; } return true; } public String minWindow(String s, String t) { // 这都是不存在的 if (s == null || t == null || s.length() &lt; t.length()) return &quot;&quot;; String minStr = null; HashMap&lt;Character, Integer&gt; mapForT = new HashMap&lt;&gt;(); for (char character : t.toCharArray()) { if (!mapForT.containsKey(character)) { mapForT.put(character, 1); } else { mapForT.put(character, mapForT.get(character) + 1); } } HashMap&lt;Character, Integer&gt; mapForS = new HashMap&lt;&gt;(); for (int i = 0; i &lt; t.length(); i++) { Character character = s.charAt(i); if (!mapForS.containsKey(character)) { mapForS.put(character, 1); } else { mapForS.put(character, mapForS.get(character) + 1); } } // 滑动窗口大小 int left = 0, right = t.length() - 1; do { while (checkMap(mapForT, mapForS) &amp;&amp; right - left + 1 &gt;= t.length()) { if (minStr == null || minStr.length() &gt; right - left + 1) { minStr = s.substring(left, right + 1); } mapForS.put(s.charAt(left), mapForS.get(s.charAt(left)) - 1); left++; } right++; if (right &gt;= s.length()) continue; if (!mapForS.containsKey(s.charAt(right))) { mapForS.put(s.charAt(right), 1); } else { mapForS.put(s.charAt(right), mapForS.get(s.charAt(right)) + 1); } } while (right &lt;= s.length() - 1 &amp;&amp; right - left + 1 &gt; t.length()); return minStr == null ? &quot;&quot; : minStr; }} K 个不同整数的子数组找到 A 里面的连续子数组，其中子数组里面的数据的 distinct 只有 K 个 这个题目一想就是滑动窗口 但是 很不好计算 等于 K 的时候 数组有多少个 但是计算 小于等于 K 的比较好计算，可以依据以下规则 以 [1,2,1,2,3] 为例，左边界固定的时候，恰好存在 2 个不同整数的子区间为 [1,2],[1,2,1],[1,2,1,2]，总数为 3。其值为下标 3 - 1 + 1，即区间 [1..3] 的长度。 因为，left, right 同时圈定了一组满足 &lt;= k 的题意的长度范围 那么，包含 left 的子数组数量肯定是 right - left + 1，因为相当于每次给数组里面添加一个数([1,2] [1,2,1] [1,2,1,2]) 所以 right 比 left 多几个数 就能形成几个子数组 12345678910111213141516171819202122232425262728func subarraysWithKDistinct(A []int, K int) int { return atMostK(A, K) - atMostK(A, K-1)}// 因为求解 恰好K 不好弄 求解 最大K 比较好弄func atMostK(A []int, K int) int { i, j := 0, 0 // 作为一个 set 保存窗口内的所有 distinct 数据 window := make(map[int]int) res := 0 for j &lt; len(A) { window[A[j]]++ j++ for len(window) &gt; K { window[A[i]]-- if window[A[i]] == 0 { delete(window, A[i]) } i++ } res += j - i + 1 } return res} 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;public class SubarraysWithKDistinct_992 { // 如果 A 里面 public int subarraysWithKDistinct(int[] A, int K) { return subArraysDistinctAtMostK(A, K) - subArraysDistinctAtMostK(A, K - 1); } // 计算最多的有多少个的话 可以固定左边界 然后计算 private int subArraysDistinctAtMostK(int[] array, int k) { Map&lt;Integer, Integer&gt; window = new HashMap&lt;&gt;(); int res = 0; int left = 0, right = 0; while (right &lt; array.length) { // 固定左边界 移动右边界 window.put(array[right], window.getOrDefault(array[right], 0) + 1); // 这边已经需要减除了 while (left &lt;= right &amp;&amp; window.size() &gt; k) { window.put(array[left], window.get(array[left]) - 1); if (window.get(array[left]) == 0) window.remove(array[left]); left++; } // 这个地方是因为右边界到左边之间的数字 一定是小于等于 K 个不同的数字的 // 那么能够以左边界形成的 一定是中的一个子数组 如 // 以 [1,2,1,2,3] 为例，左边界固定的时候，恰好存在 2 个不同整数的子区间为 [1,2],[1,2,1],[1,2,1,2]，总数为 3。其值为下标 3 - 1 + 1，即区间 [1..3] 的长度。 res += right - left; right++; } return res; } public static void main(String[] args) { System.out.println(new SubarraysWithKDistinct_992().subarraysWithKDistinct(new int[]{1,2,1,2,3}, 2)); System.out.println(new SubarraysWithKDistinct_992().subarraysWithKDistinct(new int[]{1,2,1,3,4}, 3)); }} 最大连续 1 的个数 III最大连续 1 的个数，A 中只有 0 和 1，其中可以变换最多 K 个 0 成为 1，问最长的连续 1 的长度为多少 滑动窗口，窗口中最多含有 K 个 0 即可 123456789101112131415161718192021222324252627282930func longestOnes(A []int, K int) int { // 返回值 res := 0 left, right := 0, 0 zeros := 0 for right &lt; len(A) { // 用外层循环带动 right 移动 if A[right] == 0 { zeros++ } // 这个时候要移动左侧的 left 保障 zeros 小 for zeros &gt; K { if A[left] == 0 { zeros-- } left++ } // 每轮都去比较即可 res = max(res, right - left + 1) right++ } return res}func max(a, b int) int { if a &gt; b { return a } return b} 绝对差不超过限制的最长连续子数组 给定一个数组 nums 和 limit，找到最长的连续数组，其中任意两个数的差值不超过 limit 上面这句话换个说法说的就是 最大值和最小值 之差不超过 limit，因此如果能够 o(1) 的拿到窗口的 最大最小值，那么就比较方便 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package classictype MaxMinQueue struct { stack1 MaxMinStack stack2 MaxMinStack}func (queue *MaxMinQueue) Push(val int) { queue.stack1.Push(val)}func (queue *MaxMinQueue) Shift() int { if queue.stack2.Len() == 0 { for queue.stack1.Len() &gt; 0 { queue.stack2.Push(queue.stack1.Pop()) } } return queue.stack2.Pop()}func (queue *MaxMinQueue) Max() int { if queue.stack1.Len() == 0 { return queue.stack2.Max() } else if queue.stack2.Len() == 0 { return queue.stack1.Max() } return max(queue.stack2.Max(), queue.stack1.Max())}func (queue *MaxMinQueue) Min() int { if queue.stack1.Len() == 0 { return queue.stack2.Min() } else if queue.stack2.Len() == 0 { return queue.stack1.Min() } return min(queue.stack2.Min(), queue.stack1.Min())}func (queue *MaxMinQueue) Len() int { return queue.stack1.Len() + queue.stack2.Len()}type MaxMinStack struct { // 这两个不用 slice 用 list 之类的链表 可能会快一点儿 data []int maxes []int mins []int}func (ms *MaxMinStack) Push(val int) { ms.data = append(ms.data, val) if len(ms.maxes) &gt; 0 { ms.maxes = append(ms.maxes, max(ms.maxes[len(ms.maxes)-1], val)) } else { ms.maxes = append(ms.maxes, val) } if len(ms.mins) &gt; 0 { ms.mins = append(ms.mins, min(ms.mins[len(ms.mins)-1], val)) } else { ms.mins = append(ms.mins, val) }}func (ms *MaxMinStack) Pop() int { res := ms.data[len(ms.data)-1] ms.data = ms.data[:len(ms.data)-1] ms.maxes = ms.maxes[:len(ms.maxes)-1] ms.mins = ms.mins[:len(ms.mins)-1] return res}func (ms *MaxMinStack) Max() int { return ms.maxes[len(ms.maxes)-1]}func (ms *MaxMinStack) Min() int { return ms.mins[len(ms.mins)-1]}func (ms *MaxMinStack) Len() int { return len(ms.data)}// 找到一个最长的连续子数组 其任意两个元素之间的差值 小于等于 limitfunc longestSubarray(nums []int, limit int) int { // 就是维护一个 queue 为了方便 应该在 o(1) 的时间内获得其 最大最小值 left, right := 0, 0 window := &amp;MaxMinQueue{stack1: MaxMinStack{}, stack2: MaxMinStack{}} res := 0 for right &lt; len(nums) { window.Push(nums[right]) if window.Len() &gt; 0 &amp;&amp; window.Max() - window.Min() &lt;= limit { res = max(res, right - left + 1) } for window.Len() &gt; 0 &amp;&amp; window.Max() - window.Min() &gt; limit { window.Shift() left++ } right++ } return res} 爱生气的书店老板给定一个 grumpy 以及 custormers 在 grumpy == 0 的时候 可以加上 custormers 的对应值，问如果有连续的 X 个 gurmpy 可以为 0 最大 customers 的和为多少 自己的做法 维护一个前缀和数组 sum，表示前 i 个的和为多少，那么就可以用滑动窗口将数组分为三段 [0-&gt;l](可以用 sum 数组求得) [l-&gt;r](全部变为 0 所以是直接求和的) [r-&gt;len](可以用 sum 数组求得) 123456789101112131415161718192021222324public int maxSatisfiedWithSumArray(int[] customers, int[] grumpy, int X) { // sum[i] 保存 customers[i] 之前的所有满足要求的和 int[] sum = new int[customers.length + 1]; for (int i = 1; i &lt;= customers.length; i++) { sum[i] = sum[i - 1]; if (grumpy[i - 1] == 0) { sum[i] += customers[i - 1]; } } // 结果 int res = 0; // 维护一个窗口 这个窗口长度为 X 全部认为是可以加的 int windowSum = 0; for (int i = 0; i &lt; X; i++) { windowSum += customers[i]; } for (int i = X; i &lt; customers.length; i++) { res = Math.max(res, sum[i-X] + windowSum + sum[customers.length] - sum[i]); windowSum = windowSum - customers[i - X] + customers[i]; } res = Math.max(res, sum[customers.length-X] + windowSum); return res;} 题解 题解更进一步，将 customers 数组根据 grumpy 的取值分为两类，一类是 grumpy 等于 1 那么是可以直接加上的，一类是 grumpy == 0，可以在长度为 X 的滑动窗口中 increase 到 第一类的 123456789101112131415161718192021public int maxSatisfied(int[] customers, int[] grumpy, int X) { // 分两步计算 一个计算满足要求的所有和 total 另一个窗口可以额外增加的值 int total = 0; for (int i = 0; i &lt; customers.length; i++) { // grumpy[i] == 0 的时候 才加上 total += (1 - grumpy[i]) * customers[i]; } // 遍历可以增加的值 找到最大的 int window = 0; // 窗口遍历可以增加的值 for (int i = 0; i &lt; X; i++) { // 窗口可以增加的值 是 grumpy[i] == 1 window += grumpy[i] * customers[i]; } int res = window; for (int i = X; i &lt; customers.length; i++) { window = window - grumpy[i-X] * customers[i-X] + grumpy[i] * customers[i]; res = Math.max(res, window); } return total + res;} 二进制题目连接连续二进制数字题目要求的是将 1 -&gt; n 的二进制的字符拼接起来表示一个超大的二进制数，然后将 二进制 数转换成为 十进制 数，并模上 1000000007。 如果直接把每个数字转换成为二进制数，然后拼接转换，因为会超时，因为 n 的返回达到了 10^5。 所以考虑在遍历的时候直接对每一位数进行处理。 观察事例，可以看到其实相当于 1(1) &lt;&lt; 4 位数 10(2) &lt;&lt; 2 11(3) 不变，所以只需要在每个数字遍历的时候，将上一个数字形成的结果左移当前数字对应的二进制的位数的长度，加上该数即可 n = 3, res = 27 二进制表示为 1 -> 1, 2 -> 10, 3 -> 11 27 二进制表示为 11011 计算二进制数的长度的时候，可以简单的采用遍历的方式进行。 [1] 一位数长度 [2,3] 二位数长度 [4,……,7] 三位数长度 [8,……,15] 四位数长度 也就是说，长度也是一个可以从上一个长度推断来的，每次需要新增长度的时候，都是形成 2 的幂 的形成，可以用 i &amp; (i - 1) 来快速的判断 2 的幂。 12345678910111213141516171819202122private static int mod = 1000000007;// 只需要知道遍历的 n 的位数的长度即可public int concatenatedBinary(int n) { long res = 0; int shift = 0; // 因为要返回的是 1 - n 的数字的二进制的组合形成的大数字的十进制数 // 比如 1 2 3 组成的 1 10 11 返回 27 // 相当于 首先访问 1 结果为 1 // 访问 2 然后 1 左移两位 再加上 2 // 访问 3 上一步的结果 再左移两位 加上 3 // 所以对于每一个数字来说 实际上只需要让上一次的结果 不停的左移它的二进制的位数长度即可 for (int i = 1; i &lt;= n; i++) { // 因为二的幂次方为 1000 的形式 // 所以一旦知道现在的 i 为 2 的幂次方 就需要 shift++ if ((i &amp; (i - 1)) == 0) { shift++; } res = ((res &lt;&lt; shift) + i) % mod; } return (int) res;} 模拟除法不能使用乘法、除法和 mod 运算符。 除法的本质，以 10 / 3 为例 10 / 3 = 3 …… 1 (即为 3 个 3 相乘 余 1) 即为 10 - (3 _ 2) - (3 _ 1) = 1 其结果为 2 + 1 为 3 也就是说任意一种除法可以用一组除数的 2 的次方的乘积的结果来表示。 如 100 / 15 = 6 100 - (15 _ 4) - (15 _ 2) 所以可以采用二进制的方法来做，每次用被除数减去最大的一个除数的 2 次方的乘积，循环，直到剩下余数或者 0 123456789101112131415161718192021222324252627func divide(dividend int, divisor int) int { if divisor == 0 { return 1 &lt;&lt; 31 - 1 } minus := -1 if (dividend &lt; 0 &amp;&amp; divisor &lt; 0) || (dividend &gt; 0 &amp;&amp; divisor &gt; 0) { minus = 1 } absDividend, absDivisor := int64(math.Abs(float64(dividend))), int64(math.Abs(float64(divisor))) res := 0 for absDividend &gt;= absDivisor { tmp, multi := absDivisor, 1 for (tmp &lt;&lt; 1) &lt; absDividend { tmp &lt;&lt;= 1 multi &lt;&lt;= 1 } absDividend -= tmp res += multi if minus &gt; 0 &amp;&amp; res &gt;= math.MaxInt32 { return math.MaxInt32 } else if minus &lt; 0 &amp;&amp; minus * res &lt;= math.MinInt32 { return math.MinInt32 } } return minus * res} 123456789101112131415161718192021222324252627class Solution { public int divide(int dividend, int divisor) { if(divisor == 0 || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1)) return Integer.MAX_VALUE; int sign; if ((dividend &gt; 0 &amp;&amp; divisor &gt; 0) || (dividend &lt; 0 &amp;&amp; divisor &lt; 0)) sign = 1; else sign = -1; int res = 0; long dvd=Math.abs((long)dividend); long dvs=Math.abs((long)divisor); while (dvd &gt;= dvs) { long temp = dvs, m = 1; while (temp &lt;&lt; 1 &lt; dvd) { temp &lt;&lt;= 1; m &lt;&lt;= 1; } res += m; dvd -= temp; } return sign * res; }} 只出现一次的数字 II数组中的数组只有出现 1 次（一个数字）的和 3 次的数字，找到只出现一次的那个数字 其实就是计算每一位数字出现的次数 % 3 注意 goland 默认的 int 可能值得是 int64 所以强制指定为 32 为长度的 int32 不然没办法处理负数的情况 123456789101112func singleNumber(nums []int) int { var res int32 for i := 0; i &lt; 32; i++ { var count int32 for _, num := range nums { count += (int32(num )&gt;&gt; i) &amp; 1 } res += (count % 3) &lt;&lt; i } return int(res)} 只出现一次的数字 III一组数字 其中只有两个数字 出现一次 其余出现两次 12345678910111213141516171819202122232425262728func singleNumberIII(nums []int) []int { // 如果两个出现一次的数 不同 肯定不为 0 sum := 0 for _, num := range nums { sum ^= num } // 那么根据 sum 的某一个不为 0 的位数来分离两类数 counter := 1 for sum &amp; 1 == 0 { sum &gt;&gt;= 1 counter &lt;&lt;= 1 } // 找到了这个位数 根据 位数 分成两组即可 num1, num2 := 0, 0 for _, num := range nums { // 根据位数分离两类数 if num &amp; counter == 0 { num1 ^= num } else { num2 ^= num } } return []int{num1, num2}} 数字按位与要求求 m -&gt; n 的范围内的所有数字的 按位与 的结果，因为范围比较大，直接 &amp; 会超时 考虑 3 -&gt; 11 这个范围的数字，红色的 就是相同的二进制前缀部分 实际上就是找到这部分前缀 001011 11 001010 10 001001 09 001000 08 000111 07 000110 06 000101 05 000100 04 000011 03 123456789101112131415func rangeBitwiseAnd(m int, n int) int { if m == n { return m } // 考虑 [5,6,7] 三个数 &amp; 起来的话 实际上是 考虑 最大值 和 最小值的 左侧相等的部分是多少 // mov 记录移位了多少次 然后再移动回来 mov := 0 for m != n { m &gt;&gt;= 1 n &gt;&gt;= 1 mov++ } return m &lt;&lt; mov} 动态规划最后一块石头的重量 II其实就是问是否能够形成相等的两部分, 用一个 dp[i][j] 表示前 i 个的能否形成和为 j 的数值，在遍历的时候就可以找到最大的和为多少，之后就减去最大的和即可 1234567891011121314151617181920212223242526272829303132333435package classic// 这道题题干 要求 stones 两两相撞 剩下一块儿 为剩下的石头 最小能形成的重量// 其实就是问是否能够形成相等的两部分 因为相等的话 最后形成的石头 为 0func lastStoneWeightII(stones []int) int { sum := getStonesSum(stones) // dp[i][j] 表示前 i 个能否形成 何为 j dp := make([][]bool, len(stones)+1) for i := 0; i &lt; len(dp); i++ { dp[i] = make([]bool, sum/2+1) // 合为0一定可以 dp[i][0] = true } maxSum := 0 for i := 1; i &lt;= len(stones); i++ { for j := 1; j &lt;= sum/2; j++ { // 因为表示的前 i 能不能形成 j 所以 i-1 能形成的话 也是可以的 dp[i][j] = dp[i][j] || dp[i-1][j] if j &gt;= stones[i-1] { dp[i][j] = dp[i][j] || dp[i-1][j-stones[i-1]] } if dp[i][j] { maxSum = max(maxSum, j) } } } return sum - 2 * maxSum}func getStonesSum(stones []int) (sum int) { for _, w := range stones { sum += w } return} 最长子序列套题最长上升子序列找到非连续的递增子序列，那么我就只需要知道 在我之前的小于我的数字的上升子序列长度为多少 即实际上只需要在访问数组的时候 0 ≤ i &lt; j &lt; nums.length，只需要知道 i 下标对应的最长的子序列是多少即可。 这样就变成了一个 dp 问题，小问题就是解决的以 nums[i] 结尾的最长的上升子序列的长度 123456789101112131415161718func lengthOfLIS(nums []int) int { // dp[i] 表示 nums[i] 结尾的最长的递增子序列长度为多少 dp := make([]int, len(nums)) // 初始化 一个数字肯定是递增的 for i := 0; i &lt; len(nums); i++ { dp[i] = 1 } res := 0 for i, num := range nums { for j := 0; j &lt; i; j++ { if num &gt; nums[j] { dp[i] = max(dp[i], dp[j]+1) } } res = max(res, dp[i]) } return res} 最长上升子序列数量与上面那个类似 也是一个 dp 问题 只是需要在 dp 遍历的时候 知道 对应最长长度 对应的 LIS 有多少个 1234567891011121314151617181920212223242526272829303132333435363738// 找到 LIS 对应的长度的子序列有多少个func findNumberOfLIS(nums []int) int { // 保存 nums[i] 结尾的 LIS 的长度 dp := make([]int, len(nums)) // 保存 nums[i] 结尾的 LIS 的最长 LIS 的长度 counts := make([]int, len(nums)) // 初始化 for i := 0; i &lt; len(dp); i++ { dp[i] = 1 counts[i] = 1 } maxLen := 0 for i := 0; i &lt; len(nums); i++ { for j := 0; j &lt; i; j++ { // 形成 递增 if nums[j] &lt; nums[i] { if dp[i] &lt;= dp[j] { // 说明 j 的长度比这个长 dp[i] = dp[j] + 1 counts[i] = counts[j] } else if dp[j]+1 == dp[i] { // 长度相差 1 说明这个时候 counts 要 + 上 j 的 counts[i] += counts[j] } } } maxLen = max(maxLen, dp[i]) } res := 0 for i, count := range counts { if maxLen == dp[i] { res += count } } return res} 摆动序列找到摆动序列（摆动序列是一升一降的序列，即前后相减为一正一负）参考注释即可 (这个题目不要求连续 所以还需要不停的保存前一个状态 不用初始化) 1234567891011121314151617181920212223242526272829// 两个数组分别代表上升和下降序列的最大长度// 因为 wiggle 的数组 是一升一降 的 up[i] 表示 最后一个 nums[i] 是上升的趋势的最大值func wiggleMaxLengthWithoutMemo(nums []int) int { if len(nums) == 0 { return 0 } // up[i] down[i] 分别代表上升和下降序列(最后一个是上升或者下降)的 在 index = i 时的最长长度 ups, downs := make([]int, len(nums)), make([]int, len(nums)) // 初始化 ups[0] = 1 downs[0] = 1 for i := 1; i &lt; len(nums); i++ { if nums[i] &gt; nums[i-1] { // 如果 nums i 是上升趋势 说明那么 之前前一个是下降的趋势的话 可以 加一 // 同时 也可以不考虑这个 上升趋势 跟前一个比较 ups[i] = max(downs[i-1]+1, ups[i-1]) // 此时由于是上升的 所以没有下降的趋势 状态直接转移 downs[i] = downs[i-1] } else if nums[i] &lt; nums[i-1] { downs[i] = max(ups[i-1]+1, downs[i-1]) ups[i] = ups[i-1] } else { // 相等的情况下是不变的 ups[i] = ups[i-1] downs[i] = downs[i-1] } } return max(ups[len(ups)-1], downs[len(downs)-1])} 因为只依赖前一个状态 因此可以压缩状态 1234567891011121314151617181920212223// 两个数组分别代表上升和下降序列的最大长度// 因为 wiggle 的数组 是一升一降 的 up[i] 表示 最后一个 nums[i] 是上升的趋势的最大值func wiggleMaxLength(nums []int) int { if len(nums) == 0 { return 0 } up, down := 1, 1 for i := 1; i &lt; len(nums); i++ { preDown, PreUp := down, up if nums[i] &gt; nums[i-1] { up = max(down+1, up) down = preDown } else if nums[i] &lt; nums[i-1] { down = max(up+1, down) up = PreUp } else { up = PreUp down = preDown } } return max(up, down)} 类似摆动序列的题目 978. 最长湍流子数组找到一个连续的子数组能够满足 当 A 的子数组 A[i], A[i+1], …, A[j] 满足下列条件时，我们称其为湍流子数组： 若 i &lt;= k &lt; j，当 k 为奇数时， A[k] &gt; A[k+1]，且当 k 为偶数时，A[k] &lt; A[k+1]；或 若 i &lt;= k &lt; j，当 k 为偶数时，A[k] &gt; A[k+1] ，且当 k 为奇数时， A[k] &lt; A[k+1]。也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。 123456789101112131415161718192021222324252627282930func maxTurbulenceSize(arr []int) int { // 仍然是一升一降 才能使符号反号 up, down := 1, 1 res := 1 for i := 1; i &lt; len(arr); i++ { if arr[i] &gt; arr[i-1] { up = down+1 // 因为是要连续的 一升一降 所以这个地方需要重新初始化为 1 down = 1 } else if arr[i] &lt; arr[i-1] { down = up + 1 up = 1 } else { up, down = 1, 1 } // 因为重新初始化 所以需要对每一个状态进行比较保存 res = max(res, max(up, down)) } return res}func max(a, b int) int { if a &gt; b { return a } return b} 俄罗斯套娃信封问题根据信封的宽度和高度 判断能够装下的信封的最大长度有多少 高度和宽度均小于另外一个信封的 可以装进去 实际上是一个 找到最长递增序列的问题 按照宽度进行排序，这样从一个维度上看 所有的信封都是宽度有序的 再次基础上 如果要前一个信封能够装在后一个信封里面 说明长度是一个逆序的 最后只需要在这个排序的数组里面 找到长度的一个最长递增序列即可 123456789101112131415161718192021222324252627282930313233343536373839func maxEnvelopes(envelopes [][]int) int { // envelopes[0] 相等 说明宽度相等 这个时候 只需要更长的排在后面即可 // envelopes[0] 不等 说明宽度不等 这个时候 只需要只需要根据长度大小从大到小排序即可 sort.Slice(envelopes, func(i, j int) bool { if envelopes[i][0] == envelopes[j][0] { return envelopes[i][1] &gt; envelopes[j][1] } else { return envelopes[i][0] &lt; envelopes[j][0] } }) // 因为现在这样排序之后 信封的宽度 一定是满足顺序的 那么只需要判断长度 能够形成的最长的递增子序列是多长 dp := make([]int, len(envelopes)) // 1 个数字也能有一个长度 for i := 0; i &lt; len(dp); i++ { dp[i] = 1 } res := 0 for i := 0; i &lt; len(dp); i++ { tmp := 0 for j := 0; j &lt; i; j++ { if envelopes[i][1] &gt; envelopes[j][1] { tmp = max(tmp, dp[j]) } } dp[i] = tmp + 1 res = max(res, dp[i]) } return res}func max(a, b int) int { if a &gt; b { return a } return b} 解码方法这道题是入门的动态规划 只要知道 前一个和前前个的状态，就可以转移到下一个状态 12345678910111213141516171819202122232425262728293031323334353637func numDecodings(s string) int { if len(s) == 0 { return 0 } // dp[i] 表示 s[0:i] 不包括i能生成的数量 // dp[i] = dp[i-1]+dp[i-2] // 因为只要当前的这个 sting 能够被 decoding 说明只要加上前面的数量即可 dp := make([]int, len(s) + 1) dp[0] = 1 // 表示的每次遍历的string的尾部 for i := 1; i &lt;= len(s); i++ { for j := max(i - 2, 0); j &lt; i; j++ { if canDecoding(s[j:i]) { dp[i] += dp[j] } } } return dp[len(s)]}func canDecoding(s string) bool { if len(s) &gt; 1 &amp;&amp; s[0] == '0' { return false } if num, err := strconv.Atoi(s); err != nil || num &gt; 26 || num &lt; 1 { return false } return true}func max(a, b int) int { if a &gt; b { return a } return b} 子序列不同的子序列1234567891011121314151617181920212223242526func numDistinct(s string, t string) int { // dp[i][j] 表示 s[i-1] 和 t[j-1] 之间有多少组合 dp := make([][]int, len(s)+1) for i := 0; i &lt;= len(s); i++ { dp[i] = make([]int, len(t)+1) } // 初始化 只要 t 是空 那么一定可以 在 s 中找到 for i := 0; i &lt;= len(s); i++ { dp[i][0] = 1 } for i := 1; i &lt;= len(s); i++ { for j := 1; j &lt;= len(t); j++ { if s[i-1] == t[j-1] { // 分为两个部分 因为可以不算当前的 s 串的最后一个 也可以算上 // 因为 s 串的前面部分 可能已经匹配到了 dp[i][j] = dp[i-1][j-1] + dp[i-1][j] } else { dp[i][j] = dp[i-1][j] } } } return dp[len(s)][len(t)]} 打家劫舍系列题打家劫舍 I这道题是经典的 dp 问题。题目要求的是不能抢劫相邻的位置，那么这种条件下的最大和是多少。 一个位置会有两个状态，拿当前这个地方的值 或者 不拿 下个位置的状态就会由上一个位置决定 如果当前位置拿了值的话，上一个位置只能不拿 如果当前位置没有拿，上一个位置只需要取拿 or 不拿的 较大值 优化下 dp 数组 其实可以用一对值表示前面一个循环中拿了的最大值即可 12345678910111213141516func rob(nums []int) int { if len(nums) &lt;= 0 { return 0 } // 优化的目的在于去掉数组 因为现在直接最大的就是 notRob, rob := 0, 0 res := 0 for _, num := range nums { rm := rob rob = notRob + num notRob = max(notRob, rm) res = max(notRob, rob) } return res} 打家劫舍 II这个是打劫的循环数组，因为 rob 了第一个 就不能 rob 最后一个 所以分别访问从 [1:len(nums)] 和 [0:len(nums)-1] 然后比较大小即可 1234567891011121314151617181920212223242526272829303132func rob(nums []int) int { if len(nums) &lt;= 0 { return 0 } if len(nums) == 1 { return nums[0] } // 因为是首尾相连的 robFirst := getMaxRob(nums[:len(nums)-1]) notRobFirst := getMaxRob(nums[1:]) return max(robFirst, notRobFirst)}func getMaxRob(nums []int) int { notRob, rob := 0, 0 res := 0 for _, num := range nums { rem := rob rob = notRob + num notRob = max(rem, notRob) res = max(res, max(rob, notRob)) } return res}func max(a, b int) int { if a &gt; b { return a } return b} 打家劫舍 III这次是树，实际上还是要知道子节点上的话 rob 和 notRob 的状态即可，然后递推到当前的状态 1234567891011121314151617181920212223242526272829303132333435363738394041func rob(root *TreeNode) int { var res int recursionRobTree(root, &amp;res) return res}// recursionRobTree 返回值是 rob 当前这个 root 还不 不 rob 的值func recursionRobTree(root *TreeNode, res *int) (int, int) { if root == nil { return 0, 0 } leftRob, leftNotRob := recursionRobTree(root.Left, res) rightRob, rightNotRob := recursionRobTree(root.Right, res) // 如果 rob 当前这个root 节点的话 意味着 两个节点都不可以rob rob := leftNotRob + rightNotRob + root.Val // 如果 不 rob 这个节点的话 子节点可以 rob 也可以不 rob notRob := getArrayMax(leftRob + rightRob, rightRob + leftNotRob, rightNotRob + leftRob, rightNotRob + leftNotRob) *res = max(*res, rob) *res = max(*res, notRob) return rob, notRob}func getArrayMax(nums ...int) int { if len(nums) == 0 { return -1 } res := nums[0] for _, num := range nums { res = max(res, num) } return res}func max(a, b int) int { if a &gt; b { return a } return b} 贪心算法转换罗马字12345678910111213141516171819202122232425262728293031323334353637383940package classicimport ( &quot;strings&quot;)var ( memo = make(map[int]string) keys []int)func init() { memo[1] = &quot;I&quot; memo[4] = &quot;IV&quot; memo[5] = &quot;V&quot; memo[9] = &quot;IX&quot; memo[10] = &quot;X&quot; memo[40] = &quot;XL&quot; memo[50] = &quot;L&quot; memo[90] = &quot;XC&quot; memo[100] = &quot;C&quot; memo[400] = &quot;CD&quot; memo[500] = &quot;D&quot; memo[900] = &quot;CM&quot; memo[1000] = &quot;M&quot; keys = []int{1000,900,500,400,100,90,50,40,10,9,5,4,1}}func intToRoman(num int) string { res := strings.Builder{} for _, key := range keys { for num &gt;= key { res.WriteString(memo[key]) num -= key } } return res.String()} jumpGame12345678910111213141516func canJump(nums []int) bool { rightMost := 0 for i, num := range nums { // 如果当前的下标大于 rightMost 说明这个点是无法到达的 直接返回 false 即可 if i &gt; rightMost { return false } // 维护一个能够到达的最远距离 rightMost = max(rightMost, i + num) // 最远距离大于长度 即可知道能够达到 if rightMost &gt;= len(nums) - 1 { return true } } return false} 递归执行乘法运算的最大分数 给你两个长度分别 n 和 m 的整数数组 nums 和 multipliers ，其中 n &gt;= m ，数组下标 从 1 开始 计数。初始时，你的分数为 0 。你需要执行恰好 m 步操作。在第 i 步操作（从 1 开始 计数）中，需要：选择数组 nums 开头处或者末尾处 的整数 x 。你获得 multipliers[i] * x 分，并累加到你的分数中。将 x 从数组 nums 中移除。在执行 m 步操作后，返回 最大 分数。 暴力解法 暴力解法就是直接根据每次取的不同字符生成一颗二叉树，然后在二叉树上进行遍历得到结果 12345678910111213141516class Solution { public int maximumScore(int[] nums, int[] multipliers) { Deque&lt;Integer&gt; num = new LinkedList&lt;&gt;(); for (int t : nums) { num.addLast(t); } return recursion(0, multipliers, num); } public int recursion(int index, int[] multipliers, Deque&lt;Integer&gt; nums) { if (index &gt;= multipliers.length) return 0; Deque&lt;Integer&gt; tmp = new LinkedList&lt;&gt;(nums); return Math.max(multipliers[index] * nums.removeFirst() + recursion(index + 1, multipliers, nums), multipliers[index] * tmp.removeLast() + recursion(index + 1, multipliers, tmp)); }} 带 memo 观察上述的结果的话，可以首先进行的优化是去除 dequeue 的使用，直接使用一个范围框定 nums 的选取 12345678910public int maximumScore(int[] nums, int[] multipliers) { return recursion(0, multipliers, nums, 0, nums.length - 1);}public int recursion(int index, int[] multipliers, int[] nums, int left, int right) { if (index &gt;= multipliers.length) return 0; int l = nums[left] * multipliers[index] + recursion(index + 1, multipliers, nums, left + 1, right, memo); int r = nums[right] * multipliers[index] + recursion(index + 1, multipliers, nums, left, right - 1, memo); return Math.max(l, r);} 但是上述的方法仍然超时，因为遍历这颗形成的二叉树的时候，会有重复的访问情况，可以观察到的是 left + n - 1 - right == index，因为从左边选取的数字数量和右边选取的数字的数量，肯定是 multipliers 选取的数量。 123456789101112131415161718192021public int maximumScore(int[] nums, int[] multipliers) { // 上面的 left、right、index 其实可以用任意两个来表示即可 // 因为可以根据公式互换，所以这样选择的 memo 是最小的 int[][] memo = new int[multipliers.length][multipliers.length]; for (int i = 0; i &lt; multipliers.length; i++) { Arrays.fill(memo[i], Integer.MAX_VALUE); } return recursion(0, multipliers, nums, 0, nums.length - 1, memo);}// 因为 left + n - 1 - right == index// 因为其结果代表的是 左边选取 left 个 右边选取 n - 1 - right 个// 而取出的结果public int recursion(int index, int[] multipliers, int[] nums, int left, int right, int[][] memo) { if (index &gt;= multipliers.length) return 0; if (memo[left][index] != Integer.MAX_VALUE) return memo[left][index]; int l = nums[left] * multipliers[index] + recursion(index + 1, multipliers, nums, left + 1, right, memo); int r = nums[right] * multipliers[index] + recursion(index + 1, multipliers, nums, left, right - 1, memo); memo[left][index] = Math.max(l, r); return memo[left][index];} 括号生成1234567891011121314151617181920212223// generateParenthesis 入口函数func generateParenthesis(n int) []string { res := make([]string, 0) recursionGenerate(&amp;res, &quot;&quot;, n, n) return res}// 递归生成func recursionGenerate(res *[]string, tmp string, left, right int) { if left == 0 &amp;&amp; right == 0 { *res = append(*res, tmp) return } // 由于左括号可以直接放到结果上，因此左括号不用判断其他的 if left &gt; 0 { recursionGenerate(res, tmp+&quot;(&quot;, left-1, right) } // 而有括号需要跟左括号匹配，所以有括号遍历的时候 必须已经有左括号被放到了结果中 // 所以需要判断一下 right &gt; left if right &gt; left { recursionGenerate(res, tmp+&quot;)&quot;, left, right-1) }} 12345678910111213141516171819public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); recursion(res, n, n, &quot;&quot;); return res;}public void recursion(List&lt;String&gt; res, int left, int right, String tmp) { if (left == 0 &amp;&amp; right == 0) { res.add(tmp); return; } if (left &gt; 0) { recursion(res, left - 1, right, tmp + &quot;(&quot;); } if (right &gt; left) { recursion(res, left, right - 1, tmp + &quot;)&quot;); }} 正则表达式匹配这道题可以用递归的思想去做，也可以采用 dp 的方法。实际上递归就是从上向下的 dp 12345678910111213141516171819202122232425262728293031func isMatch(s string, p string) bool { return recursionIsMatch(s, p, 0, 0)}func recursionIsMatch(s, p string, sIndex, pIndex int) bool { // 完全匹配 if sIndex == len(s) &amp;&amp; pIndex == len(p) { return true } // 越界 pattern 匹配完了一定有问题 if pIndex == len(p) &amp;&amp; sIndex != len(s) { return false } if pIndex &lt; len(p)-1 &amp;&amp; p[pIndex+1] == '*' { // 匹配 if pIndex &lt; len(p) &amp;&amp; sIndex &lt; len(s) &amp;&amp; (p[pIndex] == s[sIndex] || p[pIndex] == '.') { return recursionIsMatch(s, p, sIndex, pIndex+2) || // 匹配0次 因为 * 代表 0 -&gt; 多次 recursionIsMatch(s, p, sIndex+1, pIndex+2) || // 匹配1次 recursionIsMatch(s, p, sIndex+1, pIndex) // 匹配多次 } else { // 如果不匹配 则跳过 return recursionIsMatch(s, p, sIndex, pIndex+2) } } // 现在的字符是匹配的 if pIndex &lt; len(p) &amp;&amp; sIndex &lt; len(s) &amp;&amp; (p[pIndex] == s[sIndex] || p[pIndex] == '.') { return recursionIsMatch(s, p, sIndex+1, pIndex+1) } return false} 123456789101112131415161718192021222324252627public boolean isMatch(String s, String p) { return recursion(s, p, 0, 0);}public boolean recursion(String s, String p, int sIndex, int pIndex) { if (pIndex == p.length() &amp;&amp; sIndex != s.length()) { return false; } if (sIndex == s.length() &amp;&amp; pIndex == p.length()) { return true; } if (pIndex &lt; p.length() - 1 &amp;&amp; p.charAt(pIndex + 1) == '*') { if (sIndex &lt; s.length() &amp;&amp; (p.charAt(pIndex) == '.' || p.charAt(pIndex) == s.charAt(sIndex))) { return recursion(s, p, sIndex, pIndex + 2) || // 匹配0次 recursion(s, p, sIndex + 1, pIndex + 2) || // 匹配1次 recursion(s, p, sIndex + 1, pIndex); // 匹配多次 } else { return recursion(s, p, sIndex, pIndex + 2); } } if (sIndex &lt; s.length() &amp;&amp; pIndex &lt; p.length() &amp;&amp; (p.charAt(pIndex) == '.' || p.charAt(pIndex) == s.charAt(sIndex))) { return recursion(s, p, sIndex + 1, pIndex + 1); } return false;} 数据结构栈和队列队列-滑动窗口的最大值最大 queue 的队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960type MaxQueue struct { stack1 MaxStack stack2 MaxStack}func (queue *MaxQueue) Push(val int) { queue.stack1.Push(val)}func (queue *MaxQueue) shift() int { if queue.stack2.Len() == 0 { for queue.stack1.Len() &gt; 0 { queue.stack2.Push(queue.stack1.Pop()) } } return queue.stack2.Pop()}func (queue *MaxQueue) Max() int { if queue.stack1.Len() == 0 { return queue.stack2.Max() } else if queue.stack2.Len() == 0 { return queue.stack1.Max() } return max(queue.stack2.Max(), queue.stack1.Max())}func (queue *MaxQueue) Len() int { return queue.stack1.Len() + queue.stack2.Len()}type MaxStack struct { // 这两个不用 slice 用 list 之类的链表 可能会快一点儿 data []int maxes []int}func (ms *MaxStack) Push(val int) { ms.data = append(ms.data, val) if len(ms.maxes) &gt; 0 { ms.maxes = append(ms.maxes, max(ms.maxes[len(ms.maxes)-1], val)) } else { ms.maxes = append(ms.maxes, val) }}func (ms *MaxStack) Pop() int { res := ms.data[len(ms.data)-1] ms.data = ms.data[:len(ms.data)-1] ms.maxes = ms.maxes[:len(ms.maxes)-1] return res}func (ms *MaxStack) Max() int { return ms.maxes[len(ms.maxes)-1]}func (ms *MaxStack) Len() int { return len(ms.data)} 使用代码 123456789101112131415161718func maxSlidingWindow(nums []int, k int) []int { queue := MaxQueue{ stack1: MaxStack{}, stack2: MaxStack{}, } for i := 0; i &lt; k; i++ { queue.Push(nums[i]) } res := make([]int, 0) for i := k; i &lt; len(nums); i++ { res = append(res, queue.Max()) queue.shift() queue.Push(nums[i]) } res = append(res, queue.Max()) return res} 栈-计算器中值表达式转波兰表达式（实际上是） 链表删除倒数的第 N 个节点1234567891011121314151617181920212223func removeNthFromEnd(head *ListNode, n int) *ListNode { // 因为可能删除头结点 所有加了一个 newHead := new(ListNode) newHead.Next = head // fast 是先走的一个节点 pre 是后走的 pre, fast := newHead, head for n &gt; 0 { // 有问题 数量不够 if fast == nil { return nil } fast = fast.Next n-- } // 两个指针开始走 for fast != nil { fast = fast.Next pre = pre.Next } pre.Next = pre.Next.Next return newHead.Next} 合并 k 个已经排序的链表类似归并排序 1234567891011121314151617181920212223242526272829303132333435363738394041package classic// mergeKLists 合并k个已经按照升序排列的数组func mergeKLists(lists []*ListNode) *ListNode { return merge(lists,0, len(lists) - 1)}func merge(lists []*ListNode, start, end int) *ListNode { if start &gt; end { return nil } if start == end { return lists[start] } mid := (start + end) / 2 left, right := merge(lists, start, mid), merge(lists, mid + 1, end) return mergeTwoList(left, right)}func mergeTwoList(list1 *ListNode, list2 *ListNode) *ListNode { res := new(ListNode) rem := res for list1 != nil &amp;&amp; list2 != nil { if list1.Val &gt; list2.Val { res.Next = list2 list2 = list2.Next } else { res.Next = list1 list1 = list1.Next } res = res.Next } if list1 != nil { res.Next = list1 } if list2 != nil { res.Next = list2 } return rem.Next} 翻转链表一系列反转链表最简单的反转链表的思路肯定是直接用一个 stack，FILO 的机制来反转，而不采用额外的空间可以用一下的方法 12345678910111213141516func reverseList(head *ListNode) *ListNode { // 反转后的头节点 var pre *ListNode = nil for head != nil { // 用一个 局部变量 来保存下一个节点 next := head.Next // 反转当前遍历的 head 节点，指向已经反转完毕的头结点 head.Next = pre pre = head // 重新设置 head 头 head = next } return pre} 反转链表 II反转链表 II 是反转链表下表从 m -&gt; n 的一个链表，实际上采用上述的反转的操作，即可反转 m -&gt; n 之间的节点 1234567891011121314151617181920212223242526272829303132333435363738// 主函数func reverseBetween(head *ListNode, m int, n int) *ListNode { // 添加一个新的头结点，保障原来的头结点被反转时的结果 newHead := new(ListNode) newHead.Next = head cp := newHead // 分别保存需要反转的节点之前的一个节点以及最后需要反转的一个节点 var preStartNode, endNode *ListNode = nil, nil for i := 0; cp != nil; cp, i = cp.Next, i + 1 { if i == m - 1 { preStartNode = cp } if i == n { endNode = cp } } // 保存反转完毕后的链表需要连接到的下一个节点 afterEndNode := endNode.Next reverseHead, reverseEnd := reverseBetweenNodes(preStartNode.Next, afterEndNode) preStartNode.Next = reverseHead reverseEnd.Next = afterEndNode return newHead.Next}// reverseBetweenNodes reverse两个node之间的链表// 其中 startNode 为开始翻转的节点 endNodeNext 为结束翻转的节点的后一个节点func reverseBetweenNodes(startNode, endNodeNext *ListNode) (*ListNode, *ListNode) { var newHead *ListNode = nil newEndNode := startNode for startNode != endNode { next := startNode.Next startNode.Next = newHead newHead = startNode startNode = next } return newHead, newEndNode} reverse K groupreverse K group 的更进一步，在上面一题的基础上，每 K 个节点反转一次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// reverseKGroup k个一组翻转func reverseKGroup(head *ListNode, k int) *ListNode { newHead := new(ListNode) newHead.Next = head var preStartNode, endNode *ListNode = newHead, nil counter := 0 mov := newHead for mov != nil { if counter == k { endNode = mov afterEnd := endNode.Next // 调用二题中所述的函数进行反转 reverseHead, reverseEnd := reverseBetweenNodes(preStartNode.Next, endNode.Next) preStartNode.Next = reverseHead reverseEnd.Next = afterEnd // 因为反转之后要重新记录 preStartNode counter = 0 // 反转之后的需要再次反转的头是上次反转的尾结点 preStartNode = reverseEnd // 重新定位移标 mov = reverseEnd } mov = mov.Next counter++ } return newHead.Next}// reverseBetweenNodes reverse两个node之间的链表// 其中 startNode 为开始翻转的节点 endNodeNext 为结束翻转的节点的后一个节点func reverseBetweenNodes(startNode, endNodeNext *ListNode) (*ListNode, *ListNode) { var newHead *ListNode = nil newEndNode := startNode for startNode != endNodeNext { next := startNode.Next startNode.Next = newHead newHead = startNode startNode = next } return newHead, newEndNode} 树树的遍历中序遍历123456789101112131415161718func inorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := list.New() for root != nil || stack.Len() != 0 { for root != nil { stack.PushBack(root) root = root.Left } if stack.Len() &gt; 0 { root = stack.Remove(stack.Back()).(*TreeNode) res = append(res, root.Val) root = root.Right } } return res} 前序遍历12345678910111213141516171819202122package classicimport &quot;container/list&quot;func preorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := list.New() for root != nil || stack.Len() &gt; 0 { for root != nil { res = append(res, root.Val) stack.PushBack(root) root = root.Left } if stack.Len() &gt; 0 { root = stack.Remove(stack.Back()).(*TreeNode) root = root.Right } } return res} 后序遍历12345678910111213141516171819202122232425262728293031func postorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := list.New() // 标识这个node是不是第二次访问 stackForFlag := list.New() for root != nil || stack.Len() &gt; 0 { for root != nil { stack.PushBack(root) stackForFlag.PushBack(false) root = root.Left } if stack.Len() &gt; 0 { root = stack.Remove(stack.Back()).(*TreeNode) flag := stackForFlag.Remove(stackForFlag.Back()).(bool) // 说明是第二次访问 这个时候要访问父亲节点 if flag { res = append(res, root.Val) root = nil } else { // 第一次访问 stack.PushBack(root) stackForFlag.PushBack(true) root = root.Right } } } return res} 层次遍历 普通层次遍历 123456789101112131415161718192021222324252627282930313233func levelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } tmp := make([]int, 0) queue := list.New() queue.PushBack(root) queue.PushBack(nil) for queue.Len() &gt; 0 { node := queue.Remove(queue.Front()) if node == nil { cp := make([]int, len(tmp)) copy(cp, tmp) res = append(res, cp) if queue.Len() == 0 { break } queue.PushBack(nil) tmp = make([]int, 0) continue } top := node.(*TreeNode) if top.Left != nil { queue.PushBack(top.Left) } if top.Right != nil { queue.PushBack(top.Right) } tmp = append(tmp, top.Val) } return res} zigzag 的层次遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package classicimport &quot;container/list&quot;func zigzagLevelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } isLeft := true tmp := make([]int, 0) queue := list.New() queue.PushBack(root) queue.PushBack(nil) for queue.Len() &gt; 0 { top := queue.Remove(queue.Front()) if top == nil { cp := make([]int, len(tmp)) copy(cp, tmp) res = append(res, cp) if queue.Len() == 0 { break } isLeft = !isLeft tmp = make([]int, 0) queue.PushBack(nil) continue } node := top.(*TreeNode) if node.Left != nil { queue.PushBack(node.Left) } if node.Right != nil { queue.PushBack(node.Right) } // 这个地方可以这样加入 就不用再 top == nil 中重新反转数组 if isLeft { tmp = append(tmp, node.Val) } else { tmp = append([]int{node.Val}, tmp...) } } return res} 前缀树实现用字符串的前缀来索引的结构树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Trie 之间通过 字符 关联 上一个 trie 会通过字符作为边连接下一个节点type Trie struct { data []*Trie // 存储索引结构的数 因为只包含 a-z 的字母 索引直接数组即可 不然用 map 会更好 isEnd bool // 是否结束节点}/** Initialize your data structure here. */func Constructor() Trie { return Trie{ data: make([]*Trie, 26), isEnd: false, }}/** Inserts a word into the trie. */func (this *Trie) Insert(word string) { tmp := this for _, char := range word { if tmp.data[char-'a'] == nil { tmp.data[char-'a'] = &amp;Trie{ data: make([]*Trie, 26), isEnd: false, } } tmp = tmp.data[char-'a'] } tmp.isEnd = true}/** Returns if the word is in the trie. */func (this *Trie) Search(word string) bool { tmp := this for _, char := range word { if tmp.data[char-'a'] == nil { return false } tmp = tmp.data[char-'a'] } return tmp.isEnd}/** Returns if there is any word in the trie that starts with the given prefix. */func (this *Trie) StartsWith(prefix string) bool { tmp := this for _, char := range prefix { if tmp.data[char-'a'] == nil { return false } tmp = tmp.data[char-'a'] } return true} 图并查集的数据结构并查集，表示的是一个树形的结构 如图所示，针对图的一个极大连通分量，会形成一个对应的树结构（并查集只关注一个连通分量有多少连接点，不关注内部的其他的细节） 所以针对查找连通分量有哪些，以及连同量间的关系有作用 并查集存储数据的结构123type Union struct { parents []int // 存储树的数据结构 parents[i] 表示连接到该节点的父节点的索引 如果不能用 int 来表示 可以考虑 map 类的数据结构} 并查集的操作 union (联合，关联两个点) find (查找，找到当前点的最终的父节点) 所以，实际上 如果 r1 r2 之间有连接线的话，要关联 r1 r2 的操作就是。 就是通过 find 找到分别的根节点 r1Root r2Root 在通过 union 方法关联两个根节点，实际上就是将 r2Root 作为一个子节点，挂载到 r1Root 下 所以整体的数据结构为 12345678910111213141516171819202122232425262728293031323334353637type unionFind struct { Parents []int Count int // 表示连通分量的多少}func NewUnionFind(size int) *unionFind { res := &amp;unionFind{ Parents: make([]int, size), Count: size, } // 初始化并查集中的每个元素的父节点都是自己 for i := 0; i &lt; size; i++ { res.Parents[i] = i } return res}func (u *unionFind) union(i, j int) { iRoot := u.find(i) jRoot := u.find(j) if iRoot != jRoot { u.Parents[jRoot] = iRoot // 每次连接一个之后 最大连通分量就要 -- u.Count-- }}func (u *unionFind) find(i int) int { if u.Parents[i] == i { return i } return u.find(u.Parents[i])}func (u *unionFind) GetCount() int { return u.Count} 执行交换操作后的最小汉明距离这道题实际上是找连通分量，对比两个数组中相应的连通区域不等的部分，所以可以用无向图连通分量 dfs or 并查集 得到连通分量后进行处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.Arrays;import java.util.HashMap;import java.util.Map;public class MinimumHammingDistance_1722 { public void union(int[] union, int i, int j) { int x = getParent(union, i); int y = getParent(union, j); if (x != y) { union[y] = x; } } public int getParent(int[] union, int i) { if (union[i] == -1) return i; return getParent(union, union[i]); } public void changeUnion(int[] union) { boolean[] memo = new boolean[union.length]; for (int i = 0; i &lt; union.length; i++) { if (!memo[i]) { recursion(union, memo, i); } } } // 更该 union 到root public int recursion(int[] union, boolean[] memo, int i) { if (memo[i]) return union[i]; memo[i] = true; if (union[i] == -1 || union[i] == i) { union[i] = i; return i; } int root = recursion(union, memo, union[i]); union[i] = root; return root; } // 连通图问题 在连通分量里面找到不等的数字 // 无向图的连通分量 // 可以使用 dfs 得到无向图的连通分量 or 使用 union 的算法得到连通分量 // 但是 union 算法如果直接在算法执行图中去更改所有的 root 值 会慢一点儿 所以在执行完毕后去更改 public int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) { int[] union = new int[source.length]; Arrays.fill(union, -1); for (int[] allowSwap : allowedSwaps) { union(union, allowSwap[0], allowSwap[1]); } // 修改连通分量标识 到根节点 changeUnion(union); // 现在每个中对应的都是一个连通分量的根节点的下标，那么就需要知道 一个连通分量里面有多少个不等的 // 保存root中的数字每个出现了几次 Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; sMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; union.length; i++) { int root = union[i]; if (!sMap.containsKey(root)) sMap.put(root, new HashMap&lt;&gt;()); Map&lt;Integer, Integer&gt; tmp = sMap.get(root); tmp.put(source[i], tmp.getOrDefault(source[i], 0) + 1); } int res = 0; for (int i = 0; i &lt; union.length; i++) { int root = union[i]; Map&lt;Integer, Integer&gt; tmp = sMap.get(root); if (!tmp.containsKey(target[i]) || tmp.get(target[i]) == 0) { res++; } else { tmp.put(target[i], tmp.get(target[i]) - 1); } } return res; } public static void main(String[] args) { System.out.println(new MinimumHammingDistance_1722().minimumHammingDistance(new int[]{49, 21, 79, 79, 6, 67, 78, 9, 91, 39, 49, 32, 53, 29, 97, 50, 82, 55, 13, 83, 63, 99, 41, 6, 51, 46, 31, 26, 58, 18, 32, 51, 44, 66, 40, 35, 96, 20, 35, 43, 64, 96, 99, 76, 11, 35, 86, 96, 10, 19, 70, 29, 19, 47}, new int[]{33, 22, 32, 71, 66, 90, 78, 67, 74, 76, 84, 32, 25, 100, 57, 7, 90, 95, 33, 79, 54, 99, 42, 6, 32, 55, 31, 14, 58, 67, 48, 59, 7, 50, 5, 22, 11, 97, 94, 14, 53, 75, 3, 9, 82, 74, 86, 27, 21, 77, 70, 29, 65, 15}, new int[][]{{40, 41}, {41, 35}, {18, 19}, {9, 51}, {48, 2}, {45, 13}, {27, 45}, {16, 22}, {23, 25}, {2, 6}, {5, 11}, {37, 38}, {22, 48}, {13, 48}, {51, 37}, {24, 19}, {2, 32}, {38, 23}, {33, 34}, {37, 44}, {31, 8}, {4, 26}, {34, 35}, {37, 28}, {48, 34}, {27, 0}, {23, 37}, {17, 29}, {38, 7}, {37, 31}, {34, 42}, {26, 20}, {22, 45}, {26, 29}, {40, 42}, {48, 30}, {46, 49}, {12, 52}, {49, 28}, {39, 14}, {23, 34}, {6, 30}, {18, 12}, {52, 49}, {21, 18}, {11, 4}, {2, 7}, {4, 17}, {19, 27}, {33, 5}, {44, 28}, {38, 9}, {34, 7}, {7, 47}, {37, 13}, {51, 12}, {42, 53}, {42, 21}, {18, 9}, {21, 39}, {4, 33}, {29, 39}, {47, 41}, {25, 13}, {50, 0}, {21, 48}, {32, 27}, {33, 53}, {39, 5}, {12, 25}, {52, 6}, {17, 44}, {16, 52}, {0, 34}, {14, 29}, {0, 19}, {13, 7}, {29, 21}, {9, 22}, {28, 45}, {1, 29}, {37, 17}, {38, 36}, {4, 23}, {38, 21}, {35, 5}, {2, 16}, {34, 30}, {37, 16}, {40, 53}, {51, 47}, {20, 32}, {7, 9}, {12, 15}, {26, 0}, {14, 44}, {53, 11}, {48, 17}})); }} 连通网络的操作次数题目所述，给定一个图，找到将其所有最大连通分量连通所需更改的最少的边的数量为多少。 图的所有最小连通为一个树，即需要 n 个节点有 n - 1 条边。 所以题目其实是要找到这个图里面有多少独立的连通分量，然后判断其是否可以连接 第一种思路就是直接 dfs 遍历，找到所有的连通分量。首先判断边的数量是否足够 n - 1 这个时候，如果有多个连通分量，说明某个连通分量一定有多的边，随意选取其中的边即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445package classic// makeConnected 方法查看func makeConnected(n int, connections [][]int) int { // 最短的话肯定是形成一棵树 才能联通所有 // 所以 边 至少要达到 n - 1 的数量 // 这个时候不能连通 if len(connections) &lt; n-1 { return -1 } // map 的邻接表表示 cMap := make(map[int][]int) for _, connection := range connections { if _, ok := cMap[connection[0]]; !ok { cMap[connection[0]] = make([]int, 0) } cMap[connection[0]] = append(cMap[connection[0]], connection[1]) if _, ok := cMap[connection[1]]; !ok { cMap[connection[1]] = make([]int, 0) } cMap[connection[1]] = append(cMap[connection[1]], connection[0]) } // 到这里的时候 由于边的数量够 所以一定是可以连通的 // 这个时候 只需要知道有 m 块是不相连的 然后就知道需要连接的次数就为 m - 1 memo := make([]bool, n) res := 0 for i := 0; i &lt; n; i++ { if !memo[i] { res++ dfs(memo, cMap, i) } } return res - 1}func dfs(memo []bool, cMap map[int][]int, start int) { memo[start] = true for _, next := range cMap[start] { if !memo[next] { dfs(memo, cMap, next) } }} 并查集，找到每个群组的数据的一个代表点 12345678910111213141516171819202122232425262728293031323334353637383940414243// findRoot 找到根节点func findRoot(parents []int, index int) int { if parents[index] == -1 { return index } return findRoot(parents, parents[index])}// makeConnected 并查集func makeConnected(n int, connections [][]int) int { if len(connections) &lt; n - 1 { return -1 } // 并查集的 parents 数组，标识 当前索引的 节点的父节点的索引是谁 // 相同的数最后均能找到同样的父节点 parents := make([]int, n) // 初始化所有的为 -1 for i := 0; i &lt; n; i++ { parents[i] = -1 } // 执行 union 的操作 for _, connection := range connections { sRoot := findRoot(parents, connection[0]) eRoot := findRoot(parents, connection[1]) // 两个点上有连接线 但是现在还没有连接起来 // 让其根节点相连 if sRoot != eRoot { // 将 e 节点连接到 s 上 parents[eRoot] = sRoot } } // 剩下的还是 -1 的就一定是整个群里面的代表节点 res := 0 for _, val := range parents { if val == -1 { res++ } } return res - 1} 由斜杠划分区域采用并查集，但是这道题有特殊的地方。 题目中所示，针对一个方格有 / 和 \\ 两种，如下 ---- ---- |\\ | | /| | \\| |/ | ---- ---- 总之，针对一个 方格 ，可以把他看成四个部分 那么，也就是说， 如果当前 char == ‘ ‘ 表示 0 1 2 3 都是联通的 如果 char == ‘\\‘ 表示 01 23 分别连通 char == ‘/‘ 表示 03 12 分别连通 内部的连通完毕后， 还可以知道 1 一定跟下一个 3 连通 2 一定跟下一行的 0 连通 1234567891011121314151617181920212223242526272829303132333435363738394041424344// regionsBySlashes 通过斜杠划分func regionsBySlashes(grid []string) int { // n * n 的矩阵的长度 length := len(grid) // 为了使用 并查集 将一个1*1 的正方形，即 一个 grid[i] 标识的区域分成 四个地方 // 然后再根据 / \\\\ 两个符号的位置进行合并 最后看有几个节点 unionSize := 4 * length * length u := NewUnionFind(unionSize) for i, str := range grid { for j, char := range str { // 0 号位置 uIndex := 4 * (i*length + j) // 同一个单元格里面的连接起来 switch char { // 0 1 2 3 都要连接起来 case ' ': u.union(uIndex, uIndex + 1) u.union(uIndex + 1, uIndex + 2) u.union(uIndex + 2, uIndex + 3) case '\\\\': // 反斜杠的话 01 23 分别连接 u.union(uIndex, uIndex + 1) u.union(uIndex + 2, uIndex + 3) case '/': // 斜杠的话 03 12 分贝连接 u.union(uIndex, uIndex + 3) u.union(uIndex + 1, uIndex + 2) } // 单元格外面的连接起来 // 不管是 \\\\ 还是 / 这个区域的1一定可以和右边下一个区域( j+ 1)的 3 连接 // 这个区域的 2 一定可以和下边(i + 1)下一个区域的 0 连接 if j + 1 &lt; length { u.union(uIndex+1, 4*(i*length+j+1)+3) } if i + 1 &lt; length { u.union(uIndex+2, 4*((i+1)*length+j)) } } } return u.GetCount()} 水位上升的泳池中游泳这道题没想明白最开始，肯定是明白要知道到什么时候 [0,0] 跟 [n - 1, n - 1] 的右下角相连 相连的判断可以通过并查集实现 那么就要解决几个问题： 怎么遍历 并查集连接的条件是什么 怎么把二维数组的位置抽象到一维 从以下几个方面入手 题目中所述 grid 中的数值从 [0, nn-1] 的唯一数值，也就是说每个格子的高度都是独立的，因此只需要遍历高度，在遍历高度中如果 [0, nn-1] 相连，即完成连接 由于题目中 当遍历的位置达到一个高度的时候，他可以直接和上下左右上的相连，也就是说遍历到高度更高的地方能够直接比高度更低的地方连接 而题目中的 grid 的棋盘的二维数组可以通过简单的 n*x+y 抽象到一维 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package classicfunc union(parents []int, i, j int) { iRoot, jRoot := findRootOfParents(parents, i), findRootOfParents(parents, j) if iRoot != jRoot { parents[jRoot] = iRoot }}func findRootOfParents(parents []int, i int) int { if parents[i] == i { return i } return findRootOfParents(parents, parents[i])}func isConnectedParents(parents []int, i, j int) bool { return findRootOfParents(parents, i) == findRootOfParents(parents, j)}var ( // 表示上下左右四个方向 DIRECTIONS = [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}})func swimInWater(grid [][]int) int { if grid == nil { return -1 } n := len(grid) index := make([]int, n*n) for i := 0; i &lt; n; i++ { for j := 0; j &lt; n; j++ { // 因为题目中所述，grid 里面的数值从 0 -&gt; n * n - 1 // 所以让高度作为下标索引 方便下面遍历 index[grid[i][j]] = n*i + j } } // grid 的二位数组 可以转为 n * i + j 的一维坐标 parents := make([]int, n*n) for i := 0; i &lt; n*n; i++ { parents[i] = i } for i := 0; i &lt; n*n; i++ { x, y := index[i]/n, index[i]%n for _, direction := range DIRECTIONS { newX, newY := x+direction[0], y+direction[1] // 因为这个是从高度相距只有1的地方开始的 所以可以直接关联 // 这样当 0 n - 1 连接到一起的时候 说明已经达到的最小的高度 // 只有新的节点的高度 小于 当前的高度 才是可以游过去的！！！ if !(newX &lt; 0 || newX &gt;= n || newY &lt; 0 || newY &gt;= n) &amp;&amp; grid[newX][newY] &lt;= i { // index 的索引用在这个地方 union(parents, index[i], newX*n+newY) } if isConnectedParents(parents, 0, n*n-1) { return i } } } return -1} 拓扑排序 逆后续排列 遍历出度为 0 的点 课程表这道题本质上就是拓扑排序 简单的做法就是用 dfs 去判断是否成环 1234567891011121314151617181920212223242526272829303132333435363738394041func canFinish(numCourses int, prerequisites [][]int) bool { // 有向图 mapOfCourses := make([][]int, numCourses) for i := 0; i &lt; numCourses; i++ { mapOfCourses[i] = make([]int, 0) } for _, prerequisite := range prerequisites { mapOfCourses[prerequisite[1]] = append(mapOfCourses[prerequisite[1]], prerequisite[0]) } // 保存已经访问过的节点 这样可以避免重复访问 totalMemo := make([]bool, numCourses) for i := 0; i &lt; numCourses; i++ { if !dfsCanFinish(mapOfCourses, make([]bool, numCourses), totalMemo, i) { return false } } return true}// 通过 dfs 的方法判断是否成环// 用 memo 来记录一次循环中访问的节点func dfsCanFinish(mapOfCourses [][]int, memo, totalMemo []bool, start int) bool { if totalMemo[start] { return true } totalMemo[start] = true memo[start] = true for _, adj := range mapOfCourses[start] { if !memo[adj] { // 截断 有环直接返回 if !dfsCanFinish(mapOfCourses, memo, totalMemo, adj) { return false } } else { // 这个地方就是找到了环 return false } } memo[start] = false return true} 拓扑排序 遍历入度为 0 的点 1234567891011121314151617181920212223242526272829303132333435363738func canFinish(numCourses int, prerequisites [][]int) bool { // 入度为 0 的点为起点 inDegree := make([]int, numCourses) for _, prerequisite := range prerequisites { // 让有向图的接受线的一端 入度++ inDegree[prerequisite[0]]++ } // 保存入度为 0 的点 inDegreeEqualZero := list.New() for i, in := range inDegree { if in == 0 { inDegreeEqualZero.PushBack(i) } } // 遍历入度为 0 的点 // 每次删除一条边 判断下一个点 是否入度为0 入度为 0 加入到 map 中 不停的遍历 直到没有点 for inDegreeEqualZero.Len() &gt; 0 { node := inDegreeEqualZero.Remove(inDegreeEqualZero.Front()).(int) for _, prerequisite := range prerequisites { if node == prerequisite[1] { inDegree[prerequisite[0]]-- if inDegree[prerequisite[0]] == 0 { inDegreeEqualZero.PushBack(prerequisite[0]) } } } } for i := 0; i &lt; numCourses; i++ { // 这个地方说明还有点相连，因此是无法完成的 if inDegree[i] != 0 { return false } } return true} 最短路径地图分析找到多源最短路，改造了一下 dijkstra 算法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public int maxDistance(int[][] grid) { // 考虑使用 dijkstra 算法 // dijkstra 算法是找单源最短路经的 // 因此在这儿要改造一下 // 虚拟出一个超级节点 连接所有的起始节点 那样就可以找出从这个超级节点到 另外一个集合的最短距离 int n = grid.length; int[][] dst = new int[n][n]; // 无向图 为了防止重复访问 需要 memo boolean[][] memo = new boolean[n][n]; PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { dst[i][j] = Integer.MAX_VALUE; // 连接到超级节点的 dst 为 0 // 从 岸开始遍历 那么 岸到任意一个海的最短距离就会保存到 海节点上 if (grid[i][j] == 1) { dst[i][j] = 0; pq.add(new Node(i, j, 0)); } } } // 这样就可以吧时间复杂度降下来 while (!pq.isEmpty()) { Node top = pq.poll(); memo[top.x][top.y] = true; for (int[] direction : directions) { int newX = top.x + direction[0], newY = top.y + direction[1]; // 越界 if (newX &gt;= n || newX &lt; 0 || newY &gt;= n || newY &lt; 0) continue; if (memo[newX][newY]) continue; // relax if (dst[newX][newY] &gt; dst[top.x][top.y] + 1) { dst[newX][newY] = dst[top.x][top.y] + 1; // 更新 pq 里面的最短距离 pq.removeIf((node) -&gt; node.x == newX &amp;&amp; node.y == newY); pq.add(new Node(newX, newY, dst[newX][newY])); } } } int res = -1; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { // 因为结果保存在 海洋单元格内 if (grid[i][j] == 0) res = Math.max(res, dst[i][j]); } } return res == Integer.MAX_VALUE ? -1 : res;}private static class Node implements Comparable&lt;Node&gt; { int x, y; int dst; public Node(int x, int y) { this.x = x; this.y = y; // 还没有找到 this.dst = Integer.MAX_VALUE; } public Node(int x, int y, int dst) { this.x = x; this.y = y; this.dst = dst; } @Override public int compareTo(Node o) { return this.dst - o.dst; }}private static int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; 1786. 从第一个节点出发到最后一个节点的受限路径数说实话 我是看不懂受限路径到底是什么意思，所以看了下他们的思路，自己实现了一下。现在贴上原题 现有一个加权无向连通图。给你一个正整数 n ，表示图中有 n 个节点，并按从 1 到 n 给节点编号；另给你一个数组 edges ，其中每个 edges[i] = [ui, vi, weighti] 表示存在一条位于节点 ui 和 vi 之间的边，这条边的权重为 weighti 。从节点 start 出发到节点 end 的路径是一个形如 [z0, z1, z2, …, zk] 的节点序列，满足 z0 = start 、zk = end 且在所有符合 0 &lt;= i &lt;= k-1 的节点 zi 和 zi+1 之间存在一条边。路径的距离定义为这条路径上所有边的权重总和。用 distanceToLastNode(x) 表示节点 n 和 x 之间路径的最短距离。受限路径 为满足 distanceToLastNode(zi) &gt; distanceToLastNode(zi+1) 的一条路径，其中 0 &lt;= i &lt;= k-1 。返回从节点 1 出发到节点 n 的 受限路径数 。由于数字可能很大，请返回对 109 + 7 取余 的结果。 参考的解法 模仿的解法 超时，怀疑是 构建图 花费太多时间 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import microsoft.PlusOne;import java.util.*;public class CountRestrictedPaths_1786 { private static class Edge { int from, to; int weight; public Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } public int getOther(int node) { if (node == from) return to; return from; } } private static class Map { List&lt;List&lt;Edge&gt;&gt; map; public int capacity; public Map(int capacity) { this.capacity = capacity; this.map = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; this.capacity; i++) { this.map.add(new ArrayList&lt;&gt;()); } } public void addEdge(int from, int to, int weight) { Edge e = new Edge(from, to, weight); this.map.get(from).add(e); this.map.get(to).add(e); } public List&lt;Edge&gt; adj(int node) { return this.map.get(node); } } private static class Pair implements Comparable&lt;Pair&gt; { int node; int weight; public Pair(int node, int weight) { this.node = node; this.weight = weight; } @Override public int compareTo(Pair o) { return weight - o.weight; } } // 返回 dp 结果 // 这个题目说的意思是 只要从尾结点开始遍历 并且到下一个点的距离 大于 当前点的距离 就是逆序的 // 按照题解的描述 // 这条路径的搜索过程可以看做，从结尾（第 5 个点）出发，逆着走，每次选择一个点（例如 a）之后， // 再选择下一个点（例如 b）时就必须满足最短路距离比上一个点（点 a）要远，如果最终能选到起点（第一个点），说明统计出一条有效路径。 public int[] dijkstra(Map map, int start) { int[] dstTo = new int[map.capacity]; Arrays.fill(dstTo, Integer.MAX_VALUE); dstTo[start] = 0; PriorityQueue&lt;Pair&gt; queue = new PriorityQueue&lt;&gt;(); queue.add(new Pair(start, 0)); // 无向图 防止重复 boolean[] memo = new boolean[map.capacity]; while (!queue.isEmpty()) { Pair top = queue.poll(); memo[top.node] = true; for (Edge e : map.adj(top.node)) { int other = e.getOther(top.node); if (!memo[other] &amp;&amp; dstTo[other] &gt; dstTo[top.node] + e.weight) { dstTo[other] = dstTo[top.node] + e.weight; queue.removeIf((p) -&gt; p.node == other); queue.add(new Pair(other, dstTo[other])); } } } return dstTo; } public int countRestrictedPaths(int n, int[][] edges) { Map map = new Map(n + 1); for (int[] edge : edges) { map.addEdge(edge[0], edge[1], edge[2]); } // 返回节点的数据 int[] dstTo = dijkstra(map, n); // 得到了dist数组，可以得到递推关系，dp[u] += dp[v], when v links to v and dist[u] &gt; dist[v] // 因此先算dist小的，才可以算dp，需要dist从小到大排序, 然后依次计算。 // 保存到某个点 以及对应的 dst 距离 List&lt;int[]&gt; pairs = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; dstTo.length; i++) { pairs.add(new int[]{i, dstTo[i]}); } pairs.sort(Comparator.comparingInt(a -&gt; a[1])); int[] dp = new int[n + 1]; dp[n] = 1; int mod = 1000000007; for (int[] p : pairs) { int node = p[0], cur = p[1]; for (Edge adj : map.adj(node)) { int other = adj.getOther(node); if (cur &gt; dstTo[other]) { dp[node] = (dp[node] + dp[other]) % mod; } } } return dp[1]; } public static void main(String[] args) { System.out.println(new CountRestrictedPaths_1786().countRestrictedPaths(5, new int[][]{ {1, 2, 3}, {1, 3, 3}, {2, 3, 1}, {1, 4, 2}, {5, 2, 2}, {3, 5, 1}, {5, 4, 10} })); System.out.println(new CountRestrictedPaths_1786().countRestrictedPaths(7, new int[][]{ {1, 3, 1}, {4, 1, 2}, {7, 3, 4}, {2, 5, 3}, {5, 6, 1}, {6, 7, 2}, {7, 5, 3}, {2, 6, 4} })); }} 博弈问题预测赢家分别从数组的两端取值，问最后谁获胜。 模拟取值的过程即可 123456789101112131415161718public boolean PredictTheWinner(int[] nums) { int[][] memo = new int[nums.length][nums.length]; for (int[] ints : memo) { Arrays.fill(ints, -1); } return recursionMemo(nums, 0, nums.length - 1, memo) &gt;= 0;}public int recursionMemo(int[] nums, int i, int j, int[][] memo) { if (i &gt; j) return 0; if (i == j) return nums[i]; if (memo[i][j] != -1) return memo[i][j]; // 分别选取左边和右边的值进行比较 int left = nums[i] - recursionMemo(nums, i + 1, j, memo); int right = nums[j] - recursionMemo(nums, i, j - 1, memo); memo[i][j] = Math.max(left, right); return memo[i][j];} 石子游戏石子游戏 VII杂题递增的三元子序列 首先想到嘛，用两个数组分别存储从左到右的最小值和最右到左的最大值，那么如果 nums 中一个数 num 大于这个最小值小于这个最大值，是一定可以的 123456789101112131415161718192021222324252627282930313233343536func increasingTriplet(nums []int) bool { if len(nums) == 0 { return false } mins, maxes := make([]int, len(nums)), make([]int, len(nums)) mins[0] = nums[0] for i := 1; i &lt; len(nums); i++ { mins[i] = min(mins[i-1], nums[i]) } maxes[len(nums)-1] = nums[len(nums)-1] for i := len(nums) - 2; i &gt;= 0; i-- { maxes[i] = max(maxes[i+1], nums[i]) } for i, num := range nums { if num &gt; mins[i] &amp;&amp; num &lt; maxes[i] { return true } } return false}func max(a, b int) int { if a &gt; b { return a } return b}func min(a, b int) int { if a &lt; b { return a } return b} 还可以进一步优化 他实际上是找这么一组 3 个数 num1 &lt; num2 &lt; num3 那么如果我在 num3 之前找到了这两个数字 num1 num2 即可 所以用 一个 min mid 来记录之前找到的 num1 num2。 其中 min 保存之前遇到的最小值, mid 保存之前 大于 min 的最小值，那么 如果碰到 同时大于 min、mid 的数 就可以直接返回 true 了。 但是可能遇到这种情况，在访问找到 num3 的时候，min 对应的数字的下标在 mid 之后。 但是考虑这种情况的话，一定有一个小于 mid 的 历史 min 值在 mid 之前，所以其实还是一个完整的三元组。 12345678910111213141516class Solution { public boolean increasingTriplet(int[] nums) { if (nums == null || nums.length &lt; 3) return false; int min = Integer.MAX_VALUE, mid = Integer.MAX_VALUE; for (int num : nums) { if (num &lt;= min) { min = num; } else if (num &lt;= mid) { mid = num; } else { return true; } } return false; }} 二分袋子里最少数目的球 给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。你可以进行如下操作至多 maxOperations 次：选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。请你返回进行上述操作后的最小开销。 bruteforce 直接的做法就是不停的找到数组中最大的数，然后在 maxOperations 的次数限制内进行分隔，找到分隔中最小的数据。 为了 o(1) 的找到最大的数，所以使用的 pq 来保存中间数据 12345678910111213141516171819202122232425// bruteforce 模拟的方法 通过对递归的方法对最大数进行不停的分隔 得到最后的结果public int minimumSizeBruteForce(int[] nums, int maxOperations) { PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a); for (int num : nums) { pq.add(num); } return recursion(pq, maxOperations);}public int recursion(PriorityQueue&lt;Integer&gt; pq, int operations) { assert !pq.isEmpty(); if (operations == 0) return pq.peek(); int max = pq.poll(); int res = Integer.MAX_VALUE; for (int i = 1; i &lt;= max / 2; i++) { int other = max - i; pq.add(i); pq.add(other); res = Math.min(res, recursion(pq, operations - 1)); pq.remove(i); pq.remove(other); } pq.add(max); return res;} 二分查找 二分查找可以用于查找最小的最大值，最大的最小值等情况。 那么可以以结果作为区间，每次判断这个最小开销是否能够实现，就可以去缩短遍历的范围。 但是需要知道如何找到能否实现这个函数： 当用 mid 去规定最小开销的时候，意味着所有大于 mid 的数字都需要被拆分到最小开销中 拆分的时候，如 num = 8, mid = 4, 那么只需要拆分一次即可，如 num = 17, mid = 7，那么需要拆分成[7,7,3] 需要拆分两次。所以拆分的代价是 num / mid，在 num % mid == 0 时要减一 123456789101112131415161718192021222324252627282930// 二分查找 二分的范围是返回的最小结果// 即最小代价public int minimumSize(int[] nums, int maxOperations) { // nums 中最大的数为 j 的大小 int i = 1, j = 1000000000; int res = 0; while (i &lt;= j) { int mid = i + (j - i) / 2; if (check(nums, mid, maxOperations)) { j = mid - 1; res = mid; } else { i = mid + 1; } } return res;}// 检查当前遍历到的 mid 的状态 能不能在 maxOperations 的限制下达到public boolean check(int[] nums, int mid, int maxOperations) { int res = 0; for (int num : nums) { if (num % mid == 0) { res += num / mid - 1; } else { res += num / mid; } } return res &lt;= maxOperations;} 找出第 k 小的距离对距离差定义为 数组中 任意一对数之间的差的绝对值 因此找到第 K 个最小距离，一个直观的解法就是，遍历所有的差，放入到只有 k 个数的大顶堆中，那么堆顶都是结果。（memory 爆了） 12345678910111213141516171819202122232425262728293031323334353637type IntHeap []intfunc (h IntHeap) Len() int { return len(h) }func (h IntHeap) Less(i, j int) bool { return h[i] &gt; h[j] }func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }func (h *IntHeap) Push(x interface{}) { // Push and Pop use pointer receivers because they modify the slice's length, // not just its contents. *h = append(*h, x.(int))}func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x}// 找到 nums 中第k小一对数之间的最短距离（距离为两数之差）// heap outOfMemoryfunc smallestDistancePairWithHeap(nums []int, k int) int { hp := &amp;IntHeap{} heap.Init(hp) for i := 0; i &lt; len(nums); i++ { for j := i + 1; j &lt; len(nums); j++ { heap.Push(hp, int(math.Abs(float64(nums[i]-nums[j])))) if hp.Len() &gt; k { heap.Pop(hp) } } } return (*hp)[0]} 另外一个想法就是二分 二分的范围是从差值的范围出发，即 0 -&gt; max(nums) - min(nums)，那么 max min 可以直接排序取首尾即可 但是如何统计，二分中小于 mid 的差值的数量 以 [1,2,2,3,4] 为例，固定右边界为 4 的时候 1 -&gt; 4 中间可能小于 k 的数字组合为 [1,4] [2,4] [2,4] [3,4] 其结果为 j - i = 4 - 0 (4 的下标 4 1 的下标 1) 12345678910111213141516171819202122232425262728293031323334353637383940func smallestDistancePair(nums []int, k int) int { if len(nums) == 0 { return -1 } sort.Ints(nums) // i, j 表示的是 nums 中的 数据差 的范围 i, j := 0, nums[len(nums)-1] - nums[0] for i &lt; j { // mid 表示的是中间的差值 mid := i + (j - i) / 2 // 找到小于等于 mid 的数值差的数量 count := findDistancePair(nums, mid) if count &gt; k { j = mid - 1 } else if count &lt; k { i = mid + 1 } else { // 因为是小于等于 所以可能 mid 是解 也可以是在左边 j = mid } } return i}func findDistancePair(nums []int, distance int) int { res := 0 // 固定右边界 i, j := 0, 0 for j &lt; len(nums) { // 统计出来的是小于等于 distance 的数量 for i &lt; j &amp;&amp; nums[j] - nums[i] &gt; distance { i++ } // 因为是递增的 如果这个时候 1,2,2,3,4 相当于固定右边界 那么排序完的数组 左边能够形成的满足条件的数对 应该是 j - i 个 res += j - i j++ } return res} 字典树猜字谜暴力解法，用 word 去匹配 puzzle 的 set 超时了。 而原题目中 words 的数量比 puzzles 的数量高一个数量级，因此可以使用 字典树 压缩 word 的数量，用 puzzle 进行比较 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private class TrieTree { int currency; TrieTree[] child; public TrieTree() { this.currency = 0; // 因为只包含小写字母 this.child = new TrieTree[26]; } public void add(char[] word) { TrieTree cur = this; for (char c : word) { if (cur.child[c - 'a'] == null) { cur.child[c - 'a'] = new TrieTree(); } cur = cur.child[c - 'a']; } // currency 表示有一个 word 到达了这个底 cur.currency++; }}public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { // 因为实际上并不在意 word 的顺序 而且根据题目要求 word 不定长 而且比 puzzle 大 因为 puzzle 是 7 为固定长度 // 所以固定 word 为 字符树 TrieTree root = new TrieTree(); // 加入字典树中相当于 压缩了 words for (String word : words) { // 排序去重加入 因为这样才能统计 currency 并进行压缩 root.add(getCharArray(word)); } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(puzzles.length); for (int i = 0; i &lt; puzzles.length; i++) { res.add(0); } // 比较 puzzle 与 字典树 // puzzle 最大深度为 7 // 最后只需要加上 currency 即可 for (int i = 0; i &lt; puzzles.length; i++) { char[] puzzleArray = getCharArray(puzzles[i]); char required = puzzles[i].charAt(0); res.set(i, recursionSearch(root, puzzleArray, 0, required)); } return res;}// puzzle 去匹配字典树 找到一个 节点 返回其 currency 即对应的 word 数量public int recursionSearch(TrieTree node, char[] puzzleArray, int pos, char required) { if (node == null) { return 0; } // puzzle 最深就打到这儿 if (pos == puzzleArray.length) { return node.currency; } // 可以选择用当前 pos 这个位置来匹配 然后都 ++ int res = recursionSearch(node.child[puzzleArray[pos] - 'a'], puzzleArray, pos + 1, required); // 因为去重了 所以 required 等于的时候 一定要匹配 // 不等于的时候，可以维持 node 引用 然后不匹配 跳过 puzzle 的这个字符 继续往下走 if (puzzleArray[pos] != required) { // + 是因为 可以用多条路走 实际上就是要或者不要 res += recursionSearch(node, puzzleArray, pos + 1, required); } return res;}public char[] getCharArray(String word) { char[] tmp = word.toCharArray(); Arrays.sort(tmp); int newIndex = 0; int l = 0, r = 0; while (r &lt; tmp.length) { while (r &lt; tmp.length &amp;&amp; tmp[r] == tmp[l]) { r++; } tmp[newIndex++] = tmp[l]; l = r; } char[] res = new char[newIndex]; System.arraycopy(tmp, 0, res, 0, newIndex); return res;} 计算器基本计算器其本质是一个 中值表达式 求值。实际上只需要注意 符号的 优先级即可。（PS：·· 好多细节没注意到 就会 gg） TODO: 中值表达式 转成 逆波兰表达式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.Deque;import java.util.LinkedList;public class BasicCalculator_224 { private int operate(char operator, int n1, int n2) { switch (operator) { case '+' -&gt; { return n1 + n2; } case '-' -&gt; { return n2 - n1; } } return 0; } // 字符的优先级！！！ TODO: 中值表达式 转 逆波兰表达式 // 中缀转后缀 public int calculate(String s) { // 只有 数字 + - ( ) Deque&lt;Integer&gt; number = new LinkedList&lt;&gt;(); Deque&lt;Character&gt; operators = new LinkedList&lt;&gt;(); if (s.length() &gt; 0 &amp;&amp; s.charAt(0) == '-') { s = '0' + s; } s = s.replaceAll(&quot;\\\\(\\\\+&quot;, &quot;(0+&quot;); s = s.replaceAll(&quot;\\\\(-&quot;, &quot;(0-&quot;); for (int i = 0; i &lt; s.length(); ) { char c = s.charAt(i); if (c == ' ') { i++; } else if (c == '+') { // 需要弹出栈 直到优先级相等 因为只有 - + 所以需要一直弹出到 - while (operators.size() &gt; 0 &amp;&amp; operators.peekLast() != '+' &amp;&amp; operators.peekLast() != '(') { int first = number.removeLast(); int second = 0; if (!number.isEmpty()) second = number.removeLast(); number.add(operate(operators.removeLast(), first, second)); } operators.add(c); i++; } else if (c == '-') { while (operators.size() &gt; 0 &amp;&amp; operators.peekLast() == '-' &amp;&amp; operators.peekLast() != '(') { int first = number.removeLast(); int second = 0; if (!number.isEmpty()) second = number.removeLast(); number.add(operate(operators.removeLast(), first, second)); } operators.add(c); i++; } else if (c == '(') { operators.add(c); i++; } else if (c == ')') { // 弹栈 while (operators.size() &gt; 0 &amp;&amp; operators.peekLast() != '(') { int first = number.removeLast(); int second = 0; if (!number.isEmpty()) second = number.removeLast(); number.add(operate(operators.removeLast(), first, second)); } // 去掉 ( operators.removeLast(); i++; } else { int num = 0; // 数字 while (i &lt; s.length() &amp;&amp; s.charAt(i) &gt;= '0' &amp;&amp; s.charAt(i) &lt;= '9') { num = num * 10 + s.charAt(i) - '0'; i++; } number.add(num); } } while (!operators.isEmpty()) { int first = number.removeLast(); int second = 0; if (!number.isEmpty()) second = number.removeLast(); number.add(operate(operators.removeLast(), first, second)); } return number.getLast(); } public static void main(String[] args) { System.out.println(new BasicCalculator_224().calculate( &quot;(6)-(8)-(7)+(1+(6))&quot;)); System.out.println(new BasicCalculator_224().calculate( &quot;1 + 1&quot;)); System.out.println(new BasicCalculator_224().calculate( &quot; 2-1 + 2 &quot;)); System.out.println(new BasicCalculator_224().calculate( &quot;(1+(4+5+2)-3)+(6+8)&quot;)); }} 数学问题1802. 有界数组中指定下标处的最大值 给你三个正整数 n、index 和 maxSum 。你需要构造一个同时满足下述所有条件的数组 nums（下标 从 0 开始 计数）：nums.length == nnums[i] 是 正整数 ，其中 0 &lt;= i &lt; nabs(nums[i] - nums[i+1]) &lt;= 1 ，其中 0 &lt;= i &lt; n-1nums 中所有元素之和不超过 maxSumnums[index] 的值被 最大化返回你所构造的数组中的 nums[index] 。 这个问题就是说构建一个只有正整数的数组，且相邻数字之间差值不能超过 1，问 如何构建才能使 index 下标位置的数最大。 其实偏向于贪心的策略，既然要 index 最大，那么每次遍历的时候，我都在 index 上 +1，看在没有打到 maxSum 的时候能够给这个地方添加几次。最后其实际的生长过程可以看做下面的一个过程。 例输入：n = 4, index = 2, maxSum = 6 构建基础数组，因为要求每个数字都为正整数，因此最小为 1 1 1 1 1 _ | index 从 index 开始生长 2 1 1 1 1 _ | index 这个时候 已经不能再加 1 了 所以直接返回 2 所以其实就是构建一个题型的台状结构，每层比下一层只会高 1 个，最后到 index 的位置最高即可。 123456789101112131415161718192021222324252627282930class Solution { public int maxValue(int n, int index, int maxSum) { // 因为是正整数 所以相当于每个数字至少要填上1 int remain = maxSum - n; // 现在 index 位置填入的是 1 int res = 1; // 然后根据剩下的数字 从 index 开始增加 int l = index, r = index; while (l &gt; 0 || r &lt; n - 1) { // 在 l 到 r 之间的数字 加 1 int len = r - l + 1; if (remain &gt;= len) { // index 对应位置的数字 一定是在 l,r 之间的 res += 1; // 因为相邻不能相差 1 所以 每次 l、r 向外增加 1 位长度 l = Math.max(0, l - 1); r = Math.min(r + 1, n - 1); remain -= len; } else { break; } } // 还剩下 全部加一 res += remain / n; return res; }} 132 模式在一个数组中找到下标 i &lt; j &lt; k 满足 nums[i] &lt; nums[k] &lt; nums[j] 也就是说 j 对应的数值 是三个中最大的 k 次之，最小的是 i 那么很容易知道 i 的值其实需要越小越好，越小的话，后面 k、j 的条件就最好满足，因此第一步就是求出从左向右的最小值数组 brute force 的方法(o(n^2)) 既然已经知道 i 取从左向右的最小值，那么只想就需要确定 j &lt; k 且 nums[i] &lt; nums[k] &lt; nums[j]，也就是在后续的数组中找到一对逆序的数组，那么 o(n^2) 的算法就很好写了 123456789101112131415161718192021222324// 找到 1 3 2 模式// bruteforce 的方法 因为要找到 i &lt; j &lt; k 满足 nums[i] &lt; nums[k] &lt; nums[j] 的格式// 即中间的数是最大 那么 nums[i] 一定是最小 所以先维护一个 leftMin 表示从左侧开始的最小值// 然后开始遍历数组 找到一个 逆序数对 且逆序数对中的最小值 大于 leftMin 的值 即可找到// 所以是 o(n^2)public boolean find132patternBruteForce(int[] nums) { if (nums == null || nums.length &lt; 3) return false; int[] leftMin = new int[nums.length]; leftMin[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) { leftMin[i] = Math.min(leftMin[i - 1], nums[i]); } // 先固定一个最小值 // 然后在找到一个逆序的点 for (int i = 1; i &lt; nums.length - 1; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (nums[j] &gt; leftMin[i] &amp;&amp; nums[i] &gt; nums[j]) return true; } } return false;} 优化的算法（o(n)） 之前的算法寻找逆序的时候，是在确定了 j 值 的情况下从前向后寻找 k 值，如果能够知道之前访问的过的 j 值，作为当前 k 值，那么就可以进一步的降低复杂度。 因为，在满足 nums[j] &gt; leftMin[j] (即 nums[i]) 时，如果 k 值正好取到小于 nums[j] 的值 且 大于 nums[i] 时满足条件。所以 nums[k] 的值 在取小于 nums[j] 的值的时候 越大越好，因为这样才可能更大程度的满足 nums[k] &gt; nums[i] 的条件。 所以使用一个单调栈来保存 j 之后遍历的历史情况，越靠近栈底的值越大，只需要取到栈中需要的满足小于 nums[j] 的最大值即可。 这样 栈中还保存着较大的值，之后再遍历的时候，还以用这个比 nums[j] 大的值，与 j 之前更大的值匹配成 132 组合。 而 j 之后的较小值，如何满足题设条件，会在第一次访问的时候就返回了，所以也不会存在漏的结果。 12345678910111213141516171819202122232425262728public boolean find132pattern(int[] nums) { if (nums == null || nums.length &lt; 3) return false; int[] leftMin = new int[nums.length]; leftMin[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) { leftMin[i] = Math.min(leftMin[i - 1], nums[i]); } Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); // 从后向前找 因为要找的是 j &lt; k nums[j] &gt; nums[k] 的结果 // 那么只需要保存遍历的 j 之后的比 nums[j] 小 且比 leftMin 大的最大值 这样就可以满足要求了 // 所以 stack 中保存的是 j 之后的 较大的值 如果能够在其中找到一个小于 nums[j] 的值 就证明可行 for (int j = nums.length - 1; j &gt;= 0; j--) { // 必须要比左侧最小的大 才能比较 if (nums[j] &gt; leftMin[j]) { // 因为要在 j 右边找一个更小的 nums[k] 所以 比 nums[j] 小的 都出栈 // 比较其中的最大值与 leftMin 的大小既可以知道 int remove = Integer.MIN_VALUE; while (!stack.isEmpty() &amp;&amp; stack.peekLast() &lt; nums[j]) { remove = stack.removeLast(); } if (remove &gt; leftMin[j]) return true; stack.addLast(nums[j]); } } return false;} 最大子序和简单的题型简单的题型如 剑指offer 上所述，只需要用一个数组保存以当前结尾的最大子序和即可。转移的时候，如果之前的最大子序和小于 0，说明应该重新开始计数。 123456789101112131415class Solution { public int maxSubArray(int[] nums) { int[] dp = new int[nums.length]; int res = Integer.MIN_VALUE; for (int i = 0; i &lt; nums.length; i++) { if (i == 0 || dp[i - 1] &lt; 0) { dp[i] = nums[i]; } else { dp[i] = dp[i - 1] + nums[i]; } res = Math.max(res, dp[i]); } return res; }} 删除一次得到子数组最大和 直觉想法 拿到这个题目的第一个直觉就是跟上面那个基本一致，但是需要删除一个数字，那么删除的这个数字一定存在这样的性质。 删除这个数字后，有可能左右的最大子序和加起来更大，所以这个数字一定是负数。 那么，只需要知道这个数字左边和右边的分别的最大子序和即可，那么就可以用两次上面的算法，得到以 i 结尾的从左向右最大子序和 和 以 i 结尾的从右想左的最大子序和即可 123456789101112131415161718192021222324252627282930313233343536373839// 最大子序和的变种 如果中间可以删除一个数字 问能够形成的最大子序和为多少public int maximumSumWithTwoDirection(int[] arr) { if (arr == null || arr.length == 0) return 0; if (arr.length == 1) return arr[0]; // 因此要删除一个的话 只需要遍历被删除的项即可，然后将以 arr[i] 结尾的左右的最大子序和累加起来即可 int[] left = new int[arr.length + 1]; int[] right = new int[arr.length + 1]; for (int i = 0; i &lt; arr.length; i++) { if (left[i] &lt; 0) left[i + 1] = arr[i]; else left[i + 1] = left[i] + arr[i]; } for (int j = arr.length - 1; j &gt;= 0; j--) { if (right[j + 1] &lt; 0) right[j] = arr[j]; else right[j] = right[j + 1] + arr[j]; } int res = Math.max(left[arr.length], right[0]); // 遍历需要删除的负数点 因为只有负数才需要删除 删除后才可能达到需要的连续两个段的最大值 for (int i = 0; i &lt; arr.length; i++) { // 只有小于 0 才需要分隔 if (arr[i] &lt; 0) { // 注意的是需要分离开 i == 0 i == arr.length - 1 因为 默认是0 会影响 res 为负数的情况 if (i == 0) { res = Collections.max(Arrays.asList(right[i + 1], res)); } else if (i == arr.length - 1) { res = Collections.max(Arrays.asList(left[i], res)); } else { // 平时的话 去掉这个值 只需要在三部分中取较大值与 res 比较即可 res = Collections.max(Arrays.asList(left[i] + right[i + 1], left[i], right[i + 1], res)); } } } // 没有小于 0 的话 说明全是正数 // 返回和即可 return res;} 两个 dp 数组保存状态 那么可以使用一个循环得到结果。 仍然需要一个数组保存以 arr[i] 结尾时的最大子序和 需要一个数组保存以 arr[i] 结尾时删除一个数字的最大子序和 那么删除的这个数字可能是遍历的 arr[i] 或者 之前就已经删除了一个数字，arr[i] 不能被删除。所以第2个数组的更新策略即deleteOne[i] = Math.max(deleteOne[i - 1] + arr[i], dp[i - 1])。 即保留当前的 arr[i] 那么只能取之前删除了一次的最大子序和 和 删除当前的 arr[i]，那么就要去之前没有删除数字的最大子序和 dp[i - 1]。 12345678910111213141516171819public int maximumSum(int[] arr) { if (arr == null || arr.length == 0) return 0; int[] dp = new int[arr.length]; // 保存删除一个的结果 int[] deleteOne = new int[arr.length]; dp[0] = arr[0]; // 最小值到达 -10^ (4) deleteOne[0] = -100000; int res = Math.max(dp[0], deleteOne[0]); for (int i = 1; i &lt; arr.length; i++) { dp[i] = Math.max(arr[i], dp[i - 1] + arr[i]); // 要删除一个数的话 要么保留当前数 和 之前删除一个数形成的最大值比较 要么删除当前这个数 与之前保存的最大值比较 deleteOne[i] = Math.max(deleteOne[i - 1] + arr[i], dp[i - 1]); res = Math.max(res, Math.max(dp[i], deleteOne[i])); } return res;}","link":"/2021/01/18/leetcode/"}],"tags":[{"name":"code","slug":"code","link":"/tags/code/"},{"name":"求职","slug":"求职","link":"/tags/%E6%B1%82%E8%81%8C/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"summary","slug":"summary","link":"/tags/summary/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"hello world","slug":"hello-world","link":"/tags/hello-world/"},{"name":"笔试","slug":"笔试","link":"/tags/%E7%AC%94%E8%AF%95/"},{"name":"concurrent","slug":"concurrent","link":"/tags/concurrent/"},{"name":"kmp","slug":"kmp","link":"/tags/kmp/"},{"name":"string","slug":"string","link":"/tags/string/"},{"name":"qrcode","slug":"qrcode","link":"/tags/qrcode/"},{"name":"吐槽","slug":"吐槽","link":"/tags/%E5%90%90%E6%A7%BD/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"图算法","slug":"图算法","link":"/tags/%E5%9B%BE%E7%AE%97%E6%B3%95/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"}],"categories":[{"name":"life","slug":"life","link":"/categories/life/"},{"name":"code","slug":"code","link":"/categories/code/"},{"name":"tutorial","slug":"tutorial","link":"/categories/tutorial/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}
{"pages":[{"title":"关于我","text":"苦逼学生党 读研中","link":"/about/index.html"}],"posts":[{"title":"18年年终总结","text":"&emsp;&emsp;18 年年终总结虽然会迟到，但永远不会缺席 回顾 2018 年 考研 （是不是该算到 2017 呀）2333 考研复试 本科毕业 毕业设计&amp;答辩 读研 助教 实验室项目 学习前端基础 搭建博客（姑且现在算是搭了个雏形出来了） 补 java 基础（算了买了书 还没看完的感觉） 算法（算是准备开始补基础吧） spring boot &amp; spring cloud（了解下现在较“新”的微服务架构吧） 考研初试&emsp;&emsp;从 17 年上半年开始准备到 17 年 12 月 22 号考试,整个 17 年都在复习中度过。本来开始的准备如下： 17 年上半年过完数二的两门数学的第一遍 &amp; 英语的单词 暑假 \b 过第二遍强化 &amp; 复习政治 9 月份开始过数学的第三遍 &amp; 各科的往年试题（包括数一）&amp; 专业课 &emsp;&emsp;结果最后变成了： 上半年半摸鱼状态，结果最后只把高数的上半册给复习完做完题；英语的单词也大概背了一半 暑期学校还规定必须自主实习，自己找实习。于是乎整个暑假大部分是咕咕咕状态。毕竟找了老师实验室，接了一个活儿，从零开始入门 \bjava web。幸而在室友的帮助下还是顺顺利利的交差走人。 虽说暑假还去报了个数学的复习班，花费了 2K 大洋复习两周，感觉还非常一般，大部分自己看书做题的时候都能总结 \b 出来，只有一道题和一个极限四则运算的条件印象深刻。总之就是 \b 着实不太值，如若真需要补习，还不如报全程班（甚至线代是边上课边复习的）（每天上课都是坐最后面两排，然而不是因为去得晚，只是因为\b前面的是留给VIP和全程班的，每个位置上还有编号，真是太真实了） 从 9\b\b 月份中下旬开始着手第二遍数学复习 + 政治复习。每天上午 10 点起床（反正也不去图书馆抢位置）背两个小时单词，吃完饭去自习，晚上 10 点回来，12 点睡觉 期间找了一位 dalao 去 \b 一起复习，不得不说没开暖气之前的主楼和主南 10 月份和 11 月份是真的冷 11 月开题直接被否，1 月重开 最后不得不说肖秀荣老师 🐂🍺，甚至还记得考试前几天在主楼走道背肖四的感觉，不得不说最后还是挺稳的 emmm，因为我们系的专业课考试是 C 语言和数据结构，花了一周时间做了做往年的题目，最后结果也颇为满意 &emsp;&emsp;考研的 \b 初试还是全凭实力的，大家都在同一个起点上，做同一个卷子，颇有一种高考的感觉，可是却也回不到高考的状态了（虽说高考也不想再经历了）。最后总结初试的经历，感觉还是有几点可以说一下： 每年的考试范围都会在研招网上公布，要考研首先去了解自己考啥，具体都是啥 如果你对自己的初试有 \b 安排，那么你一定要了解一下学校在大三和大四的安排，因为你永远不知道学校会在什么时候给你扔一堆莫名其妙的事儿来 政治早点开始好，9 月后开始的我，那两个月痛不欲生，每天复习得第一件事儿就是背政治，背不下去了，各种数学题泡着。重复着政治=&gt;数学=&gt;政治的无限循环 因为时间的关系，我是不可能有大量的时间练习英语写作啥的，于是英二就靠着考研单词和最后两个月的突击写作练习撑起来，最后结果也算满意，本来也没打算拿高分，事实证明单词也确实重要 专业课，看自己的 \b 学校的情况吧 复试&emsp;&emsp;18 年 3 月初就是准备复试，各类专业课准备呀啥的，反正咱也没上机啥的。其他也没啥好说的，只是当时毕设老师人招满了，另外联系了一位导师，也就是我现在的导师。\b&emsp;&emsp;PS：如果你初试高，又联系了老师…… 本科毕设&emsp;&emsp;说实话，当我从毕设老师手里面第一次拿到这个题目的时候，觉得不难嘛。可各种技术都不太会，外加还要去针对当前项目提出一种可行的解决方案。当时的我确实做不到 现在好像也不一定。毕竟咱们软件工程，引用百度百科如下 软件工程是一门研究用工程化方法构建和维护有效的、实用的和高质量的软件的学科。 百度百科baike.baidu.com/item/软件工程/25279 简言之就是需要针对用户需求做出用户满意软件制品。 &emsp;&emsp;虽说整个毕设过程中，开题、二次开题、中期和最终答辩都被怼出 shit 了，不过最终还是在学长的帮助下还是写了个 Demo 出来。\b 打心底里是十分感谢当时的那位学长的 从毕设来说。当时的第一版 Demo 是学长写出来的，也是学长给我讲了 \b 他对着这个东西的设计思路和想法。然后在此基础上慢慢完善了这个 Demo（虽然感觉没啥大用）。 从技术来说。当时用的是 Spring boot + Spring Security + Oauth2.0 完成的 Demo，因为整个项目是基于 Spring cloud 的微服务架构，所以使用了能够这些能够方便集成的框架。可以说从 Java Web 以及微服务架构的角度来说，学长给我开了一扇窗。 毕业&emsp;&emsp;\b 天之涯海之角来形容毕业的情况感觉十分贴切。本科的几位室友，一位已经远在美国求学，一位 \b 在同一学校读研。\b&emsp;&emsp;回沙河拍照那天，站在原来的寝室门口，\b 又想起本科刚入学的时候初入北京。独自一人来到学校，到最后毕业的时候，普航 julao、小强、九哥、男神、托儿、儿子……大学也已是给了我太多太多。 读研&emsp;&emsp;战战兢兢地度过了初试、复试、毕设后，最终还是顺利本科毕业读研了。研究生的整体生活给我的感觉是较忙的，老师的项目、学校的课程和考试等等，到寒假最开始的时候（就是现在）还在忙助教期末 \b 成绩的事儿。 项目&emsp;&emsp;第一次接到老师给的项目 \b 应该是在 4 月中旬（\b 巧了，那时候毕设还正开始做）。整体的内容大概是做 NLP（怎么大家都是机器学习，臣妾不会呀），对爬取到的文本的语义实体进行识别，如时间、人等。 &emsp;&emsp;毕竟是老师给的第一个项目，还是颇为重视，花了一个月从零入门机器学习。吴恩达的 coursera 上的和斯坦福大学的公开课程都强行看了一遍，最后得出的结论是 ———— 臣妾看不懂（数学实在是难，特别是概率论）。 &emsp;&emsp;于是转头直接寻找今年的 \bNLP 实体识别实现。还真找到了,16 年的论文，Bidirectional LSTM-CRF实现。于是想通过 python\b 实现这个 \b 思路，再一看 keras、tensorflow 等一堆东西，emmm，还是直接去找别人实现的吧。 &emsp;&emsp;就这样直到七月中旬，终于在把别人的 \b 实现扒下来改改的情况下，通过一个开源的 Word2Vec 的预训练向量集和一个小量的训练集，这东西终于能跑起来并且能识别一定量的 \b 实体了。 &emsp;&emsp;最终这个方案还是失败了。为什么呢？做了这多，到最后一步才发现————没有数据！！爬取的数据没人去手动清洗（工作量太大），而且数据量太小，也不能保证训练出来的正确性。但是项目总得继续，于是乎硬着头皮直接人工清理了爬取的数据，然后做个可视化。本来还想清洗完扔进去训练看看，可当清洗工作快结束时，才发现最开始的清洗方法错了，导致清洗的数据完全无法扔进去训练。于是我的工作就变成了可视化前端+后端。 &emsp;&emsp;对于这个项目，只能用心情复杂来形容了。 暑假&emsp;&emsp;暑假留下来参与了实验室的其他项目（可怜那时候还要去看机器学习），从学姐手里分到了一个还算 \b 不那么困难的部分（感谢下学姐的怜悯）。 &emsp;&emsp;暑假的项目在我的理解上感觉像一个 proxy，各类请求的转发和存储。\bKoa2 实现，于是边学 nodejs、es6、koa2 边写。不得不说 js 写起来就是比 java 感觉简单···毕设的 Demo 写得实在是太难受了。 助教&emsp;&emsp;这学期的另一个大事儿就是当了一门本科课的助教。其实读研之前曾经幻想过当助教（主要是当时也想复习点啥，比如算法？数据结构？）。可真正要去当助教的时候，才觉得十分蛋疼———因为研一又要上课、还有实验室的各种活儿。跟我搭档的另一位助教，经常自嘲为实验室最忙的人，大概是就是因为这些事儿吧。 &emsp;&emsp;当助教，每周都要批改、统计 180 份各位同学的作业。对我来说一个晚上才能勉强改完作业，再花一个晚上才能统计完成。然而助教最难受的地方是 \b 同学们的问题（虽然平时来问的同学不多，期末陡增）。毕竟是两年前的 \b 科目，好多细节都记不太清楚了，可研一的课程、实验室的活儿一做完，根本没啥时间和精力去复习这门课，我只能说对同学们说这门课的助教我尽力了。\b &emsp;&emsp;当然，最后统计期末成绩的 \b 时候还出了一点小纰漏 \b，几位 \b 同学的最后一次签到给计算掉了，只能真诚的给各位同学说一声对不起了（虽然他们也看不到就是了\b）。 学习&emsp;&emsp;整个 18 年可以说是被各种事情 drive 着去学习的一年 考研的时候被自主实习 drive 学了一波 Java Web 被毕设 drive\b 了解了一波 Spring Security、Oauth、Spring Cloud 被项目 drive 学了一波机器学习，虽然最后无疾而终，也让我明白我确实搞不懂机器学习 被项目 drive 学了一波前端，虽然到现在 css 依然是一块痛处 &emsp;&emsp;以上 18 年的学习也让我对自己 19 年的有了一定想法，主要分为面向工程扩充自己吧 工程 设计模式 算法、数据结构 框架 vue spring node 刷题 leetcode? (面向工作学习 23333)","link":"/2019/01/25/18summary/"},{"title":"Hello World","text":"&emsp;&emsp;建立这个博客只是兴趣所致为了完成18年的既定目标 &amp; 找一个能够写些东西的地方（毕竟工作之余心情烦闷之时？！） &emsp;&emsp;指不定写些啥就咕咕咕了 &emsp;&emsp;谨以此hello world\b纪念下博客正式搭好","link":"/2019/01/23/hello-world/"},{"title":"hexo静态博客搭建（一）hexo简介&amp;环境","text":"一直以来都有搭建博客的想法，粗略了解了一下WordPress和hexo，\b在尝试过WordPress的安装部署后果断选择了hexo。准备从以下几个方面介绍下hexo的搭建过程 hexo简介 &amp; 环境 hexo命令 &amp; 主题 hexo自动部署 hexo简介我们首先来看看hexo官网对hexo的介绍 超快速度 支持 Markdown 一键部署 丰富的插件 \b简而言之，hexo就是 一个基于nodejs的博客引擎 支持ejs等模板引擎 通过渲染Markdown文件生成博客所需各类静态文件 有较为完整的\b生态支持，包含各种插件，满足大部分需求 所以对于熟悉nodejs的用户能够通过hexo快速搭建一个博客 hexo环境nodejs环境nvm + nrm 可以使用nvm进行nodejs版本切换和管理 国内环境下推荐使用淘宝的npm源cnpm或者使用nrm切换到淘宝源 全局安装hexo-cli1npm install hexo-cli -g 使用包管理器 osx环境下使用homebrew安装 1brew install nodejs git环境windows可以通过访问git官网下载安装包即可 各类linux系等建议通过包管理器下载","link":"/2019/01/26/hexo-1/"},{"title":"hexo静态博客搭建（二）hexo命令&amp;主题","text":"简单说下常用的命令 hexo命令hexo 安装nodejs环境安装完成后，在全局下安装hexo\b-cli，命令如下 1npm install -g hexo-cli hexo-cli安装完毕后才可以执行hexo命令 hexo init1hexo init [folder] folder是当前博客目录，通过hexo init命令可以在指定的folder目录下自动克隆一个hexo项目模板（一个nodejs项目），并自动安装相应的依赖，其目录文件结构如下. ├── _config.yml - hexo的相关配置信息 ├── db.json ├── node_modules - nodejs依赖 ├── package.json - nodejs项目信息 ├── scaffolds - 发布模板 ├── source - 存放用户资源，如文章等 └── themes - 主题，会根据主题生成 、对应的页面 \bhexo server通过hexo init命令建立博客模板文件后，其自带了landscape主题，可以通过hexo server直接启动 hexo new1hexo new [layout] &lt;title&gt; 新建一个名为title的文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替 hexo publish1hexo publish [layout] &lt;filename&gt; hexo将文章组织为draft和post两种状态，因此在使用了hexo new draft someFile后需要通过hexo publish命令将处于draft下的文章正式发表，这样才能在blog中正常查看。 hexo generate &amp; hexo deployhexo generate会将markdown文件等一系列的文件编译转换成标准的静态文件。hexo deploy命令会将本地生成的静态文件一键部署到远程服务器。 hexo 主题hexo提供了丰富的主题，这个blog使用了icarus 安装 如果blog通过git来进行版本控制，可以直接通过git安装1git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 可以去其github页面上下载release包，解压到themes/icarus下 微调样式大部分对于样式的微调都能在issues页面找到 阅读页面三栏转二栏 添加about页面icarus将about页面挂载在了网页的/about页面123cd blog根目录/sourcemkdir abouttouch index.md 中文设置 icarus自带中文设置1vim blog根目录/_config.yml 将language项调整成zh-CN，hexo会自动加载themes/icarus下的i18n文件 导航栏中文设置修改/themes/icarus下的_config.yml将 添加comment插件icarus提供了对于gitalk、Valine等评论插件的支持，这个blog使用了valine对评论插件 valine申请创建应用申请leancloud 应用申请成功后将下列key填入icarus下的_config.yml中 添加valine人数统计在添加valine的comment组件的时候，发现valine支持文章的浏览数量统计，考虑添加valine阅读数量统计。找到layout/comment/valine.ejs，添以下到else block中 1234&lt;span id=&quot;&lt;Your/Path/Name&gt;&quot; class=&quot;leancloud-visitors&quot; data-flag-title=&quot;Your Article Title&quot;&gt; &lt;em class=&quot;post-meta-item-text&quot;&gt;阅读量 &lt;/em&gt; &lt;i class=&quot;leancloud-visitors-count&quot;&gt;1000000&lt;/i&gt;&lt;/span&gt; 123456(function () { var span = document.getElementsByClassName('leancloud-visitors')[0]; span['id'] = window.location.pathname; // 貌似 title 有bug // span.dataset.flagTitle = document.title;})(); span的id会作为valine统计的主键，所以直接填入每个location对象的pathname即可，即可做出阅读量统计","link":"/2019/03/06/hexo-2/"},{"title":"hexo静态博客搭建（三）hexo自动部署","text":"经过前两步，一个能看的blog已经搭起来了，在本地调试完成后，还是需要一个地方部署这个blog。因为有一个服务器来科学上网，所以就吧这个blog部署到了同一个vps上（这两个应用都不是太吃资源）。所以接下来介绍如何将blog部署到一个远程的服务器上。 自动部署到VPS需要用到的hexo命令hexo是一个部署静态blog的工具，因此所有的文件最后都会被生成浏览器能认识的html、css、js文件。 12hexo cleanhexo deploy 因此需要在部署前使用hexo clean命令，清理已经生成的/public下的静态文件和db.json，再调用hexo deploy命令使用hexo提供的部署命令将本地的静态文件部署到远程服务器。 hexo deploy use rsynchexo deploy提供了多种方式来部署到远程，这里使用了rsync来部署。 需要在服务器端做什么需要注意的是，要求您提供的实际上是一个能通过SSH登陆远程主机的Linux用户。Hexo会自动处理关于rsync使用的一切操作。因此，您需要在远程主机上为您的Hexo站点建立一个用户，并允许其通过SSH登陆。不过，这里的port，的确是指rsync监听的端口，请确保防火墙打开了该端口。 hexo对于rsync的介绍 也就是说rsync需要我们提供一个可以通过ssh登录的用户，这样hexo可以使用该用户通过ssh将需要部署的文件移动到远程服务器上 本地设置在搞定了用户之后我们就需要在blog的配置文件_config.yml中配置deploy选项来启用rsync帮助我们来进行远程部署，如下图所示。 使用git hooks来自动调用hexo deploy在完成了deploy选项的设置后，可以通过hexo deploy命令一键将静态文件远程部署到服务器上，但是每次都需要手动调用下这个命令，同时因为blog放到了github上，所以为了偷个小懒就利用git hooks，在本地commit后，调用hexo deploy命令将本地的文件部署到远程。 首先进入到hooks文件中 1cd .git/hooks 添加以下内容到post-commit文件中，这样每次在本地commit后，都会出发这个hook，调用这个文件中的命令 1234567#!/bin/bashcd /path/to/your/blogecho &quot;----- 开始 -----&quot;hexo cleanhexo generatehexo deployecho &quot;----- 结束 -----&quot; warning:首先需要进入到你的blog的根目录下，这样hexo的命令才会被正确的调用","link":"/2019/05/17/hexo-3/"},{"title":"春招java后端实习岗笔试总结","text":"春招实习生投递小结春招实习生一共投了4家企业，包括字节、美团、阿里和快手，因为两边都相对较多，因此将笔试和面试分开吧 字节倒在了二面 美团刚刚完成了二面 阿里完成了三面(不过我觉得我跟他们需求的方向相对较远，因此希望渺茫) 快手，可能是投递得比较晚，至今(4月24日无任何消息) 因为觉得大部分希望渺茫，所以特地记录下春招的笔试和面试情况，希望有所帮助。 有几家是在牛客网提供的平台上笔试的，不过笔试的方式都是大同小异，保证入口class是Main即可，可以先去牛客网上试试 不保证自己的贴出的代码能够全部AC，仅供参考 阿里阿里的笔试是所有人统一时间参加笔试，我是在4月13日参加的晚上的笔试，抽到的笔试题都是跟图相关的 第一题题目描述一个数组，表示一组动物（动物的下标从1开始），数组中的数值表示仰慕的对象，这个动物可以给自己投票，或者跟自己仰慕的人投同样的票，如果数组中数值为0 那么他只能给自己投票，而且数组中的位置代表了这个动物的能力大小 后面的动物越低，他们只能仰慕前面的动物。 问：每个动物可能拿到的最大的投票数为多少 1234567例：输入[0,1,1,1,1]输出4 1 1 1 1 解释：第一个动物只能给自己投票，所以他给自己投票，而后面的动物仰慕1号动物，因此全部跟自己仰慕的对象投相同的票，即1投自己后，后面的2 3 4 5号动物全跟1投相同的票，投1，因此1号最多4票，其他的只有自己投自己。 例程（笔试中写的代码没有考虑到递归情况，只对了10%） 可能解法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.company;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Scanner;public class First { // 递归的去寻找后面能够投票的是哪些 public static int dfs(HashMap&lt;Integer, List&lt;Integer&gt;&gt; map, int start, boolean[] memo) { List&lt;Integer&gt; temp = map.get(start); memo[start] = true; int res = temp.size(); for (Integer admire : temp) { if (start &lt; admire &amp;&amp; !memo[admire]) res += dfs(map, admire, memo); } memo[start] = false; return res; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] admires = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { admires[i] = scanner.nextInt(); } HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); // 简历崇拜者图 for (int i = 1; i &lt; admires.length; i++) { if (!map.containsKey(i)) { map.put(i, new ArrayList&lt;&gt;()); } if (admires[i] != 0 &amp;&amp; admires[i] != i) { if (!map.containsKey(admires[i])) { map.put(admires[i], new ArrayList&lt;&gt;()); } List&lt;Integer&gt; temp = map.get(admires[i]); temp.add(i); } } System.out.println(map); for (int i = 1; i &lt;= n; i++) { System.out.println(dfs(map, i, new boolean[n + 1]) + 1); } }} 第二题题目描述给定三个参数，3个参数表示，城市数，路径数和目标城市，然后下面有路径数的输入i,j,k，分别表示从i城市到j城市花费的时间是k。 问：如果每个城市都有一个人，那么这些人，到这个目标城市，然后回来，在路上花费的时间的最小值 (ps:实际上就是个最短路径的问题，但是我当时根本就没咋弄过图算法，只了解基本的dfs，bfs和连通分量啥的，因此笔试的时候是用两边dfs做的，存在问题，最短路算法应该去复习一下) 可能解法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.company;import java.util.*;public class Second { static class Pair { public Integer key; public Integer value; public Pair(Integer key, Integer value) { this.key = key; this.value = value; } } public static int resolve(HashMap&lt;Integer, List&lt;Pair&gt;&gt; map, int start, int end, int size) { boolean[] memo = new boolean[size]; return dfs(map, start, end, memo, 0); } public static int dfs(HashMap&lt;Integer, List&lt;Pair&gt;&gt; map, int start, int end, boolean[] memo, int current) { if (start == end) return current; memo[start] = true; List&lt;Pair&gt; temp = map.get(start); int res = Integer.MAX_VALUE; for (Pair tempPair : temp) { if (!memo[tempPair.key]) { res = Math.min(res, dfs(map, tempPair.key, end, memo, current + tempPair.value)); } } memo[start] = false; return res; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(), x = scanner.nextInt(); HashMap&lt;Integer, List&lt;Pair&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; m; i++) { int a = scanner.nextInt(), b = scanner.nextInt(), l = scanner.nextInt(); if (!map.containsKey(a)) { map.put(a, new ArrayList&lt;&gt;()); } List&lt;Pair&gt; temp = map.get(a); temp.add(new Pair(b, l)); } int res = Integer.MIN_VALUE; for (int i = 1; i &lt;= n; i++) { res = Math.max(res, resolve(map, i, x, n + 1) + resolve(map, x, i, n + 1)); } System.out.println(res); }} 美团美团的笔试，我们同学投的前端和后端是一样的，美团的笔试环境跟牛客网差不多，注意一下即可 第一题题目描述给定两个整数n,m。n表示有多少个学生，m表示有多少门课程，接下来输入n行，每行m个，表示这个学生在这门课的得分是多少。 问：每门课获得最高成绩的人（可能有多个）一共有多少个，重复的人在不同的课程中拿第一门，算同一个人。 可能解法（笔试时AC）123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.*;public class MFirst { public static class Pair { public Integer index; public Integer credit; public Pair(int i, int i1) { this.index = i; this.credit = i1; } } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); HashSet&lt;Integer&gt; res = new HashSet&lt;&gt;(); int[][] credits = new int[n][m]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { credits[i][j] = scanner.nextInt(); } } PriorityQueue&lt;Pair&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; b.credit - a.credit); for (int j = 0; j &lt; m; j++) { for (int i = 0; i &lt; n; i++) { queue.add(new Pair(i, credits[i][j])); } if (queue.size() &gt; 0) { int max = queue.peek().credit; Pair temp; while (queue.size() &gt; 0 &amp;&amp; (temp = queue.poll()).credit == max) { res.add(temp.index); } } queue.clear(); } System.out.println(res.size()); }} 第二题问题描述给定一个输入，a、b、m和x。采用一个循环算法，如下 12while (true) x = (a * x + b) % m; 问循环几次，这个算法中x值会跟最开始一样 可能解法（因为没有注意到题目的数据范围，爆了int，AC了65%）1234567891011121314151617181920212223242526import java.util.HashSet;import java.util.Scanner;import java.util.Set;public class MSecond { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(), b = scanner.nextInt(), m = scanner.nextInt(); long x = scanner.nextLong(); int counter = 0; Set&lt;Long&gt; set = new HashSet&lt;&gt;(); while (true) { x = (a * x + b) % m; if (!set.contains(x)) { set.add(x); counter++; } else { break; } } System.out.println(counter); }} 第三题问题描述给定一个输入n和m，接下来输入n个数。 问：如果这个n个数（这n个数有可能重复）进行排列组合会产生n*n的组合（自己可以和自己组合），那么如果将这些组合从大到小排序（排序的规则是对于一个组合[i,j] 如果i相同，则按照j的大小排序，如果i不同，i大的排在前面），问第m小的一个组合是什么 12345678例输入：3 41 2 3输出(2,1) 可能解法(当时AC了)123456789101112131415161718192021222324252627282930import java.util.Arrays;import java.util.Scanner;public class MThird { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); int[] nums = new int[n]; for (int i = 0; i &lt; n; i++) { nums[i] = scanner.nextInt(); } Arrays.sort(nums); int divide; if (m % n == 0) { divide = m / n - 1; } else { divide = m / n; } int counter = 0, counter1 = 0; for (int num : nums) { if (nums[divide] &gt; num) counter1++; if (nums[divide] == num) counter++; } int temp = (m - counter1 * n) / counter; System.out.format(&quot;(%d,%d)\\n&quot;, nums[divide], nums[temp - 1]); }} 第四题问题描述给定一个输入n，k。n表示要输入的数组的数的数量，k表示其中的某个数，然后输入n个数。 问：如果要让k这个数成为中位数，那么需要再往这个数组里面添加几位数才行 12345678例输入4 11 2 2 3输出2 解释：要让1成为中位数，那么就需要再在1前面添加两个数即可成为新数组的中位数 可能的解法（TODO）我当时以为整个数组的输入顺序，包括现在的一切都不能改变，因此我只找了离现在的中心最近的k的位置，然后看看它需要几位数才能到中心（AC 10%） 实际上这道题是一个桶排序，只需要统计小于K的有多少个数，等于K的有多少个数，大于K的多少个数，然后再去跟mid比较，最后得到答案（感谢镇宇dalao） 我的解法 1234567891011121314151617181920212223import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class MFourth { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), k = scanner.nextInt(); int mid = (n + 1) / 2; int[] nums = new int[n]; int remember = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { nums[i] = scanner.nextInt(); if (nums[i] == k) remember = Math.min(remember, Math.abs(mid - i)); } int res = Integer.MAX_VALUE; System.out.println(res); }} 正确的解法(模仿镇宇dalao的思路来的 TODO) 1 第五题问题描述给定两个字符串s1,s2 问：s1子串与s2的的子序列的匹配个数（子串就是说是连续的，子序列就是说是不连续的） 解法方法当时第一反应就是dp，可是没有找到递推公式，普航julao AC了，请教了一下，大致理解了思路，就是用dp[i][j] 表示以s1[i]结尾子串和s2[j]结尾的子序列能够匹配的数量 转移方程的话就是需要考虑s1[i] == s[j],相等就说明我们只需要看dp[i - 1][k](k = 0 ………… j-1)的和+1即可 ，因此最后一位是匹配的，而不等，就直接赋值为0即可 讨论原文：dp[i][j]是s[i]为尾的的子串与t[j]为尾的的子序列的匹配个数 如果s[i] != t[j]那直接就是0了 如果不是的话 那就是以s[i-1]以及所有t[k]（0&lt;=k&lt;=j-1）的匹配个数的和（因为这些匹配的接上s[i] t[j]还是匹配的）再+1（只有这一个位置匹配前面全部不匹配的情况） 代码（TODO） 1","link":"/2020/04/24/interview-1/"},{"title":"java多线程(一)","text":"一直以来，对于java的多线程变成都不是十分了解，趁着项目需要一个多线程的爬虫学习了一下，主要是一些基础的相关知识，以上。 Runnable和Thread踩的第一个坑是关于实现Runnable接口和继承Thread类来build一个新的可运行线程。 12345678910111213141516// Runnable接口定义public class MyRunnable implements Runnable { private int count = 5; @Override public void run() { System.out.println(this.count--); }}// Thread类定义public class MyThread extends Thread { private int count = 5; @Override public void run() { System.out.println(this.count--); }} 1234567// 启动public static void main(String[] args) { while (int i = 0; i &lt; 5; i++) { new MyRunnable().run(); // new MyThread().start(); }} 在main中分别启动两个类的5个线程，可以看到Runnable接口并没有实际上的并发的启动几个线程，而是在第一个线程执行完毕之后，再去执行第二个线程，阻塞式地执行完new出来的5个线程，究其原因，是因为Runnable接口实际上并不是实际的Thread的入口，Runnable接口只是定义了Thread的任务逻辑，也就是说Runnable接口中的run()方法只是实现了现在需要的业务逻辑，实际的多线程仍然需要通过Thread类开始。 多线程的执行在实际的线程执行的时候，较为传统的做法是通过new Thread(new Runnable()).start()来执行，然而新建线程实际上也是一个较为繁重的操作，以下是反编译的Thread类代码 123456789101112131415161718192021222324public synchronized void start() { if (this.threadStatus != 0) { throw new IllegalThreadStateException(); } else { this.group.add(this); boolean started = false; try { this.start0(); started = true; } finally { try { if (!started) { this.group.threadStartFailed(this); } } catch (Throwable var8) { } } }}private native void start0(); 以上可以看出，Thread类的start()方法，最终调用了native的start0()，最终通过JNI(java native interface)调用底层提供的pthread_create方法，最终进入linux系统提供的创建线程的接口。 在javase 1.5提供了一个Concurrent的包来提供方便运行的多线程类库，如提供运行的ExecutorService，提供线程安全的各类Blocking Queue、Blocking List、Concurrent List等，以及一些原子操作类库。 其主要通过ExecutorService来启动需要执行的线程 12345678910111213// 创建无限大的线程池，当任务到来的时候ExecutorService e1 = Executors.newCachedThreadPool();// 创建指定pool size的线程池ExecutorService e1 = Executors.newCachedThreadPool(int poolSize);// 创建一个指定pool size的定时线程池ExecutorService e3 = Executors.newScheduledThreadPool(int poolSize);// 创一个执行单个线程的ExecutorService e4 = Executors.newSingleThreadExecutor();// 通过submit方法可以将需要执行的Runnable Callable接口实现类启动e1.submit(() -&gt; { // do something}) 任务通过ExecutorService提交到指定的线程池，或者执行线程中异步的执行，即submit函数不会阻塞主线程的执行，最终子任务的逻辑会异步的在新线程中执行 但是如果主线程依赖子线程的运行结果，在submit方法执行后，返回了一个Future对象，Future对象可以在主线程中控制子线程 12345678910111213141516171819ExecutorService ex = Executors.newCachedThreadPool();Future f = ex.submit(() -&gt; { try { Thread.sleep(10000) } catch (Exception e) { e.printStackTrace(); }})// 获取子线程的运行结果f.get()// 在1s之后get没有返回执行结果 即没有执行完毕 则出发timeout 可以通过这种方式来对一些任务做超时处理try { f.get(1000, TimeUnit.MilliSeconds)} catch(TimeoutException | InterruptedException | ExecutionException e) { e.printStackTrace();}","link":"/2019/12/10/javaConcurrent/"},{"title":"kmp","text":"算法书上使用的是 有限状态机 来描述的 kmp 算法。 之前学习的是通过前后缀匹配的方式来做的 kmp 算法。 现在记录一下。 参考：阮一峰 blog 前后缀匹配实际上 kmp 的思想就是在字符串失配的时候，跳过一定的距离，就可以不用重置模式串的指针到开头。 如 字符串 a b a b a b a b c a 模式串 a b a b a b c a kmp a b a b a b c a 如上所示，在失配的时候(红色所示)，会找到前面字符串中相同长度的前缀和后缀(绿色所示)，这样在匹配的时候，就可以直接跳过这些长度的前后缀，向右移动 6 - 4 = 2 位长度即可。 那么实际上 kmp 的原始运算算法就可以得到了 1234567891011121314151617181920public int kmp(String origin, String pattern) { // 获得 kmp 数组 int[] next = getNext(String pattern); int i = 0, j = 0; while (i &lt; origin.length() &amp;&amp; j &lt; pattern.length()) { if (origin.charAt(i) == pattern.charAt(j)) { i++; j++; } else { // 因为有相同的前后缀 所以直接赋值 就找到模式串相等的前缀的位置 j = next[j]; } } // 返回开始的 index if (j == pattern.length()) return i - j; // 没有找到匹配 return -1;} 而 next 数组的求法，实际上是 pattern 字符串自己跟自己匹配，找到相等的前后缀的长度 以 a b a b a b c a 为例 字符串 前缀 后缀 匹配的最大长度 a [] [] 0 a b [a] [b] 0 aba [a, ab] [a, ba] 1（a 与 a 匹配） abab [a, ab, aba] [bab, ab, b] 2 (ab 匹配) ababa [a, ab, aba, abab] [baba, aba, ba, a] 3(aba 匹配) …… …… …… …… 上面的表格表示了前后缀的匹配情况，下一步就是求得这个前后缀匹配长度的 next 数组 123456789101112131415161718public int[] getNext(String str) { int n = str.length(); int[] next = new int[n]; // 让模式串错位一个开始 kmp 的匹配过程 int k = -1, j = 0; while (j &lt; n)) { if (k == -1 || str.charAt(k) == str.charAt(j)) { k++; j++; next[j] = k; } else { // 根据已经匹配的长度 重新定位 k = next[k]; } } return next;}","link":"/2021/03/07/kmp/"},{"title":"签到二维码生成","text":"做这个东西的灵感来自于[lufer blog]('http://coder.lufer.cc/2018/06/11/%E7%8C%AB%E9%80%94%E6%A0%A1%E5%9B%AD%E7%AD%BE%E5%88%B0%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%BC%AA%E9%80%A0/')以及室友的微信小程序拆包帮助 做这个事儿的原因嘛，最近老师准备派出去出差去学习 2 周，但是人出去了，课还是要上的，尤其是杜博士的课又在最近开了。杜博士还是有点怕的，而好巧不巧杜博士又喜欢用微信小程序的猫途校园来进行二维码签到，所以才有了做这个东西的动力和原因。 猫途校园签到二维码生成去年已经有学长大致做过了这个二维码的伪造签到，粗略的看了一下，大概对面只是在二维码里面明文放了一个课程ID&amp;学生ID&amp;&amp;当前时间的三元组，通过在一两秒的时间内不断变换当前时间来变化二维码，达到必须在现场才能签到的目的。可是咱另外给你生成一个二维码不就行了嘛，23333。 问题这周，专门截图了一个签到二维码来扫码试试，扫码结果如下。 1x%97%C5%94joj%97%93%92%98ggf%60%60f%9C%C8%C6%C7%94a%95%8B%5B%98%C7%C6%9Bke%98%98chni%95%92%60foo%99%9Anm%99%89Wfjloqljnnikp%5D%u5F46%uC46F%uC8C6 嗯？！！这和说好的有点不太一样呀，不是说好的明文存储嘛。在看到%后面跟着数字的时候，果断猜想是使用了 js 的encodeURI()来转换了一下无法在浏览器路径栏里面识别的字符，然后果然···猜错了。 小程序反编译（这时候又要膜一波室友了）在尝试了常见了编码和加密方式都没办法拿到加密信息后，在室友的帮助下吧微信小程序反编译拿到了源代码。(微信小程序会在本地缓存一个.wxapkg的文件，该文件可以反编译出源代码，反编译工具)（以后就算他的加解密方法变了，仍然可以通过这种方法重新拿到他的加解密方法）。总值最后拿到的加解密方法如下。 1234567891011121314151617181920212223// 加密function encrypt(str) { for ( var t = String.fromCharCode(str.charCodeAt(0) + str.length), n = 1; n &lt; str.length; n++ ) { t += String.fromCharCode(str.charCodeAt(n) + str.charCodeAt(n - 1)); } return escape(t);}// 解密function decode(str) { str = unescape(str); for ( var t = String.fromCharCode(str.charCodeAt(0) - str.length), n = 1; n &lt; str.length; n++ ) t += String.fromCharCode(str.charCodeAt(n) - t.charCodeAt(n - 1)); return t;} 总体来说就是通过 js 来产生了 unicode 码的偏移，在加密时，除了第一位偏移了字符串长度的位数，其他的均是偏移了后一个位置的位数。唯一不懂的是escape()和unescape()方法，一查，这两方法都已废弃···，与之对应的是 encodeURI()和decodeURI()。于是将之前扫码拿到的字符串丢进去解码，可以得到 现在变成了一个四元组(&amp;分隔)，第三个是标准的 unix 时间戳，因此我们只需要拿到四元组的其他三个信息，然后自己生成一个时间戳，就可以生成跟他完全一样的二维码了。最后它每 3 秒钟生成一次二维码，不超过 5s 的时间差就接受该二维码。 自己写了个生成的页面，需要上传一个自己的签到截图，就会每 1s 中在页面中生成一个二维码和分享链接，把分享链接发送给在教室的大佬们帮忙签到即可。实例如下majexh.xyz/qrcode","link":"/2019/05/17/maotuQrcode/"},{"title":"一些吐槽的集中贴","text":"4d5b354008a79032227bf4d2dcfc8ac348f0e256e558eca4a30f845895870ce8fb5e8f8fb0907b486c29aa2a1c5cfe43a0705892748bdafa18044d53171cc282a0158f686b95a14bcaf0529f57c540003c62a7154aa095f6ec434dc400a39f688aa811682f6add45ab148d3b3db137d2504a6ba23d02bf8e27fcf15870338c4189be78f818213f6d0522cdd8c983de66fb311b49504a97e808e3f21cb7db10b53ca9b3923add8b1fdbbabfa5505967f64ec0ff60944b56fae433a1a74f7511ca8f8484fd9e4c481bac1c5829892916b279fe4a04d6650e7345a86eec364bb88cc1ce5b9ec114091d2db12cf261a8b4c313c5279a406feac438b048099a81be4ccd0e527e5545c2addecac06e02f4259258e053a883f827d340a069c2e6dc79cba72c5e343b07f7fb171ed5d5a7f6959bbc4ec8b7d56865439f31bb687714f6aabb20f004b8f27c03a695740f8f25f1c4f0798638972112bcb01278020cb2f89b6f8dad32a32e44d30138ef398f48e664ac41e3ff2b7d229e32562a738bb1bb3666a21a1a15cbb514b0058c93ba847b27e2aa44b16ee36138e3471e09d4753074a8c22d35dc22984534e293d8710ab2390695a782c21421e260949d26f064bb2042b1eb9b6eb0ae2eb3c703f0bc8dfd570ae6e64bcf5d4108bde72bee146f5e74d4feaed1084dae44bc28f68195647dd0c66257794f96a29f123328ef4ce41794ad0221ae1a32a8d20ccb7ca9f48b046b66a992abdbd182a94fba8688137e73aad952d6551255bf24338bb63fc044529af044db22ff678bb676397f297d2b549c73ce8aa848a18af352b3bc5478ce6fab9a7310c71d441218457c40a7e16191c7a98ea448ff0e6a30fd22c5bdf1296217d60093d531fd138917a6c497ec6fef4cd3b7ce973d957b9f0083e175c3c392053854791752186d1ae1d0cfd23665ea1f81dfcc0d8c3a647cbee8698e8df8838632342bd3bed47ba0efcadaafcfb625dab57f98a2a0a7aaef180e83c39395a0f78ab3c0c20873785277ad190341831ae827000c9266e624852fbb029e4361bcbdead34af7a9e45a5503459f16bb7cffdd828c6cd17a7178b479d734860935147cc0b3a8752204e62c22332eb5ef60c1e940fb83cff797bfa0e0638b64ac3dd5033f877669bc3bd8fb00e190728a0e5ca524581466ebac3e6be2f356ad33f31c58e06fa9d381c4ca0d2c1f37262df51e24cfe0b82db1556c713298204522c5c1fd68f0b3d9c9624988c71e15374570ffa63ed576d998d0c667c90f4e2b6c14e43f4f0d7845b15afd741653752c4185d9753baacd2030daebe63adc3298129ca30acbbb20de0eae03e7537329e899bb8044499cdc58aaa0eb586261f0fa27d63372cd6b7c57735c0e8ec8735a514cb2ad3918bbe9424eb9acd8deaf9ca50518d905e79581401fd37da4b950e63f80269aa498b0f98dfad2786f19b2af0813f5c4877c8fcfcf6c8e105686cf5e206ec2ac3411b57299a22317cbf5aa898f3bd2b3a2d5aa983545c0a1d427f114405ae63f8d1929ccc6575f64a417cb61ebad62e5972f566504b0f1b0b434656fe94427f40b77526e4706d083378101c4cba3c1d1fa63c6005e34b0422a483e6e71eb2c0b6a77d7399bab425594cb11593f933f6ee0646b7fb1fd26e148b0908356d9ad990f1fa1cc5a6e0f1a2b7b5e50de6f4d27d8bd5d3c282fb8217891689671d82878fea61049e4d28e2b1a5212f3e19dcb1a48d982a2d4d2c6d9ac4fe5f9c0eb3ac13b31bbbe188340703d3821ae4fd53216c1238d96296f91ce3b70bd22f84cd96b047738bea76f779a9ab11180e23dd59e45dfdc8ca08770872c0b585cb2467618882ee089b0b497e01a1b889e2300a983e90cf7077703eed7bb3575435c612946c469de05bdaba01a37aede9c4d949cdfbde171917c49d933c790a6980a2c02fff811f725174c5c16f8799db9336a47d19e8c700627f5c55727b6faa41a0d6c2664044f0ed693536cd1f7d78fc7630c4e6e46ddc6d54854cae7da43dc257d4f183d728ad961fb3aed31255385cb403b3c6df996b7a57645ea608f8e452e5eeb9b38eb372434c1c66b7b203a4dfb80c55f5ab17ed7a94a84e955a2a91c76ee066cb72544cde387a7f8a20ac2c4d8e7653d2940780e637bfa5d6022b9d246d561c99f985bbc1a62aec6a1874a96ad20f0434ed6e77120ea669fdf4d685b09faf6e98c2ec5992d90676927f5fcf53c4601c666795731946e67b2d71f2d52cb6ae91e4155d735bc069610459d814103a0c72eec23569413a268853f5a8f4947e7430664a2648aa1c57cec3ca37559ffdb43ae1dee24c039b66bf660bfdd0ae7aecbb9b95dc1f1d6a2ab44f915fb1b7396d350b72bb8a4d42f60c085f40aaed15be042475efe8a59c2e087875f747c2f9d3820659e985a78e7e3f28a9b13142c033d7c5c303fe436286eb6aeff8030b6157d4208d4e863e089c6d85027dc20f94c372d9cc3f07733a1282a59390c6b7acfb5a7eea9968ea701e812fb5f1350d37e4544f67533ddd45b4092e404eac1439aea27efc5bf008d1660ba7563185f1f173e8e4b9c06befb0379e21fc595f97619944ae9ecfeb13ed9663c36886d68daebc3f7e711d9f25e75802119d69e3c3827f71bb43df7fab27e25b165a2b8a452394fec9e0728f4d25e129cbb36d31e7854bd9d4693e3a37d1820aef9084547dacf914f74f40b50a597dbff19ffd07ff6150de3e26d58a1109727b4bf8800d928bb38ac236dde1638567af7dd8ad952841930ddfabcba921bad528c9adae8276429c0bb17c0c94b050183a670302a5a248e5c8a08e3858d7fcc5090a543b33f71f516ff8f08a494dadafd151a657d906ef916a36a08f41f57b3e25ccb00b50340cb7e39c711ca8d34a9f4e016a338edc18e04a68dc0f04135ec3d3f31198d50853b3ff0edbbd9860ca9c81eafd302e5fc4437c60d5ebbdf68a38ce6c3f83c78405efc213fa97eb0c794b6dd05ffdc5f1fb077d586a2e6253c836517ad099ff05e0aebe0f3e6647feba34a82698baf06f712a85e78c96dcda8c0e8a638e33d608f42674b40b86baaa8a4733aa7b848e4e5e09a5c40e77fab935376631db73555c16b2b38a696a802e3a6e8ed370af64ca5a0faf274e092ed71d1c4db0c62e67b1c714963ec16ccda1959d8ba6712d350b0a9a2c3db51f456b3badd8906d8f0888f48333c51724a3680a615d0a2f3973ba48dddb52723d6291802348a199a59f8bc38017439d2209133740c6b9e8f78c0ea9df1d575db892f6e0ca9d4afbe629536872a8f01f0e2479f4b785b09702924e4a739666d0a5bb247f8f504401891ce00c527b7fad8b74faed7fd74fe93189601ec046d2527d2736c5719b72d96fd06a3670b0d230fbb15a90e8c433a1141061a5fc45cc34a000bd0bc202b9d14e53fd78368421f3222a55c5f0fcd26dbf2c544d8b2f13926bdaf1801762ccdb04725cc998788ec31d0737ef3bb5409261ebe4990e689b9a38dd3cbb4dc45e90a22642b2b87ffaaab1aba29af1fc44212f6c7e13f19cb0fe6be9cdb99baf0bb3108a2e85dfc0f8b67b35298ff1b4bbf61356a14b5ab9b89e0c31ac728216a6aacb5a53ef039c3cdd4daec86f5f41b3f641cd46f7e285793f2cb26128ca14b05546f9ec7966e0438f4db8c014b2c0273689378ed09e519f4e7267a1d5471814f277a955cb1baee7676a3b17c03988c2aee7bbd7ecac07b8b737049f1817f4a1ca9a76a98f5834eafe5d2c593b6ec5e4348a1c6d7d83a1005258a28677c254e9565c05ae2c57d157040dfc2098b7066cbb17b6a7d36b4f127dd6ca8bb0db615d760f8929aa53b75856b954c5fe0fae0bf5b5c210903dc14d09ac01622cd59fcb03dca7ca20bf5b0365978a91e3c3f5fde00d155aa0a68471c5ae2f65f788b8e58e865122c91db123aeb6de64a3addbf563b79427ad1c2c35537518c3e1b2da839c070bd7d3f9a16f91cf474dd55fac9d00922b7fd6701497dd88e9dcd75a1addeefc49046f0be0ddff92afd7dfca598ac58c7ad90b3a5e8a0e8f0294e866520e3e78a7c3a077e95d2d6a7703318832db8b3c5f54e8c4dc39c18ae57576777f0b4b697560c5ee566248f812cc6512388f6e12ed462da3116e81de74ede576d6b91e8d1294cdc7e312ffdda47448e004aa4e1bea540f68359a28dbef30dbcaf3a08b6eb4a8f7464ede227148bdfd07f1a1871330f0bee4b596223cf9f58de545ac9e7a1c9f3fa37048573a0a57208fb358ef319276887fec7dcff3df6d1cbe5c80320c0b47b25b4ee8aa456d4fe68d971a7254e964b039d2abdce999f682deab5f8638545e2fbce9f8ab351874332300c6c1f08c97d7f11788824c3489e92394b833ea2bc4831c023a48400d5282a4116ade049eb4072131ecd78b36e62ad5c7a4777f5985192a41fdc5f67f435c3cf88cd5c0e8bf6afe1aacdfda46518f3d2d35365ef414c90181d88d9f3d533453b60c5860fac4097303120b65858d92f7069590bfe95a16556c1a3d2959629c205dfb1f5e90fb506f0812e34a9a7f928d176a57edeef33f3ed331b5a7f646ea799ac6be92ae3a9deb6e0c5e22714462523f1d196e3a7353cf73bba326bc2c5f0f98c2beb226f2fe2d5e7979c5d7792cb5dc61d10e86feb5dcf7cc00fe4ebc69451c7d3203a25d90702bcc0c4c5c675fb3e7605cc0eeda56210a92f0f28550387c1519c1cf8205afad3608ac96f7d8e857e6712ea38b17017d7148224e99b6cf7612d24630d28b3b3fe278e18c9b036b7cdae3440f1c6f7a96965fa423d2196751763654fbae9688792a19fd12097390e2013f1eaf57bd1226338bec7dcf9e0ebbc8a570cea7856a08d6c00522b98aae7c48cbbea62773bf66cd08ce72b154ead879c762736ef874869c8d176587bf7f4bda03845c43d0cd84dda632181b3636f4a14b91a464416582f12ef6761b319507f9e74fc24d70c66bd4cf7bf6f0e7cae7a932a96b9aec9cee1873dd1d35a80a2aee1d9cc074925559b8bbf0e9f5772fac4d6738f36479f631390aea94a96812fe651d9b3d5896cd89910ce3cf78490d1c874434a43d7c9dd24fc54de74090cf0b302a21be8942f1057bef175edd1cf6229059e777f53effc833178e4c88ffa08f1ed647ce575e6abc26a5aade790b181c936861c5f8ed6722ec84a43a21832957972832684e7e6498689f3abb78f2f84823e272b25f9a6e425a845b8333a83d08d521be9a9af1fde78bd70de54ebc1e58293ae11038d32c3ca8ac5b833a72a95ab251bc2ae11a5a0c611ca8c96dadf3ecb8bf5a5d50e47a665680b67d3ff3c427d3b5d5094d5dfab2fdf1d3693635bc22c946a62a2d482dc072cae1ee671beb8df147d1b099d7da37d3c413af71a75e77a236a1be10f3bafc8f4231347ac2902f0570b76ac7fb90d4dc2530afdf4364d1229e98f2d4dc3360e438663877b0c087108e9068367ab663a1a0bffcb663d61f4047ef9f906034d879fef1eefe48d30427d1976972c8236a5243a67ea0025987da2e80f172b32a638975853f26f8bc932487be81722756babf1650e182c07bd4c76d33106261db6769f9cf75869b212542440d14a69b2f118c95980cc2e69d0df802fc20a7ae2bf2146753894b92ddb87c8de59fcd4047ab09b22595f7e410810b89d40b2a64741009b4be258e4d7a655f59d13042467eb37e18dd4e5bf2a07455af6b8717294a7cda59d31e3444edcae18bb561ada2824adb0ae0620d935d3ee724e6c5ae3ae79acad04ac56f2632301912fbca0de68b6befc0018c1277c3a42f081682b69bcee5c8441f47c45b9146693ec8a6b935e66c99b2db8441db819b29af1a7eb4807becc40999438bfcebc8d6c78ebaaa4fa15e603fed563f6b930fce0ad747d93572e68af2b5de135d1882f7e0b47c9b2511137c727318b879d17e1cca17d12d28dcbfae7fa81b2e7eef237d51b03678c9b906e2a6eab2a630600af09cb3d04eea3a12827af4535f7c50d954eb88b0b10e86051d8033d134061c6f67d1f986af3ce9da9c5fd3b563976a729d039fa72567c749d50d3b3ce746d11f508a1ebd7389599420c4e012e7dbd986a40288b9be6e2939bfb75b4eebd334405532822daa32e85e2ab375d70ed8d9ba2badcc4250dc848cd8ff3358726fd8d04fde49f9b5f273ba3b37e8e6df0f46884a4f3ee6dc227c91b8caf4a5492cc336c6b1be8f1f81435416a09e6d155a39cb181b06b187d4943981e888fd169cfdd7e097bfd7a8aa4c3f3a6185c963cee12328850f97ca6d536de86d7e74263e620a0994f32cc09dcf3a4eea5f589c9b767039ba7121dfc1187c9a99fccc4b3b341c8c41705f08f06dcd61c8d2ff73b63f91cb99b40eeb21f4e65690851578a07b9b31710bd0f9b71d98117767a57dcae11aabfe93b5fb87d680bef7a2de954da595d0c4f49ce5a2d45d87d51e15c7cba5c93401d85fe1297c123d60573b17193ea17430b57591a51e7afb2534b11028dfb5ef4607f3d9f5235f05021d395f72864ccc83becd4e109b6a8cce14ba86dd75b301ffd2acac7a9c9bb35cf6bfdeb1e8c8f56fe3167184214d04c5411717b5421300277b517f387bd1f3874119e57b22742242b81ab65018f104e0d6396ea17d1f1ca48611c02c927755a8a4c09bd63af2f7223fd4fc1d57ab53f603285dd9e9540da4082256187c50b2d9ca8d055a2cae61f1a2249f86231cb9e0ef13237efbce5a36a040e31221fc74572bac84fc8023384b47f6fde437045db25ea33e26df7abaf144efdb05ee1b96c95c6f088fb5027cc6d375301c9f9c7f8186f55e09e19f045cebd0dc7e8d4ad43bc2539cb619994a564807638ecd6211917d43a9afaeaafe58472314b9baa1ce9ba6495d90346af8f52c037936ea66d7393cf79dbcc0639ea6ed093df58055003226a44f1c3d4b21cb2b4925b30b567c888c0af70224cfb32dc70038df637cc1f23748c6cfe690a5be6fc76a3781a69db413bb92c7d3812cdea9e63d39865364ff9aeb8d1e8357184a4c5d08c7bf7303b01acef09d417552ac6d2bc1fe2132fb2d836437b55e1aed40809db2b2163e31f4ae78b3409ac6f79c96fbf391a9cd298843fcc572c8bbd1bf739b88e0dbabb3e82824a894e5465b7a67602d41e682f6f7dc0f1a0f1048cd945912e8cb3fdce312fb245653d56de7b49c66bd722f4d9a50f28b2e90954f86f93c4072c3881b7a108ab16e7c3a4b7df172741774772e22083963a16c5ca4c7b07611451a0c0603d89d731908352e97855983def85a6e0218e6753afdd787790763a91417dd396c19b74da6f3277e2f6e771977b0db1bc875269cb94b92c747c77edf79cb00e3cff95550e279e78b5cefd4dd2e4561b625550e3f80b75abd840f08e86fc233552b70e9cd6ddb71f2f5effdeb950e03fa3c261585252f76116550102073610820ae9f98ff86fd83cedacce9657480e913a93fa36020d52bb3835aafa92048bd7a52988ead550a0e03efd546b8826962ebbb07b57899067a9fe455ec3df86b0e57477fb87816ea63662f52df221f61ac52f208f140e9cb525bec09225ba6af0ab7854b236949a31a9d3855516bda811412a772cdbe62ad27fbaa0e012b97610b3ba6a8fe0edc5962a9fb7cca652a87efe81e0eefac379f229261e35c7cfe025ecc12a32518c8b28b1f69d5e3650e33da460ed186b4a913c5943d0274ae4d659ac0a91d2bc685d47b157034447aa7761c493f3663d22dda3a590588348942c689f401f17bcebea7ed399f445b2dbafb9c77d332bbd24e858657e6c7a7ee331aed150abc2aadd352e3abd59f7b77c62317e51bb21249fa8905e2608162307a418052299fa9ab051e9d2b0067300b0820b7a11fef103098d602bbeb456bb20e33dbbe32a476a27fdb71361d85ee9b2a264021439aa471410bef2686c03842434d14d8b93ca60c4c0281da4ae93748096df8b4e21f3c11b2c3e6f5b6ac96ac8079073d18bb0aaaeff933ea51cceac2746509b2c70574d14b31cce44099670e1e58a701c4d55132c5593927f1457ddda8110a76b3dcf0e10d77ddf21593e43eb98e6c09d628114da0aa06a8d162a1f8e4d5e1320c3824bcccf3c1ce3a4d9875ebc1fb38855a98d8c39d9015abca386c0b56b983261510c639e366990c1c89d3a1f74864f1ef13b15f94c2efd7fbb28bc6ea75c4ac66b6aef012ea577f579ad2d4e34543945c9c854ccda362f15a2d4189f2849495878f08d50277d3306953e5b64d6bbdd63d277a4e096ee586852eb2d58e16b923dd569abf53475f1a61f31bf22bcbb3af5c8 请输入密码查看.","link":"/2019/09/15/master-complaints/"},{"title":"sort","text":"排序算法简单实现了一下几种常见的内排序算法 希尔排序 归并排序 快速排序 堆排序 基数排序 桶排序 希尔排序希尔排序实际上就是带步长的插入排序。不同于插入排序按照步长为1进行排序，希尔排序采用了缩进的步长。每次只在相同步长的一组数据中进行排序。 参考维基百科的解释，例如对于数组 []int{1,5,4,2,7,45,75,3,4,87} 排序，选取步长为 len() / 2，且每次步长缩进一半 其排序的过程如下 第一次分组 （步长为 5） 排序前 1 5 4 2 7 45 75 3 4 87 调用插入排序 对竖着的数组进行排序 1 5 3 2 7 45 75 4 4 87 第二次分组 (步长为 2) 排序前的数组为 {1,5,3,2,7,45,75,4,4,87}，因此分组为 1 5 3 2 7 45 75 4 4 87 插入排序 1 2 3 4 4 5 7 45 75 87 第三次分组 （步长为1） 步长为1 相当于插入排序 直接排序即可 123456789101112131415161718192021222324252627package sort// shell 排序是一个按照步长的排序// 其本质是一个优化了步长的插入排序func shellSort(nums []int) { if nums == nil || len(nums) == 0 { return } step := len(nums) / 2 // 步长不停的缩短 直到最后成为插入排序（但是插入排序这个时候已经基本有序 所以跟完全乱序的相比 会有比较大的性能提升） for step &gt;= 1 { // 插入排序 for i := step; i &lt; len(nums); i++ { exchange := nums[i] j := i - step // 将 i 位置的数 插入到 以 step 为步长的数组中间 for ; j &gt;= 0 &amp;&amp; exchange &lt; nums[j]; j -= step { nums[j + step] = nums[j] } // 上面已经把数据迁移完毕 只需要在 j+step 即结束迁移的位置 把需要插入的数据插入即可 nums[j + step] = exchange } step /= 2 }} 归并排序1234567891011121314151617181920212223242526272829303132333435363738394041424344package sortfunc mergeSort(nums []int, i, j int) { if i &gt;= j { return } mid := (i + j) / 2 mergeSort(nums, i, mid) mergeSort(nums, mid+1, j) // 这一步 i -&gt; mid mid + 1 -&gt; j 已经是有序的了 merge(nums, i, mid, j)}func merge(nums []int, i, mid, j int) { tmp, index := make([]int, j-i+1), 0 iStart, jStart := i, mid+1 for iStart &lt;= mid &amp;&amp; jStart &lt;= j { if nums[iStart] &gt; nums[jStart] { tmp[index] = nums[jStart] jStart++ } else { tmp[index] = nums[iStart] iStart++ } index++ } for iStart &lt;= mid { tmp[index] = nums[iStart] index++ iStart++ } for jStart &lt;= j { tmp[index] = nums[jStart] index++ jStart++ } for m, n := 0, i; m &lt; len(tmp); m, n = m+1, n+1 { nums[n] = tmp[m] }} 链表的归并排序其实思想跟普通的归并排序基本一样，但是需要注意的是。归并分链表的时候，要直接截断链表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func sortList(head *ListNode) *ListNode { return mergeSort(head)}func mergeSort(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } mid := divideList(head) return mergeTwoListNode(mergeSort(head), mergeSort(mid))}func mergeTwoListNode(left, right *ListNode) *ListNode { res := new(ListNode) mov := res for left != nil &amp;&amp; right != nil { if left.Val &gt; right.Val { mov.Next = right right = right.Next } else { mov.Next = left left = left.Next } mov = mov.Next } if left != nil { mov.Next = left } if right != nil { mov.Next = right } return res.Next}// divideList 会把 list 分为两个 list// 会截断原来的 nodefunc divideList(node *ListNode) *ListNode { if node == nil || node.Next == nil { return node } fast := node.Next for fast != nil &amp;&amp; fast.Next != nil { fast = fast.Next.Next node = node.Next } mid := node.Next node.Next = nil return mid} 快速排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546package sortfunc QuickSort(nums []int, i, j int) { if i &gt;= j { return } p := partition(nums, i, j) QuickSort(nums, i, p-1) QuickSort(nums, p+1, j)}func partition(nums []int, start, end int) int { base := nums[start] i, j := start, end+1 for true { i++ for i &lt; len(nums) &amp;&amp; nums[i] &lt; base { i++ } j-- for j &gt;= 0 &amp;&amp; nums[j] &gt; base { j-- } if i &gt;= j { break } swap(nums, i, j) } swap(nums, start, j) return j}func swap(nums []int, i, j int) { if nums[i] == nums[j] { return } nums[i] = nums[i] ^ nums[j] nums[j] = nums[i] ^ nums[j] nums[i] = nums[i] ^ nums[j]} 堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package sortfunc defaultCompare(a, b int) bool { return a &gt; b}// Heap 根据输入的 compare 构建不同的堆// 默认小顶堆 -&gt; 从大到小排列type Heap struct { nums []int compare func(a, b int) bool}// shiftDown 移动顶层的向下func (h *Heap) shiftDown(k, n int) { for 2*k+1 &lt;= n { j := 2*k + 1 // 注意这个地方 大顶堆的时候 因为需要把小的东西往下沉 所以需要选择的是 子节点中 的较大值 // 小顶堆的时候 由于需要把大的东西往下沉 所以需要选取的是较小值 （因为比较小值小 这个节点一定比两个节点都小） if j+1 &lt;= n &amp;&amp; h.compare(h.nums[j],h.nums[j+1]) { j++ } if h.compare(h.nums[j], h.nums[k]) { break } swap(h.nums, k, j) k = j }}// popUp 最下面的浮动到最上面func (h *Heap) popUp(k int) { for k &gt;= 0 { var father int if k%2 == 1 { father = k / 2 } else { father = k/2 - 1 } if h.compare(h.nums[k], h.nums[father]) { break } swap(h.nums, father, k) k = father }}func NewHeap(nums []int) *Heap { return &amp;Heap{nums: nums, compare: defaultCompare}}func NewHeapWithCompare(nums []int, compare func(a, b int) bool) *Heap { return &amp;Heap{nums: nums, compare: compare}}func (h *Heap) Sort() { n := len(h.nums) - 1 // 首先将输入构造成堆 for i := n / 2; i &gt;= 0; i-- { h.shiftDown(i, n) } // 这样排序是吧最小的排在后面 for n &gt;= 0 { swap(h.nums, 0, n) n-- h.shiftDown(0, n) }}func swap(nums []int, i, j int) { if nums[i] == nums[j] { return } nums[i] = nums[i] ^ nums[j] nums[j] = nums[i] ^ nums[j] nums[i] = nums[i] ^ nums[j]} 基数排序基数排序的思维很简单，就是根据数字的每一位来排序 首先排序个位，根据个位数字 分别放到 编号 0-9 的桶里面 然后再排序十位，最后直到最大的数字也为 0 即可停止 1234567891011121314151617181920212223242526272829303132333435363738394041424344func maximumGap(nums []int) int { if len(nums) &lt; 2 { return 0 } biggest := nums[0] for _, num := range nums { biggest = max(biggest, num) } // 基数排序的桶 分为 0 - 9 lists := make([][]int, 10) base := 1 for biggest &gt; 0 { // 每次循环前都重置 for i := 0; i &lt; 10; i++ { lists[i] = make([]int, 0) } // 排序数组 for _, num := range nums { i := num / base % 10 lists[i] = append(lists[i], num) } // 根据每轮的顺序 重新赋值 nums 数组 for i, index := 0, 0; i &lt; 10; i++ { for j := 0; j &lt; len(lists[i]); j++ { nums[index] = lists[i][j] index++ } } biggest /= 10 base *= 10 } res := 0 for i := 0; i &lt; len(nums)-1; i++ { res = max(res, nums[i+1]-nums[i]) } return res} 桶排序桶排序也很简单 直接根据最大小值分桶 然后根据其数值放到不同的桶里面 排序 只需要遍历桶的 下标即可 1234567891011121314151617181920212223242526272829303132333435363738func maximumGapWithBucket(nums []int) int { if len(nums) &lt; 2 { return 0 } smallest, biggest := math.MaxInt32, math.MinInt32 for _, num := range nums { smallest = min(smallest, num) biggest = max(biggest, num) } // 桶排序 counts := make([]int, biggest - smallest + 1) for _, num := range nums { counts[num-smallest]++ } res := 0 var pre *int for i, num := range counts { // 表示没有数字 if num == 0 { continue } if pre == nil { tmp := i pre = &amp;tmp continue } // 比较 res = max(res, i - *pre) tmp := i pre = &amp;tmp } return res}","link":"/2021/02/24/sort/"},{"title":"简单图算法","text":"图算法简单实现了无向图、无向加权图、有向图、有向加权图的几种算法，包括: 遍历 dfs bfs 应用 环图 拓扑排序 双色问题 最小生成树 prim krusal 最短路径 Dijkstra 拓扑排序遍历 bellemanFord 图的数据结构以下均使用邻接表标识 无向图 无向图设计得有点尴尬 其实没必要 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class UndirectedGraph&lt;T&gt; implements Graph&lt;T&gt; { public HashMap&lt;T, UndirectedNode&lt;T&gt;&gt; map; public UndirectedGraph() { this.map = new HashMap&lt;&gt;(); } public Set&lt;T&gt; keys() { return map.keySet(); } // 无向图 两遍都要加 public void addEdge(T from, T to) { if (!map.containsKey(from)) { map.put(from, new UndirectedNode&lt;&gt;(to)); } UndirectedNode&lt;T&gt; temp = map.get(from); // 说明加入了重复边 if (!temp.addNode(to)) return; if (!map.containsKey(to)) { map.put(to, new UndirectedNode&lt;&gt;(from)); } UndirectedNode&lt;T&gt; tempTo = map.get(to); tempTo.addNode(from); } public Node&lt;T&gt; adjacent(T from) { return this.map.getOrDefault(from, null); }}public class UndirectedNode&lt;T&gt; implements Node&lt;T&gt; { public T to; public UndirectedNode&lt;T&gt; next; public UndirectedNode(T to) { this.to = to; this.next = null; } /** * * @param to * @return boolean 表示是否加入成功 */ public boolean addNode(T to) { // 加入第一个节点的时候的判断 if (this.to == to) return true; UndirectedNode&lt;T&gt; temp = this.next; // 加入第二个节点时的判断 if (temp == null) { this.next = new UndirectedNode&lt;&gt;(to); return true; } while (temp.next != null) { if (temp.to == this.to) return false; temp = temp.next; } temp.next = new UndirectedNode&lt;&gt;(to); return true; }} 有向图 12345678910111213141516171819202122232425262728293031323334353637public class DirectedGraph { public int getCapacity() { return capacity; } private int capacity; private List&lt;LinkedList&lt;Integer&gt;&gt; nodes; public DirectedGraph(int capacity) { this.capacity = capacity; this.nodes = new ArrayList&lt;&gt;(capacity); for (int i = 0; i &lt; capacity; i++) { nodes.add(new LinkedList&lt;&gt;()); } } public LinkedList&lt;Integer&gt; adj(int node) { return this.nodes.get(node); } public void addEdge(int from, int to) { this.nodes.get(from).add(to); } public DirectedGraph reverse() { DirectedGraph reversed = new DirectedGraph(this.capacity); for (int from = 0; from &lt; this.capacity; from++) { for (Integer to : adj(from)) { if (to != null) { reversed.addEdge(to, from); } } } return reversed; }} 加权无向图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class UndirectedWeightGraph { public int getCapacity() { return capacity; } private int capacity; // 邻接表 private List&lt;LinkedList&lt;Edge&gt;&gt; nodes; public UndirectedWeightGraph(int capacity) { this.capacity = capacity; this.nodes = new ArrayList&lt;&gt;(capacity); for (int i = 0; i &lt; capacity; i++) { this.nodes.add(new LinkedList&lt;&gt;()); } } public LinkedList&lt;Edge&gt; adj(int node) { return this.nodes.get(node); } public void addEdge(int from, int to, int weight) { Edge edge = new Edge(from, to, weight); this.nodes.get(from).add(edge); this.nodes.get(to).add(edge); }}public class Edge { public int from; public int to; public int weight; public Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } // 根据传入的值 返回不同的 from to public int other(int in) { // 根据传入的端点 找到链接的另外一个断点 if (in == from) { return to; } return from; } @Override public String toString() { return &quot;Edge{&quot; + &quot;from=&quot; + from + &quot;, to=&quot; + to + &quot;, weight=&quot; + weight + '}'; }} 加权有向图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class Edge { int from, to; int weight; public Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } public int getFrom() { return from; } public void setFrom(int from) { this.from = from; } public int getTo() { return to; } public void setTo(int to) { this.to = to; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } @Override public String toString() { return &quot;Edge{&quot; + &quot;from=&quot; + from + &quot;, to=&quot; + to + &quot;, weight=&quot; + weight + '}'; }}public class DirectedWeightGraph { public int getCapacity() { return capacity; } int capacity; List&lt;List&lt;Edge&gt;&gt; nodes; public DirectedWeightGraph(int capacity) { this.capacity = capacity; this.nodes = new ArrayList&lt;&gt;(this.capacity); for (int i = 0; i &lt; capacity; i++) { this.nodes.add(new LinkedList&lt;&gt;()); } } // 有向图只用加入一遍 public void addEdge(int from, int to, int weight) { this.nodes.get(from).add(new Edge(from, to, weight)); } public void addEdge(Edge edge) { this.nodes.get(edge.from).add(new Edge(edge.from, edge.to, edge.weight)); } public List&lt;Edge&gt; adj(int node) { return this.nodes.get(node); } // 返回所有的边 public List&lt;Edge&gt; edges() { List&lt;Edge&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) { res.addAll(this.nodes.get(i)); } return res; }} 图的遍历方法以无线图为例，有向图和无向图的遍历基本一样 DFS DFS 即使用栈的思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DFS { public static &lt;T&gt; void DFSWithRecursion(Graph&lt;T&gt; graph) { Set&lt;T&gt; memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!memo.contains(start)) DFSWithRecursion(graph, start, memo); } } public static &lt;T&gt; void DFSWithoutRecursion(Graph&lt;T&gt; graph) { Set&lt;T&gt; memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!memo.contains(start)) DFSWithOutRecursion(graph, start, memo); } } public static &lt;T&gt; void DFSWithRecursion(Graph&lt;T&gt; graph, T start, Set&lt;T&gt; memo) { System.out.println(start); UndirectedNode&lt;T&gt; node = (UndirectedNode&lt;T&gt;) graph.adjacent(start); memo.add(start); while (node != null) { if (!memo.contains(node.to)) DFS.DFSWithRecursion(graph, node.to, memo); node = node.next; } } public static &lt;T&gt; void DFSWithOutRecursion(Graph&lt;T&gt; graph, T start, Set&lt;T&gt; memo) { LinkedList&lt;T&gt; stack = new LinkedList&lt;&gt;(); stack.add(start); memo.add(start); while (stack.size() != 0) { T top = stack.removeLast(); System.out.println(top); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) graph.adjacent(top); while (temp != null) { if (!memo.contains(temp.to)) { stack.add(temp.to); memo.add(temp.to); } temp = temp.next; } } }} BFS bfs 使用队列的思想 12345678910111213141516171819202122232425262728public class BFS { public static &lt;T&gt; void BFS(Graph&lt;T&gt; graph) { Set&lt;T&gt; memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!memo.contains(start)) BFS(graph, start, memo); } } public static &lt;T&gt; void BFS(Graph&lt;T&gt; graph, T start, Set&lt;T&gt; memo) { LinkedList&lt;T&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); memo.add(start); while (!queue.isEmpty()) { T first = queue.removeFirst(); System.out.println(first); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) graph.adjacent(first); while (temp != null) { if (!memo.contains(temp.to)) { queue.add(temp.to); memo.add(temp.to); } temp = temp.next; } } }} 图遍历方法的应用无向图连通分量12345678910111213141516171819202122232425262728293031323334353637// 连通分量public class Connected&lt;T&gt; { // 如果连个端点属于一个连通分量 // 他们的id应该是一样的 public HashMap&lt;T, Integer&gt; ids; public int count = 0; public Graph&lt;T&gt; graph; public Set&lt;T&gt; memo; public Connected(Graph&lt;T&gt; graph) { this.ids = new HashMap&lt;&gt;(); this.graph = graph; this.memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!this.memo.contains(start)) { dfs(start); count++; } } } public void dfs(T start) { this.memo.add(start); ids.put(start, this.count); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) this.graph.adjacent(start); while (temp != null) { if (!memo.contains(temp.to)) dfs(temp.to); temp = temp.next; } } public boolean connected(T from, T to) { return ids.get(from).equals(ids.get(to)); }} 成环检测1234567891011121314151617181920212223242526272829303132public class CheckCycle&lt;T&gt; { // memo 记录在dfs的过程中的节点 public Set&lt;T&gt; memo; public Graph&lt;T&gt; graph; public boolean hasCycle = false; public CheckCycle(Graph&lt;T&gt; graph) { this.graph = graph; this.memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!this.memo.contains(start)) { dfs(start, start); } } } public void dfs(T start, T parent) { memo.add(start); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) graph.adjacent(start); while (temp != null) { if (!memo.contains(temp.to)) dfs(temp.to, start); // 因为是无向图 因此在访问的时候 会在子节点上 重新访问父节点过来的那条边 因此这样记录父节点即可 else if(temp.to != parent) hasCycle = true; temp = temp.next; } }} 拓扑排序拓扑排序对于排队、课程安排之类的有帮助，其基于有向图实现 首先要做的就是有向图成环检测，因此成环是没有 拓扑排序 的 有向图成环检测 1234567891011121314151617181920212223public void DFS(DirectedGraph g) { boolean[] memo = new boolean[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { if (!memo[i]) { DFSRecursion(g, i, memo, new boolean[g.getCapacity()]); } } }private void DFSRecursion(DirectedGraph g, int start, boolean[] memo, boolean[] marked) { memo[start] = true; System.out.printf(&quot;%s &quot;, start); marked[start] = true; for (int i : g.adj(start)) { if (!marked[i]) { DFSRecursion(g, i, memo, marked); } else { // 已经成环 this.cycle = true; } } marked[start] = false;} 拓扑排序 有两种方法 逆后续排列。因为要找到 v-&gt;w 这种拓扑结果，那么在访问完 V 之后 访问 W 即其连接节点，用 stack 来保存访问顺序，再弹出栈 就可以得到 v -&gt; w 的顺序 12345678910111213141516171819202122232425262728public static List&lt;Integer&gt; topologySortWithRecursion(DirectedGraph g) { // 作为一个栈 List&lt;Integer&gt; stack = new ArrayList&lt;&gt;(); boolean[] memo = new boolean[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { if (!memo[i]) { // 根据一个出发点 找到其 拓扑排序 topologySortRecursion(g, stack, i, memo); } } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // 输出 stack for (int i = stack.size() - 1; i &gt;= 0; i--) { res.add(stack.get(i)); } return res;}private static void topologySortRecursion(DirectedGraph g, List&lt;Integer&gt; res, int start, boolean[] memo) { memo[start] = true; for (int adj : g.adj(start)) { if (!memo[adj]) { topologySortRecursion(g, res, adj, memo); } } res.add(start);} 遍历入度为 0 的点，因为能够作为开始节点的点，一定入度为 0，那么不停的遍历，删除边，维护一个入度为 0 的点的 collection 既可找到访问顺序 123456789101112131415161718192021222324252627282930313233343536// 2. 不停地遍历入度为 0 的点 然后删除public static List&lt;Integer&gt; topologySortIteration(DirectedGraph g) { int[] inDegree = new int[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { for (int adj : g.adj(i)) { inDegree[adj] += 1; } } Deque&lt;Integer&gt; inDegreeEqualsZero = new LinkedList&lt;&gt;(); // 找到为 0 的点 for (int i = 0; i &lt; g.getCapacity(); i++) { if (inDegree[i] == 0) { inDegreeEqualsZero.offer(i); } } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while (!inDegreeEqualsZero.isEmpty()) { int top = inDegreeEqualsZero.poll(); res.add(top); for (int adj : g.adj(top)) { inDegree[adj] -= 1; if (inDegree[adj] == 0) { inDegreeEqualsZero.offer(adj); } } } return res;} 有向图的强连通分量12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class DirectedGraphStrongConnected { public static List&lt;Integer&gt; KosarajuConnected(DirectedGraph g) { // 保存的强连通分量的 id // ids[i] 表示 i 节点属于哪个 强连通分量 id List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(g.getCapacity()); for (int i = 0; i &lt; g.getCapacity(); i++) { ids.add(-1); } // 遍历的时候的强连通分量 id int count = 0; // 先得到 反图 的拓扑排序 List&lt;Integer&gt; order = TopologySort.topologySortWithRecursion(g.reverse()); boolean[] memo = new boolean[g.getCapacity()]; for (int node : order) { if (!memo[node]) { recursionDFS(g, node, count, memo, ids); count++; } } // 根据拓扑排序 DFS return ids; } private static void recursionDFS(DirectedGraph g, int start, int count, boolean[] memo, List&lt;Integer&gt; ids) { memo[start] = true; ids.set(start, count); for (int adj : g.adj(start)) { if (!memo[adj]) { recursionDFS(g, adj, count, memo, ids); } } } public static void main(String[] args) { DirectedGraph g = new DirectedGraph(13); g.addEdge(1, 2); g.addEdge(3, 1); g.addEdge(6, 3); g.addEdge(4, 7); g.addEdge(2, 0); g.addEdge(11, 8); g.addEdge(10, 1); g.addEdge(0, 7); g.addEdge(0, 6); System.out.println(KosarajuConnected(g)); }} 最小生成树最小生成树都是基于贪心的思路和想法。由于需要生成的无向加权图的树（v-1 条边）的路径和最短，所以实际上是一个不断遍历最短路径边的贪心策略。 prim 算法 lazy 版本 在遍历所有的边的时候，不主动删除队列中的无效边，所以为 lazy 实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MinTree { // 最小生成树 指的是无向图中，能够生成的边的权重总和最小的树 // prime 的最小生成树实际上是一个贪心算法 // 通过 PriorityQueue 不停地生成权重最小的边 // lazyPrim 指的是在遍历的过程中 pq 中的边 是访问时才失效 public static Deque&lt;Edge&gt; lazyPrim(UndirectedWeightGraph g) { // 存储所有的边 PriorityQueue&lt;Edge&gt; minQueue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a.weight)); // 保存被访问过的节点 boolean[] marked = new boolean[g.getCapacity()]; // 保存返回的结果 Deque&lt;Edge&gt; res = new LinkedList&lt;&gt;(); // 保证 g 整体是连通的 // 随意选取一个节点作为开始节点 addEdgeToPQ(marked, minQueue, 0, g); while (!minQueue.isEmpty()) { // 抓到的一定是最短的路径 Edge top = minQueue.poll(); int from = top.from, to = top.to; // from to 两个断点都已经访问过 说明在两个端点之间已经找到最短的了 if (marked[from] &amp;&amp; marked[to]) continue; // 否则就找到最短的 res.add(top); // 将两个端点的 edge 加入到 queue 中 if (!marked[from]) addEdgeToPQ(marked, minQueue, from, g); if (!marked[to]) addEdgeToPQ(marked, minQueue, to, g); } return res; } public static void addEdgeToPQ(boolean[] marked, PriorityQueue&lt;Edge&gt; minQueue, int start, UndirectedWeightGraph g) { marked[start] = true; for (Edge e : g.adj(start)) { if (!marked[e.other(start)]) { // 另外一个断点没有访问过 minQueue.add(e); } } }} 及时版本 在遍历的时候，不再以边作为 优先队列 的遍历对象，而是采用对点进行遍历，在遍历的图中，不停的更新 优先队列 中点对应的最短边，以此减少调整堆的时间。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private static class Pair { int node; int weight; public Pair(int node, int weight) { this.node = node; this.weight = weight; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Pair pair = (Pair) o; return node == pair.node; } @Override public int hashCode() { return Objects.hash(node); }}// 实时的 prim 算法 与 lazy 不同的是// 在 v 这个节点 加入 pq 的时候 其余的非树阶段 应该只加入 到 树中最短的边// 相对来说 可以减少时间 因为 一个图的话 一般是 边比点多// 这个算法只用在 优先队列中保存点public static Edge[] prim(UndirectedWeightGraph g) { // 仍然使用一个 pq 保存最短的点 （到这个点的最短距离） PriorityQueue&lt;Pair&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(e -&gt; e.weight)); // edge[i] 保存 i 到 edge.to 的最短边长 Edge[] edgeTo = new Edge[g.getCapacity()]; boolean[] marked = new boolean[g.getCapacity()]; pq.add(new Pair(0, 0)); while (!pq.isEmpty()) { Pair top = pq.poll(); inTimeAddEdgeToPQ(g, top.node, marked, edgeTo, pq); } return edgeTo;}private static void inTimeAddEdgeToPQ(UndirectedWeightGraph g, int node, boolean[] marked, Edge[] edgeTo, PriorityQueue&lt;Pair&gt; pq) { marked[node] = true; for (Edge adj : g.adj(node)) { int otherNode = adj.other(node); // 已经找到了 if (marked[otherNode]) continue; // 说明还没有找到到这个点的最短距离 或者 // 现在的 edge 的 weight 更短 更新 if (edgeTo[otherNode] == null || adj.weight &lt; edgeTo[otherNode].weight) { edgeTo[otherNode] = adj; Pair p = new Pair(otherNode, adj.weight); for (Pair tmp : pq) { // remove 掉已经失效的边 if (tmp.node == otherNode) { pq.remove(tmp); } break; } pq.add(p); } }} krusal 算法 与 lazy prim 算法类似，其也是遍历所有的边并加入到 优先队列 中，但是遍历的时候采用的方法是通过 并查集 判断点是否已经找到了最短的距离，在找到最短距离后，会判断两个点相连，知道结果边集合大小扩展到 v-1。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MinTreeKruskal { // 使用 并查集 来判断加入的边是否成环 public static List&lt;Edge&gt; kruskalUseUnion(UndirectedWeightGraph g) { List&lt;Edge&gt; res = new ArrayList&lt;&gt;(); Union uf = new Union(g.getCapacity()); PriorityQueue&lt;Edge&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt((e) -&gt; e.weight)); pq.addAll(g.getEdges()); // 最小生成树 只能有 V - 1 个 （V 为 node 数） while (!pq.isEmpty() &amp;&amp; (res.size() &lt; g.getCapacity() - 1)) { Edge e = pq.poll(); assert e != null; int from = e.from, to = e.to; // 之前已经连接了最短的边 所以不用再连接了 if (uf.connected(from, to)) continue; // 连接两条边 uf.union(from, to); res.add(e); } return res; }}public class Union { // 并查集 int[] parents; public Union(int capacity) { this.parents = new int[capacity]; for (int i = 0; i &lt; capacity; i++) { // 初始化 this.parents[i] = i; } } public void union(int n1, int n2) { int rootOfN1 = find(n1); int rootOfN2 = find(n2); if (rootOfN1 == rootOfN2) return; // n1 root 连接到 n2 root 上 this.parents[rootOfN1] = rootOfN2; } // 找到跟节点 private int find(int node) { if (this.parents[node] == node) { return node; } return find(this.parents[node]); } public boolean connected(int i, int j) { // 判断两个 root 是否相等 int rootOfI = find(i); int rootOfJ = find(j); return rootOfI == rootOfJ; }} 最短路径最短路径其实跟上述的算法类似，也是一个类似贪心的策略，但是在遍历最短边的时候，或同时使用 relax 的操作，保障一个点经过一个中间点可能比直接到目标点的距离短这个问题。 Dijkstra 算法 基本与 prim 算法一样，只是加入了 relax 的操作 其只能处理非负的有向图 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static class Pair { int node; int weight; public Pair(int node, int weight) { this.node = node; this.weight = weight; }}// dijkstra 与 in time 的 prim 算法类似// 这些是找到单源最短路的public static Edge[] dijkstraMinPath(DirectedWeightGraph g, int start) { // 保存最短路径的边 Edge[] edgeTo = new Edge[g.getCapacity()]; // 保存最短路径的长度 int[] distTo = new int[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { distTo[i] = Integer.MAX_VALUE; } distTo[start] = 0; PriorityQueue&lt;Pair&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt((e) -&gt; e.weight)); pq.add(new Pair(start, 0)); // 每次都找现在最短的路径 然后 relax 路径 while (!pq.isEmpty()) { Pair min = pq.poll(); relax(g, min.node, pq, edgeTo, distTo); } return edgeTo;}// relax 节点private static void relax(DirectedWeightGraph g, int node, PriorityQueue&lt;Pair&gt; pq, Edge[] edgeTo, int[] distTo) { for (Edge adj : g.adj(node)) { // 因为 edgeTo 保存的是之前遍历的最短的路径 // 所以 如果通过现在这个点 + adj.weight 的距离 比 edgeTo 的短 就需要更新 if (distTo[adj.to] &gt; distTo[node] + adj.weight) { edgeTo[adj.to] = adj; distTo[adj.to] = distTo[node] + adj.weight; // 添加新的 或者 更新原来的节点的最小值 Pair p = new Pair(adj.to, distTo[adj.to]); // 更新 pq for (Pair tmp : pq) { if (tmp.node == adj.to) { pq.remove(tmp); } break; } pq.add(p); } }} 拓扑排序处理无环图 由于拓扑排序的性质，是从入度为 0 的点不断向外延伸，所以，如果根据 拓扑排序 的顺序访问图中的点，那么后面的点是一定不会再访问已经访问过的点，所以不会出现 relax。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 采用 dfs 做的 topologySort// 保证无环public static int[] topologySort(DirectedWeightGraph g) { boolean[] marked = new boolean[g.getCapacity()]; Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; g.getCapacity(); i++) { // marked 标识标记过的点 if (!marked[i]) { dfs(g, marked, i, stack); } } int[] res = new int[stack.size()]; int i = 0; while (!stack.isEmpty()) { res[i++] = stack.removeLast(); } return res;}public static void dfs(DirectedWeightGraph g, boolean[] marked, int start, Deque&lt;Integer&gt; stack) { marked[start] = true; for (Edge adj : g.adj(start)) { if (!marked[adj.to]) { dfs(g, marked, adj.to, stack); } } stack.addLast(start);}// 使用拓扑排序的单源最短路经// 只能处理无环的情况// 拓扑排序只能针对无环图// 由于 拓扑排序是从 无入度的点开始// 如果找最短路径从这儿开始的话 这个点 一定不会再次被访问到 所以只放松一次// 同理 解决单点无环图的最长路径 可以把 weight 取负 再来最短路径即可public static Edge[] topologyMinPath(DirectedWeightGraph g, int start) { int[] topologyPath = TopologySort.topologySort(g); Edge[] res = new Edge[g.getCapacity()]; // 初始化距离 int[] dst = new int[g.getCapacity()]; Arrays.fill(dst, Integer.MAX_VALUE); dst[start] = 0; for (int node : topologyPath) { relax(g, res, dst, node); } return res;}private static void relax(DirectedWeightGraph g, Edge[] res, int[] dst, int node) { for (Edge adj : g.adj(node)) { // 如果之前遍历的 到 adj.to 的距离 比从 node 经过 adj 到达 adj.to 的距离长 说明该更新了 if (dst[adj.to] &gt; dst[node] + adj.weight) { res[adj.to] = adj; dst[adj.to] = dst[node] + adj.weight; } }} BellmanFord 算法 能过处理负数的图，但是不能处理负数环（因为负数环能够达到任意短的负数）。 其核心思想是遍历 V 次 图，这样保障每个点都被遍历 V 次，找到最短的路径。 但是可以优化的点是，只有在上次被更改了长度的点才能加入队列中。 // 这个算法只能处理没有负权重环的有向图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 因为带有负权重环的图可以得到任意短的权重 是无效的public static Edge[] bellmanFordMinPath(DirectedWeightGraph g, int start) { // 所以 如果遍历所有的点 同时 relax 所有的 边 就可以得到一个结果 // 其效率为 o(v + e) // 但是 可以考虑一个问题 就是只有在上轮循环中更新过的点 才有可能使 距离更短，所以 用一个 queue 来保存这样的点 // 转上轮对 dst 数组有贡献的点 Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // 结果 Edge[] edgeTo = new Edge[g.getCapacity()]; // 距离初始化 int[] dst = new int[g.getCapacity()]; Arrays.fill(dst, Integer.MAX_VALUE); dst[start] = 0; // 因为 queue 里面不能有重复节点 所以用这个来判断 boolean[] inQueue = new boolean[g.getCapacity()]; // 执行 relax 的次数 int cost = 0; // 最开始的节点 queue.add(start); // TODO 这个时候还要检查负权重环 // 这个地方只需要检查是否是成环即可 while (!queue.isEmpty()) { relax(g, queue.remove(), dst, edgeTo, queue, inQueue); } return edgeTo;}// 在放松的时候同时更新 queueprivate static void relax(DirectedWeightGraph g, int node, int[] dst, Edge[] edgeTo, Queue&lt;Integer&gt; queue, boolean[] inQueue) { for (Edge adj : g.adj(node)) { int to = adj.to; // 更新 if (dst[to] &gt; dst[node] + adj.weight) { edgeTo[to] = adj; dst[to] = dst[node] + adj.weight; if (!inQueue[node]) { inQueue[node] = true; // 这有这轮已经更新过的 到 to 的更短距离 其他才可能更短 queue.add(to); } } // TODO 检查负权重环 }}","link":"/2021/03/07/graph/"},{"title":"leetcode","text":"leetcode 例题记录下 leetcode 值得记录的例题 kmp 算法kmp 算法的原始实现方法在另一篇里面已经写过，实际上 单调栈下一个更大元素 II 示例 输入: [1,2,1] 输出: [2,-1,2] 解释: 第一个 1 的下一个更大的数是 2； 数字 2 找不到下一个更大的数； 第二个 1 的下一个最大的数需要循环搜索，结果也是 2。 用单调栈来保存之前遍历过的路径，之后访问的数字如果比路径上的数字大的话，说明对于栈中保存的路径上的数字下一个更大的数是当前访问的数。 12345678910111213141516171819public int[] nextGreaterElements(int[] nums) { // 优化循环 int n = nums.length; int[] res = new int[n]; // 添加的默认值 Arrays.fill(res, -1); // 单调栈保存 nums 中的下标 Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); // 因为是循环数组 所以遍历到最后一个的时候 还要看其左侧的 // 所以相当于是两倍长度 for (int i = 0; i &lt; 2 * n - 1; i++) { // stack 里面放置的都是比 nums[i % n] 小的数 在其被弹出的时候 说明之后第一个比他大的数 就是访问的 nums[i % n] while (!stack.isEmpty() &amp;&amp; nums[i % n] &gt; nums[stack.peek()]) { res[stack.pop()] = nums[i % n]; } stack.push(i % n); } return res;} 滑动窗口最小覆盖子串滑动窗口 当前遍历的字符串没有包含所有字符的时候，右移右游标 然后左移左游标，直到不再包含该字符串 在移动窗口的时候不听比较即可 123456789101112131415161718192021222324252627282930313233func checkEqualMap(mapForT, window map[int32]int) bool { for k, v := range mapForT { if count, ok := window[k]; !ok || count &lt; v { return false } } return true}func minWindow(s string, t string) string { i, j := 0, 0 res := &quot;&quot; mapForT := make(map[int32]int) for _, char := range t { mapForT[char]++ } window := make(map[int32]int) for j &lt; len(s) || i &lt; j { for j &lt; len(s) &amp;&amp; !checkEqualMap(mapForT, window) { window[int32(s[j])]++ j++ } if checkEqualMap(mapForT, window) &amp;&amp; (res == &quot;&quot; || len(res) &gt; j-i) { res = s[i:j] } window[int32(s[i])]-- i++ } return res} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { // 返回true 说明里面已经包含了一个完整的 t 字符串 public boolean checkMap(HashMap&lt;Character, Integer&gt; mapForT, HashMap&lt;Character, Integer&gt; mapForS) { for (Character key : mapForT.keySet()) { if (!mapForS.containsKey(key) || mapForS.get(key) &lt; mapForT.get(key)) return false; } return true; } public String minWindow(String s, String t) { // 这都是不存在的 if (s == null || t == null || s.length() &lt; t.length()) return &quot;&quot;; String minStr = null; HashMap&lt;Character, Integer&gt; mapForT = new HashMap&lt;&gt;(); for (char character : t.toCharArray()) { if (!mapForT.containsKey(character)) { mapForT.put(character, 1); } else { mapForT.put(character, mapForT.get(character) + 1); } } HashMap&lt;Character, Integer&gt; mapForS = new HashMap&lt;&gt;(); for (int i = 0; i &lt; t.length(); i++) { Character character = s.charAt(i); if (!mapForS.containsKey(character)) { mapForS.put(character, 1); } else { mapForS.put(character, mapForS.get(character) + 1); } } // 滑动窗口大小 int left = 0, right = t.length() - 1; do { while (checkMap(mapForT, mapForS) &amp;&amp; right - left + 1 &gt;= t.length()) { if (minStr == null || minStr.length() &gt; right - left + 1) { minStr = s.substring(left, right + 1); } mapForS.put(s.charAt(left), mapForS.get(s.charAt(left)) - 1); left++; } right++; if (right &gt;= s.length()) continue; if (!mapForS.containsKey(s.charAt(right))) { mapForS.put(s.charAt(right), 1); } else { mapForS.put(s.charAt(right), mapForS.get(s.charAt(right)) + 1); } } while (right &lt;= s.length() - 1 &amp;&amp; right - left + 1 &gt; t.length()); return minStr == null ? &quot;&quot; : minStr; }} K 个不同整数的子数组找到 A 里面的连续子数组，其中子数组里面的数据的 distinct 只有 K 个 这个题目一想就是滑动窗口 但是 很不好计算 等于 K 的时候 数组有多少个 但是计算 小于等于 K 的比较好计算，可以依据以下规则 以 [1,2,1,2,3] 为例，左边界固定的时候，恰好存在 2 个不同整数的子区间为 [1,2],[1,2,1],[1,2,1,2]，总数为 3。其值为下标 3 - 1 + 1，即区间 [1..3] 的长度。 因为，left, right 同时圈定了一组满足 &lt;= k 的题意的长度范围 那么，包含 left 的子数组数量肯定是 right - left + 1，因为相当于每次给数组里面添加一个数([1,2] [1,2,1] [1,2,1,2]) 所以 right 比 left 多几个数 就能形成几个子数组 12345678910111213141516171819202122232425262728func subarraysWithKDistinct(A []int, K int) int { return atMostK(A, K) - atMostK(A, K-1)}// 因为求解 恰好K 不好弄 求解 最大K 比较好弄func atMostK(A []int, K int) int { i, j := 0, 0 // 作为一个 set 保存窗口内的所有 distinct 数据 window := make(map[int]int) res := 0 for j &lt; len(A) { window[A[j]]++ j++ for len(window) &gt; K { window[A[i]]-- if window[A[i]] == 0 { delete(window, A[i]) } i++ } res += j - i + 1 } return res} 最大连续 1 的个数 III最大连续 1 的个数，A 中只有 0 和 1，其中可以变换最多 K 个 0 成为 1，问最长的连续 1 的长度为多少 滑动窗口，窗口中最多含有 K 个 0 即可 123456789101112131415161718192021222324252627282930func longestOnes(A []int, K int) int { // 返回值 res := 0 left, right := 0, 0 zeros := 0 for right &lt; len(A) { // 用外层循环带动 right 移动 if A[right] == 0 { zeros++ } // 这个时候要移动左侧的 left 保障 zeros 小 for zeros &gt; K { if A[left] == 0 { zeros-- } left++ } // 每轮都去比较即可 res = max(res, right - left + 1) right++ } return res}func max(a, b int) int { if a &gt; b { return a } return b} 绝对差不超过限制的最长连续子数组 给定一个数组 nums 和 limit，找到最长的连续数组，其中任意两个数的差值不超过 limit 上面这句话换个说法说的就是 最大值和最小值 之差不超过 limit，因此如果能够 o(1) 的拿到窗口的 最大最小值，那么就比较方便 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package classictype MaxMinQueue struct { stack1 MaxMinStack stack2 MaxMinStack}func (queue *MaxMinQueue) Push(val int) { queue.stack1.Push(val)}func (queue *MaxMinQueue) Shift() int { if queue.stack2.Len() == 0 { for queue.stack1.Len() &gt; 0 { queue.stack2.Push(queue.stack1.Pop()) } } return queue.stack2.Pop()}func (queue *MaxMinQueue) Max() int { if queue.stack1.Len() == 0 { return queue.stack2.Max() } else if queue.stack2.Len() == 0 { return queue.stack1.Max() } return max(queue.stack2.Max(), queue.stack1.Max())}func (queue *MaxMinQueue) Min() int { if queue.stack1.Len() == 0 { return queue.stack2.Min() } else if queue.stack2.Len() == 0 { return queue.stack1.Min() } return min(queue.stack2.Min(), queue.stack1.Min())}func (queue *MaxMinQueue) Len() int { return queue.stack1.Len() + queue.stack2.Len()}type MaxMinStack struct { // 这两个不用 slice 用 list 之类的链表 可能会快一点儿 data []int maxes []int mins []int}func (ms *MaxMinStack) Push(val int) { ms.data = append(ms.data, val) if len(ms.maxes) &gt; 0 { ms.maxes = append(ms.maxes, max(ms.maxes[len(ms.maxes)-1], val)) } else { ms.maxes = append(ms.maxes, val) } if len(ms.mins) &gt; 0 { ms.mins = append(ms.mins, min(ms.mins[len(ms.mins)-1], val)) } else { ms.mins = append(ms.mins, val) }}func (ms *MaxMinStack) Pop() int { res := ms.data[len(ms.data)-1] ms.data = ms.data[:len(ms.data)-1] ms.maxes = ms.maxes[:len(ms.maxes)-1] ms.mins = ms.mins[:len(ms.mins)-1] return res}func (ms *MaxMinStack) Max() int { return ms.maxes[len(ms.maxes)-1]}func (ms *MaxMinStack) Min() int { return ms.mins[len(ms.mins)-1]}func (ms *MaxMinStack) Len() int { return len(ms.data)}// 找到一个最长的连续子数组 其任意两个元素之间的差值 小于等于 limitfunc longestSubarray(nums []int, limit int) int { // 就是维护一个 queue 为了方便 应该在 o(1) 的时间内获得其 最大最小值 left, right := 0, 0 window := &amp;MaxMinQueue{stack1: MaxMinStack{}, stack2: MaxMinStack{}} res := 0 for right &lt; len(nums) { window.Push(nums[right]) if window.Len() &gt; 0 &amp;&amp; window.Max() - window.Min() &lt;= limit { res = max(res, right - left + 1) } for window.Len() &gt; 0 &amp;&amp; window.Max() - window.Min() &gt; limit { window.Shift() left++ } right++ } return res} 爱生气的书店老板给定一个 grumpy 以及 custormers 在 grumpy == 0 的时候 可以加上 custormers 的对应值，问如果有连续的 X 个 gurmpy 可以为 0 最大 customers 的和为多少 自己的做法 维护一个前缀和数组 sum，表示前 i 个的和为多少，那么就可以用滑动窗口将数组分为三段 [0-&gt;l](可以用 sum 数组求得) [l-&gt;r](全部变为 0 所以是直接求和的) [r-&gt;len](可以用 sum 数组求得) 123456789101112131415161718192021222324public int maxSatisfiedWithSumArray(int[] customers, int[] grumpy, int X) { // sum[i] 保存 customers[i] 之前的所有满足要求的和 int[] sum = new int[customers.length + 1]; for (int i = 1; i &lt;= customers.length; i++) { sum[i] = sum[i - 1]; if (grumpy[i - 1] == 0) { sum[i] += customers[i - 1]; } } // 结果 int res = 0; // 维护一个窗口 这个窗口长度为 X 全部认为是可以加的 int windowSum = 0; for (int i = 0; i &lt; X; i++) { windowSum += customers[i]; } for (int i = X; i &lt; customers.length; i++) { res = Math.max(res, sum[i-X] + windowSum + sum[customers.length] - sum[i]); windowSum = windowSum - customers[i - X] + customers[i]; } res = Math.max(res, sum[customers.length-X] + windowSum); return res;} 题解 题解更进一步，将 customers 数组根据 grumpy 的取值分为两类，一类是 grumpy 等于 1 那么是可以直接加上的，一类是 grumpy == 0，可以在长度为 X 的滑动窗口中 increase 到 第一类的 123456789101112131415161718192021public int maxSatisfied(int[] customers, int[] grumpy, int X) { // 分两步计算 一个计算满足要求的所有和 total 另一个窗口可以额外增加的值 int total = 0; for (int i = 0; i &lt; customers.length; i++) { // grumpy[i] == 0 的时候 才加上 total += (1 - grumpy[i]) * customers[i]; } // 遍历可以增加的值 找到最大的 int window = 0; // 窗口遍历可以增加的值 for (int i = 0; i &lt; X; i++) { // 窗口可以增加的值 是 grumpy[i] == 1 window += grumpy[i] * customers[i]; } int res = window; for (int i = X; i &lt; customers.length; i++) { window = window - grumpy[i-X] * customers[i-X] + grumpy[i] * customers[i]; res = Math.max(res, window); } return total + res;} 二进制题目模拟除法(https://leetcode-cn.com/problems/divide-two-integers/)不能使用乘法、除法和 mod 运算符。 除法的本质，以 10 / 3 为例 10 / 3 = 3 …… 1 (即为 3 个 3 相乘 余 1) 即为 10 - (3 _ 2) - (3 _ 1) = 1 其结果为 2 + 1 为 3 也就是说任意一种除法可以用一组除数的 2 的次方的乘积的结果来表示。 如 100 / 15 = 6 100 - (15 _ 4) - (15 _ 2) 所以可以采用二进制的方法来做，每次用被除数减去最大的一个除数的 2 次方的乘积，循环，直到剩下余数或者 0 123456789101112131415161718192021222324252627func divide(dividend int, divisor int) int { if divisor == 0 { return 1 &lt;&lt; 31 - 1 } minus := -1 if (dividend &lt; 0 &amp;&amp; divisor &lt; 0) || (dividend &gt; 0 &amp;&amp; divisor &gt; 0) { minus = 1 } absDividend, absDivisor := int64(math.Abs(float64(dividend))), int64(math.Abs(float64(divisor))) res := 0 for absDividend &gt;= absDivisor { tmp, multi := absDivisor, 1 for (tmp &lt;&lt; 1) &lt; absDividend { tmp &lt;&lt;= 1 multi &lt;&lt;= 1 } absDividend -= tmp res += multi if minus &gt; 0 &amp;&amp; res &gt;= math.MaxInt32 { return math.MaxInt32 } else if minus &lt; 0 &amp;&amp; minus * res &lt;= math.MinInt32 { return math.MinInt32 } } return minus * res} 123456789101112131415161718192021222324252627class Solution { public int divide(int dividend, int divisor) { if(divisor == 0 || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1)) return Integer.MAX_VALUE; int sign; if ((dividend &gt; 0 &amp;&amp; divisor &gt; 0) || (dividend &lt; 0 &amp;&amp; divisor &lt; 0)) sign = 1; else sign = -1; int res = 0; long dvd=Math.abs((long)dividend); long dvs=Math.abs((long)divisor); while (dvd &gt;= dvs) { long temp = dvs, m = 1; while (temp &lt;&lt; 1 &lt; dvd) { temp &lt;&lt;= 1; m &lt;&lt;= 1; } res += m; dvd -= temp; } return sign * res; }} 只出现一次的数字 II数组中的数组只有出现 1 次（一个数字）的和 3 次的数字，找到只出现一次的那个数字 其实就是计算每一位数字出现的次数 % 3 注意 goland 默认的 int 可能值得是 int64 所以强制指定为 32 为长度的 int32 不然没办法处理负数的情况 123456789101112func singleNumber(nums []int) int { var res int32 for i := 0; i &lt; 32; i++ { var count int32 for _, num := range nums { count += (int32(num )&gt;&gt; i) &amp; 1 } res += (count % 3) &lt;&lt; i } return int(res)} 只出现一次的数字 III一组数字 其中只有两个数字 出现一次 其余出现两次 12345678910111213141516171819202122232425262728func singleNumberIII(nums []int) []int { // 如果两个出现一次的数 不同 肯定不为 0 sum := 0 for _, num := range nums { sum ^= num } // 那么根据 sum 的某一个不为 0 的位数来分离两类数 counter := 1 for sum &amp; 1 == 0 { sum &gt;&gt;= 1 counter &lt;&lt;= 1 } // 找到了这个位数 根据 位数 分成两组即可 num1, num2 := 0, 0 for _, num := range nums { // 根据位数分离两类数 if num &amp; counter == 0 { num1 ^= num } else { num2 ^= num } } return []int{num1, num2}} 数字按位与要求求 m -&gt; n 的范围内的所有数字的 按位与 的结果，因为范围比较大，直接 &amp; 会超时 考虑 3 -&gt; 11 这个范围的数字，红色的 就是相同的二进制前缀部分 实际上就是找到这部分前缀 001011 11 001010 10 001001 09 001000 08 000111 07 000110 06 000101 05 000100 04 000011 03 123456789101112131415func rangeBitwiseAnd(m int, n int) int { if m == n { return m } // 考虑 [5,6,7] 三个数 &amp; 起来的话 实际上是 考虑 最大值 和 最小值的 左侧相等的部分是多少 // mov 记录移位了多少次 然后再移动回来 mov := 0 for m != n { m &gt;&gt;= 1 n &gt;&gt;= 1 mov++ } return m &lt;&lt; mov} 动态规划最后一块石头的重量 II其实就是问是否能够形成相等的两部分, 用一个 dp[i][j] 表示前 i 个的能否形成和为 j 的数值，在遍历的时候就可以找到最大的和为多少，之后就减去最大的和即可 1234567891011121314151617181920212223242526272829303132333435package classic// 这道题题干 要求 stones 两两相撞 剩下一块儿 为剩下的石头 最小能形成的重量// 其实就是问是否能够形成相等的两部分 因为相等的话 最后形成的石头 为 0func lastStoneWeightII(stones []int) int { sum := getStonesSum(stones) // dp[i][j] 表示前 i 个能否形成 何为 j dp := make([][]bool, len(stones)+1) for i := 0; i &lt; len(dp); i++ { dp[i] = make([]bool, sum/2+1) // 合为0一定可以 dp[i][0] = true } maxSum := 0 for i := 1; i &lt;= len(stones); i++ { for j := 1; j &lt;= sum/2; j++ { // 因为表示的前 i 能不能形成 j 所以 i-1 能形成的话 也是可以的 dp[i][j] = dp[i][j] || dp[i-1][j] if j &gt;= stones[i-1] { dp[i][j] = dp[i][j] || dp[i-1][j-stones[i-1]] } if dp[i][j] { maxSum = max(maxSum, j) } } } return sum - 2 * maxSum}func getStonesSum(stones []int) (sum int) { for _, w := range stones { sum += w } return} 最长子序列套题最长上升子序列找到非连续的递增子序列，那么我就只需要知道 在我之前的小于我的数字的上升子序列长度为多少 即实际上只需要在访问数组的时候 0 ≤ i &lt; j &lt; nums.length，只需要知道 i 下标对应的最长的子序列是多少即可。 这样就变成了一个 dp 问题，小问题就是解决的以 nums[i] 结尾的最长的上升子序列的长度 123456789101112131415161718func lengthOfLIS(nums []int) int { // dp[i] 表示 nums[i] 结尾的最长的递增子序列长度为多少 dp := make([]int, len(nums)) // 初始化 一个数字肯定是递增的 for i := 0; i &lt; len(nums); i++ { dp[i] = 1 } res := 0 for i, num := range nums { for j := 0; j &lt; i; j++ { if num &gt; nums[j] { dp[i] = max(dp[i], dp[j]+1) } } res = max(res, dp[i]) } return res} 最长上升子序列数量与上面那个类似 也是一个 dp 问题 只是需要在 dp 遍历的时候 知道 对应最长长度 对应的 LIS 有多少个 1234567891011121314151617181920212223242526272829303132333435363738// 找到 LIS 对应的长度的子序列有多少个func findNumberOfLIS(nums []int) int { // 保存 nums[i] 结尾的 LIS 的长度 dp := make([]int, len(nums)) // 保存 nums[i] 结尾的 LIS 的最长 LIS 的长度 counts := make([]int, len(nums)) // 初始化 for i := 0; i &lt; len(dp); i++ { dp[i] = 1 counts[i] = 1 } maxLen := 0 for i := 0; i &lt; len(nums); i++ { for j := 0; j &lt; i; j++ { // 形成 递增 if nums[j] &lt; nums[i] { if dp[i] &lt;= dp[j] { // 说明 j 的长度比这个长 dp[i] = dp[j] + 1 counts[i] = counts[j] } else if dp[j]+1 == dp[i] { // 长度相差 1 说明这个时候 counts 要 + 上 j 的 counts[i] += counts[j] } } } maxLen = max(maxLen, dp[i]) } res := 0 for i, count := range counts { if maxLen == dp[i] { res += count } } return res} 摆动序列找到摆动序列（摆动序列是一升一降的序列，即前后相减为一正一负）参考注释即可 (这个题目不要求连续 所以还需要不停的保存前一个状态 不用初始化) 1234567891011121314151617181920212223242526272829// 两个数组分别代表上升和下降序列的最大长度// 因为 wiggle 的数组 是一升一降 的 up[i] 表示 最后一个 nums[i] 是上升的趋势的最大值func wiggleMaxLengthWithoutMemo(nums []int) int { if len(nums) == 0 { return 0 } // up[i] down[i] 分别代表上升和下降序列(最后一个是上升或者下降)的 在 index = i 时的最长长度 ups, downs := make([]int, len(nums)), make([]int, len(nums)) // 初始化 ups[0] = 1 downs[0] = 1 for i := 1; i &lt; len(nums); i++ { if nums[i] &gt; nums[i-1] { // 如果 nums i 是上升趋势 说明那么 之前前一个是下降的趋势的话 可以 加一 // 同时 也可以不考虑这个 上升趋势 跟前一个比较 ups[i] = max(downs[i-1]+1, ups[i-1]) // 此时由于是上升的 所以没有下降的趋势 状态直接转移 downs[i] = downs[i-1] } else if nums[i] &lt; nums[i-1] { downs[i] = max(ups[i-1]+1, downs[i-1]) ups[i] = ups[i-1] } else { // 相等的情况下是不变的 ups[i] = ups[i-1] downs[i] = downs[i-1] } } return max(ups[len(ups)-1], downs[len(downs)-1])} 因为只依赖前一个状态 因此可以压缩状态 1234567891011121314151617181920212223// 两个数组分别代表上升和下降序列的最大长度// 因为 wiggle 的数组 是一升一降 的 up[i] 表示 最后一个 nums[i] 是上升的趋势的最大值func wiggleMaxLength(nums []int) int { if len(nums) == 0 { return 0 } up, down := 1, 1 for i := 1; i &lt; len(nums); i++ { preDown, PreUp := down, up if nums[i] &gt; nums[i-1] { up = max(down+1, up) down = preDown } else if nums[i] &lt; nums[i-1] { down = max(up+1, down) up = PreUp } else { up = PreUp down = preDown } } return max(up, down)} 类似摆动序列的题目 978. 最长湍流子数组找到一个连续的子数组能够满足 当 A 的子数组 A[i], A[i+1], …, A[j] 满足下列条件时，我们称其为湍流子数组： 若 i &lt;= k &lt; j，当 k 为奇数时， A[k] &gt; A[k+1]，且当 k 为偶数时，A[k] &lt; A[k+1]；或 若 i &lt;= k &lt; j，当 k 为偶数时，A[k] &gt; A[k+1] ，且当 k 为奇数时， A[k] &lt; A[k+1]。也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。 123456789101112131415161718192021222324252627282930func maxTurbulenceSize(arr []int) int { // 仍然是一升一降 才能使符号反号 up, down := 1, 1 res := 1 for i := 1; i &lt; len(arr); i++ { if arr[i] &gt; arr[i-1] { up = down+1 // 因为是要连续的 一升一降 所以这个地方需要重新初始化为 1 down = 1 } else if arr[i] &lt; arr[i-1] { down = up + 1 up = 1 } else { up, down = 1, 1 } // 因为重新初始化 所以需要对每一个状态进行比较保存 res = max(res, max(up, down)) } return res}func max(a, b int) int { if a &gt; b { return a } return b} 俄罗斯套娃信封问题根据信封的宽度和高度 判断能够装下的信封的最大长度有多少 高度和宽度均小于另外一个信封的 可以装进去 实际上是一个 找到最长递增序列的问题 按照宽度进行排序，这样从一个维度上看 所有的信封都是宽度有序的 再次基础上 如果要前一个信封能够装在后一个信封里面 说明长度是一个逆序的 最后只需要在这个排序的数组里面 找到长度的一个最长递增序列即可 123456789101112131415161718192021222324252627282930313233343536373839func maxEnvelopes(envelopes [][]int) int { // envelopes[0] 相等 说明宽度相等 这个时候 只需要更长的排在后面即可 // envelopes[0] 不等 说明宽度不等 这个时候 只需要只需要根据长度大小从大到小排序即可 sort.Slice(envelopes, func(i, j int) bool { if envelopes[i][0] == envelopes[j][0] { return envelopes[i][1] &gt; envelopes[j][1] } else { return envelopes[i][0] &lt; envelopes[j][0] } }) // 因为现在这样排序之后 信封的宽度 一定是满足顺序的 那么只需要判断长度 能够形成的最长的递增子序列是多长 dp := make([]int, len(envelopes)) // 1 个数字也能有一个长度 for i := 0; i &lt; len(dp); i++ { dp[i] = 1 } res := 0 for i := 0; i &lt; len(dp); i++ { tmp := 0 for j := 0; j &lt; i; j++ { if envelopes[i][1] &gt; envelopes[j][1] { tmp = max(tmp, dp[j]) } } dp[i] = tmp + 1 res = max(res, dp[i]) } return res}func max(a, b int) int { if a &gt; b { return a } return b} 解码方法这道题是入门的动态规划 只要知道 前一个和前前个的状态，就可以转移到下一个状态 12345678910111213141516171819202122232425262728293031323334353637func numDecodings(s string) int { if len(s) == 0 { return 0 } // dp[i] 表示 s[0:i] 不包括i能生成的数量 // dp[i] = dp[i-1]+dp[i-2] // 因为只要当前的这个 sting 能够被 decoding 说明只要加上前面的数量即可 dp := make([]int, len(s) + 1) dp[0] = 1 // 表示的每次遍历的string的尾部 for i := 1; i &lt;= len(s); i++ { for j := max(i - 2, 0); j &lt; i; j++ { if canDecoding(s[j:i]) { dp[i] += dp[j] } } } return dp[len(s)]}func canDecoding(s string) bool { if len(s) &gt; 1 &amp;&amp; s[0] == '0' { return false } if num, err := strconv.Atoi(s); err != nil || num &gt; 26 || num &lt; 1 { return false } return true}func max(a, b int) int { if a &gt; b { return a } return b} 子序列不同的子序列1234567891011121314151617181920212223242526func numDistinct(s string, t string) int { // dp[i][j] 表示 s[i-1] 和 t[j-1] 之间有多少组合 dp := make([][]int, len(s)+1) for i := 0; i &lt;= len(s); i++ { dp[i] = make([]int, len(t)+1) } // 初始化 只要 t 是空 那么一定可以 在 s 中找到 for i := 0; i &lt;= len(s); i++ { dp[i][0] = 1 } for i := 1; i &lt;= len(s); i++ { for j := 1; j &lt;= len(t); j++ { if s[i-1] == t[j-1] { // 分为两个部分 因为可以不算当前的 s 串的最后一个 也可以算上 // 因为 s 串的前面部分 可能已经匹配到了 dp[i][j] = dp[i-1][j-1] + dp[i-1][j] } else { dp[i][j] = dp[i-1][j] } } } return dp[len(s)][len(t)]} 打家劫舍系列题打家劫舍 I这道题是经典的 dp 问题。题目要求的是不能抢劫相邻的位置，那么这种条件下的最大和是多少。 一个位置会有两个状态，拿当前这个地方的值 或者 不拿 下个位置的状态就会由上一个位置决定 如果当前位置拿了值的话，上一个位置只能不拿 如果当前位置没有拿，上一个位置只需要取拿 or 不拿的 较大值 优化下 dp 数组 其实可以用一对值表示前面一个循环中拿了的最大值即可 12345678910111213141516func rob(nums []int) int { if len(nums) &lt;= 0 { return 0 } // 优化的目的在于去掉数组 因为现在直接最大的就是 notRob, rob := 0, 0 res := 0 for _, num := range nums { rm := rob rob = notRob + num notRob = max(notRob, rm) res = max(notRob, rob) } return res} 打家劫舍 II这个是打劫的循环数组，因为 rob 了第一个 就不能 rob 最后一个 所以分别访问从 [1:len(nums)] 和 [0:len(nums)-1] 然后比较大小即可 1234567891011121314151617181920212223242526272829303132func rob(nums []int) int { if len(nums) &lt;= 0 { return 0 } if len(nums) == 1 { return nums[0] } // 因为是首尾相连的 robFirst := getMaxRob(nums[:len(nums)-1]) notRobFirst := getMaxRob(nums[1:]) return max(robFirst, notRobFirst)}func getMaxRob(nums []int) int { notRob, rob := 0, 0 res := 0 for _, num := range nums { rem := rob rob = notRob + num notRob = max(rem, notRob) res = max(res, max(rob, notRob)) } return res}func max(a, b int) int { if a &gt; b { return a } return b} 打家劫舍 III这次是树，实际上还是要知道子节点上的话 rob 和 notRob 的状态即可，然后递推到当前的状态 1234567891011121314151617181920212223242526272829303132333435363738394041func rob(root *TreeNode) int { var res int recursionRobTree(root, &amp;res) return res}// recursionRobTree 返回值是 rob 当前这个 root 还不 不 rob 的值func recursionRobTree(root *TreeNode, res *int) (int, int) { if root == nil { return 0, 0 } leftRob, leftNotRob := recursionRobTree(root.Left, res) rightRob, rightNotRob := recursionRobTree(root.Right, res) // 如果 rob 当前这个root 节点的话 意味着 两个节点都不可以rob rob := leftNotRob + rightNotRob + root.Val // 如果 不 rob 这个节点的话 子节点可以 rob 也可以不 rob notRob := getArrayMax(leftRob + rightRob, rightRob + leftNotRob, rightNotRob + leftRob, rightNotRob + leftNotRob) *res = max(*res, rob) *res = max(*res, notRob) return rob, notRob}func getArrayMax(nums ...int) int { if len(nums) == 0 { return -1 } res := nums[0] for _, num := range nums { res = max(res, num) } return res}func max(a, b int) int { if a &gt; b { return a } return b} 贪心算法转换罗马字12345678910111213141516171819202122232425262728293031323334353637383940package classicimport ( &quot;strings&quot;)var ( memo = make(map[int]string) keys []int)func init() { memo[1] = &quot;I&quot; memo[4] = &quot;IV&quot; memo[5] = &quot;V&quot; memo[9] = &quot;IX&quot; memo[10] = &quot;X&quot; memo[40] = &quot;XL&quot; memo[50] = &quot;L&quot; memo[90] = &quot;XC&quot; memo[100] = &quot;C&quot; memo[400] = &quot;CD&quot; memo[500] = &quot;D&quot; memo[900] = &quot;CM&quot; memo[1000] = &quot;M&quot; keys = []int{1000,900,500,400,100,90,50,40,10,9,5,4,1}}func intToRoman(num int) string { res := strings.Builder{} for _, key := range keys { for num &gt;= key { res.WriteString(memo[key]) num -= key } } return res.String()} jumpGame12345678910111213141516func canJump(nums []int) bool { rightMost := 0 for i, num := range nums { // 如果当前的下标大于 rightMost 说明这个点是无法到达的 直接返回 false 即可 if i &gt; rightMost { return false } // 维护一个能够到达的最远距离 rightMost = max(rightMost, i + num) // 最远距离大于长度 即可知道能够达到 if rightMost &gt;= len(nums) - 1 { return true } } return false} 递归括号生成1234567891011121314151617181920212223// generateParenthesis 入口函数func generateParenthesis(n int) []string { res := make([]string, 0) recursionGenerate(&amp;res, &quot;&quot;, n, n) return res}// 递归生成func recursionGenerate(res *[]string, tmp string, left, right int) { if left == 0 &amp;&amp; right == 0 { *res = append(*res, tmp) return } // 由于左括号可以直接放到结果上，因此左括号不用判断其他的 if left &gt; 0 { recursionGenerate(res, tmp+&quot;(&quot;, left-1, right) } // 而有括号需要跟左括号匹配，所以有括号遍历的时候 必须已经有左括号被放到了结果中 // 所以需要判断一下 right &gt; left if right &gt; left { recursionGenerate(res, tmp+&quot;)&quot;, left, right-1) }} 12345678910111213141516171819public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); recursion(res, n, n, &quot;&quot;); return res;}public void recursion(List&lt;String&gt; res, int left, int right, String tmp) { if (left == 0 &amp;&amp; right == 0) { res.add(tmp); return; } if (left &gt; 0) { recursion(res, left - 1, right, tmp + &quot;(&quot;); } if (right &gt; left) { recursion(res, left, right - 1, tmp + &quot;)&quot;); }} 正则表达式匹配这道题可以用递归的思想去做，也可以采用 dp 的方法。实际上递归就是从上向下的 dp 12345678910111213141516171819202122232425262728293031func isMatch(s string, p string) bool { return recursionIsMatch(s, p, 0, 0)}func recursionIsMatch(s, p string, sIndex, pIndex int) bool { // 完全匹配 if sIndex == len(s) &amp;&amp; pIndex == len(p) { return true } // 越界 pattern 匹配完了一定有问题 if pIndex == len(p) &amp;&amp; sIndex != len(s) { return false } if pIndex &lt; len(p)-1 &amp;&amp; p[pIndex+1] == '*' { // 匹配 if pIndex &lt; len(p) &amp;&amp; sIndex &lt; len(s) &amp;&amp; (p[pIndex] == s[sIndex] || p[pIndex] == '.') { return recursionIsMatch(s, p, sIndex, pIndex+2) || // 匹配0次 因为 * 代表 0 -&gt; 多次 recursionIsMatch(s, p, sIndex+1, pIndex+2) || // 匹配1次 recursionIsMatch(s, p, sIndex+1, pIndex) // 匹配多次 } else { // 如果不匹配 则跳过 return recursionIsMatch(s, p, sIndex, pIndex+2) } } // 现在的字符是匹配的 if pIndex &lt; len(p) &amp;&amp; sIndex &lt; len(s) &amp;&amp; (p[pIndex] == s[sIndex] || p[pIndex] == '.') { return recursionIsMatch(s, p, sIndex+1, pIndex+1) } return false} 123456789101112131415161718192021222324252627public boolean isMatch(String s, String p) { return recursion(s, p, 0, 0);}public boolean recursion(String s, String p, int sIndex, int pIndex) { if (pIndex == p.length() &amp;&amp; sIndex != s.length()) { return false; } if (sIndex == s.length() &amp;&amp; pIndex == p.length()) { return true; } if (pIndex &lt; p.length() - 1 &amp;&amp; p.charAt(pIndex + 1) == '*') { if (sIndex &lt; s.length() &amp;&amp; (p.charAt(pIndex) == '.' || p.charAt(pIndex) == s.charAt(sIndex))) { return recursion(s, p, sIndex, pIndex + 2) || // 匹配0次 recursion(s, p, sIndex + 1, pIndex + 2) || // 匹配1次 recursion(s, p, sIndex + 1, pIndex); // 匹配多次 } else { return recursion(s, p, sIndex, pIndex + 2); } } if (sIndex &lt; s.length() &amp;&amp; pIndex &lt; p.length() &amp;&amp; (p.charAt(pIndex) == '.' || p.charAt(pIndex) == s.charAt(sIndex))) { return recursion(s, p, sIndex + 1, pIndex + 1); } return false;} 数据结构栈和队列队列-滑动窗口的最大值最大 queue 的队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960type MaxQueue struct { stack1 MaxStack stack2 MaxStack}func (queue *MaxQueue) Push(val int) { queue.stack1.Push(val)}func (queue *MaxQueue) shift() int { if queue.stack2.Len() == 0 { for queue.stack1.Len() &gt; 0 { queue.stack2.Push(queue.stack1.Pop()) } } return queue.stack2.Pop()}func (queue *MaxQueue) Max() int { if queue.stack1.Len() == 0 { return queue.stack2.Max() } else if queue.stack2.Len() == 0 { return queue.stack1.Max() } return max(queue.stack2.Max(), queue.stack1.Max())}func (queue *MaxQueue) Len() int { return queue.stack1.Len() + queue.stack2.Len()}type MaxStack struct { // 这两个不用 slice 用 list 之类的链表 可能会快一点儿 data []int maxes []int}func (ms *MaxStack) Push(val int) { ms.data = append(ms.data, val) if len(ms.maxes) &gt; 0 { ms.maxes = append(ms.maxes, max(ms.maxes[len(ms.maxes)-1], val)) } else { ms.maxes = append(ms.maxes, val) }}func (ms *MaxStack) Pop() int { res := ms.data[len(ms.data)-1] ms.data = ms.data[:len(ms.data)-1] ms.maxes = ms.maxes[:len(ms.maxes)-1] return res}func (ms *MaxStack) Max() int { return ms.maxes[len(ms.maxes)-1]}func (ms *MaxStack) Len() int { return len(ms.data)} 使用代码 123456789101112131415161718func maxSlidingWindow(nums []int, k int) []int { queue := MaxQueue{ stack1: MaxStack{}, stack2: MaxStack{}, } for i := 0; i &lt; k; i++ { queue.Push(nums[i]) } res := make([]int, 0) for i := k; i &lt; len(nums); i++ { res = append(res, queue.Max()) queue.shift() queue.Push(nums[i]) } res = append(res, queue.Max()) return res} 栈-计算器中值表达式转波兰表达式（实际上是） 链表删除倒数的第 N 个节点1234567891011121314151617181920212223func removeNthFromEnd(head *ListNode, n int) *ListNode { // 因为可能删除头结点 所有加了一个 newHead := new(ListNode) newHead.Next = head // fast 是先走的一个节点 pre 是后走的 pre, fast := newHead, head for n &gt; 0 { // 有问题 数量不够 if fast == nil { return nil } fast = fast.Next n-- } // 两个指针开始走 for fast != nil { fast = fast.Next pre = pre.Next } pre.Next = pre.Next.Next return newHead.Next} 合并 k 个已经排序的链表类似归并排序 1234567891011121314151617181920212223242526272829303132333435363738394041package classic// mergeKLists 合并k个已经按照升序排列的数组func mergeKLists(lists []*ListNode) *ListNode { return merge(lists,0, len(lists) - 1)}func merge(lists []*ListNode, start, end int) *ListNode { if start &gt; end { return nil } if start == end { return lists[start] } mid := (start + end) / 2 left, right := merge(lists, start, mid), merge(lists, mid + 1, end) return mergeTwoList(left, right)}func mergeTwoList(list1 *ListNode, list2 *ListNode) *ListNode { res := new(ListNode) rem := res for list1 != nil &amp;&amp; list2 != nil { if list1.Val &gt; list2.Val { res.Next = list2 list2 = list2.Next } else { res.Next = list1 list1 = list1.Next } res = res.Next } if list1 != nil { res.Next = list1 } if list2 != nil { res.Next = list2 } return rem.Next} 翻转链表一系列反转链表最简单的反转链表的思路肯定是直接用一个 stack，FILO 的机制来反转，而不采用额外的空间可以用一下的方法 12345678910111213141516func reverseList(head *ListNode) *ListNode { // 反转后的头节点 var pre *ListNode = nil for head != nil { // 用一个 局部变量 来保存下一个节点 next := head.Next // 反转当前遍历的 head 节点，指向已经反转完毕的头结点 head.Next = pre pre = head // 重新设置 head 头 head = next } return pre} 反转链表 II反转链表 II 是反转链表下表从 m -&gt; n 的一个链表，实际上采用上述的反转的操作，即可反转 m -&gt; n 之间的节点 1234567891011121314151617181920212223242526272829303132333435363738// 主函数func reverseBetween(head *ListNode, m int, n int) *ListNode { // 添加一个新的头结点，保障原来的头结点被反转时的结果 newHead := new(ListNode) newHead.Next = head cp := newHead // 分别保存需要反转的节点之前的一个节点以及最后需要反转的一个节点 var preStartNode, endNode *ListNode = nil, nil for i := 0; cp != nil; cp, i = cp.Next, i + 1 { if i == m - 1 { preStartNode = cp } if i == n { endNode = cp } } // 保存反转完毕后的链表需要连接到的下一个节点 afterEndNode := endNode.Next reverseHead, reverseEnd := reverseBetweenNodes(preStartNode.Next, afterEndNode) preStartNode.Next = reverseHead reverseEnd.Next = afterEndNode return newHead.Next}// reverseBetweenNodes reverse两个node之间的链表// 其中 startNode 为开始翻转的节点 endNodeNext 为结束翻转的节点的后一个节点func reverseBetweenNodes(startNode, endNodeNext *ListNode) (*ListNode, *ListNode) { var newHead *ListNode = nil newEndNode := startNode for startNode != endNode { next := startNode.Next startNode.Next = newHead newHead = startNode startNode = next } return newHead, newEndNode} reverse K groupreverse K group 的更进一步，在上面一题的基础上，每 K 个节点反转一次 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// reverseKGroup k个一组翻转func reverseKGroup(head *ListNode, k int) *ListNode { newHead := new(ListNode) newHead.Next = head var preStartNode, endNode *ListNode = newHead, nil counter := 0 mov := newHead for mov != nil { if counter == k { endNode = mov afterEnd := endNode.Next // 调用二题中所述的函数进行反转 reverseHead, reverseEnd := reverseBetweenNodes(preStartNode.Next, endNode.Next) preStartNode.Next = reverseHead reverseEnd.Next = afterEnd // 因为反转之后要重新记录 preStartNode counter = 0 // 反转之后的需要再次反转的头是上次反转的尾结点 preStartNode = reverseEnd // 重新定位移标 mov = reverseEnd } mov = mov.Next counter++ } return newHead.Next}// reverseBetweenNodes reverse两个node之间的链表// 其中 startNode 为开始翻转的节点 endNodeNext 为结束翻转的节点的后一个节点func reverseBetweenNodes(startNode, endNodeNext *ListNode) (*ListNode, *ListNode) { var newHead *ListNode = nil newEndNode := startNode for startNode != endNodeNext { next := startNode.Next startNode.Next = newHead newHead = startNode startNode = next } return newHead, newEndNode} 树树的遍历中序遍历123456789101112131415161718func inorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := list.New() for root != nil || stack.Len() != 0 { for root != nil { stack.PushBack(root) root = root.Left } if stack.Len() &gt; 0 { root = stack.Remove(stack.Back()).(*TreeNode) res = append(res, root.Val) root = root.Right } } return res} 前序遍历12345678910111213141516171819202122package classicimport &quot;container/list&quot;func preorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := list.New() for root != nil || stack.Len() &gt; 0 { for root != nil { res = append(res, root.Val) stack.PushBack(root) root = root.Left } if stack.Len() &gt; 0 { root = stack.Remove(stack.Back()).(*TreeNode) root = root.Right } } return res} 后序遍历12345678910111213141516171819202122232425262728293031func postorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := list.New() // 标识这个node是不是第二次访问 stackForFlag := list.New() for root != nil || stack.Len() &gt; 0 { for root != nil { stack.PushBack(root) stackForFlag.PushBack(false) root = root.Left } if stack.Len() &gt; 0 { root = stack.Remove(stack.Back()).(*TreeNode) flag := stackForFlag.Remove(stackForFlag.Back()).(bool) // 说明是第二次访问 这个时候要访问父亲节点 if flag { res = append(res, root.Val) root = nil } else { // 第一次访问 stack.PushBack(root) stackForFlag.PushBack(true) root = root.Right } } } return res} 层次遍历 普通层次遍历 123456789101112131415161718192021222324252627282930313233func levelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } tmp := make([]int, 0) queue := list.New() queue.PushBack(root) queue.PushBack(nil) for queue.Len() &gt; 0 { node := queue.Remove(queue.Front()) if node == nil { cp := make([]int, len(tmp)) copy(cp, tmp) res = append(res, cp) if queue.Len() == 0 { break } queue.PushBack(nil) tmp = make([]int, 0) continue } top := node.(*TreeNode) if top.Left != nil { queue.PushBack(top.Left) } if top.Right != nil { queue.PushBack(top.Right) } tmp = append(tmp, top.Val) } return res} zigzag 的层次遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package classicimport &quot;container/list&quot;func zigzagLevelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } isLeft := true tmp := make([]int, 0) queue := list.New() queue.PushBack(root) queue.PushBack(nil) for queue.Len() &gt; 0 { top := queue.Remove(queue.Front()) if top == nil { cp := make([]int, len(tmp)) copy(cp, tmp) res = append(res, cp) if queue.Len() == 0 { break } isLeft = !isLeft tmp = make([]int, 0) queue.PushBack(nil) continue } node := top.(*TreeNode) if node.Left != nil { queue.PushBack(node.Left) } if node.Right != nil { queue.PushBack(node.Right) } // 这个地方可以这样加入 就不用再 top == nil 中重新反转数组 if isLeft { tmp = append(tmp, node.Val) } else { tmp = append([]int{node.Val}, tmp...) } } return res} 前缀树实现用字符串的前缀来索引的结构树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Trie 之间通过 字符 关联 上一个 trie 会通过字符作为边连接下一个节点type Trie struct { data []*Trie // 存储索引结构的数 因为只包含 a-z 的字母 索引直接数组即可 不然用 map 会更好 isEnd bool // 是否结束节点}/** Initialize your data structure here. */func Constructor() Trie { return Trie{ data: make([]*Trie, 26), isEnd: false, }}/** Inserts a word into the trie. */func (this *Trie) Insert(word string) { tmp := this for _, char := range word { if tmp.data[char-'a'] == nil { tmp.data[char-'a'] = &amp;Trie{ data: make([]*Trie, 26), isEnd: false, } } tmp = tmp.data[char-'a'] } tmp.isEnd = true}/** Returns if the word is in the trie. */func (this *Trie) Search(word string) bool { tmp := this for _, char := range word { if tmp.data[char-'a'] == nil { return false } tmp = tmp.data[char-'a'] } return tmp.isEnd}/** Returns if there is any word in the trie that starts with the given prefix. */func (this *Trie) StartsWith(prefix string) bool { tmp := this for _, char := range prefix { if tmp.data[char-'a'] == nil { return false } tmp = tmp.data[char-'a'] } return true} 图并查集的数据结构并查集，表示的是一个树形的结构 如图所示，针对图的一个极大连通分量，会形成一个对应的树结构（并查集只关注一个连通分量有多少连接点，不关注内部的其他的细节） 所以针对查找连通分量有哪些，以及连同量间的关系有作用 并查集存储数据的结构123type Union struct { parents []int // 存储树的数据结构 parents[i] 表示连接到该节点的父节点的索引 如果不能用 int 来表示 可以考虑 map 类的数据结构} 并查集的操作 union (联合，关联两个点) find (查找，找到当前点的最终的父节点) 所以，实际上 如果 r1 r2 之间有连接线的话，要关联 r1 r2 的操作就是。 就是通过 find 找到分别的根节点 r1Root r2Root 在通过 union 方法关联两个根节点，实际上就是将 r2Root 作为一个子节点，挂载到 r1Root 下 所以整体的数据结构为 12345678910111213141516171819202122232425262728293031323334353637type unionFind struct { Parents []int Count int // 表示连通分量的多少}func NewUnionFind(size int) *unionFind { res := &amp;unionFind{ Parents: make([]int, size), Count: size, } // 初始化并查集中的每个元素的父节点都是自己 for i := 0; i &lt; size; i++ { res.Parents[i] = i } return res}func (u *unionFind) union(i, j int) { iRoot := u.find(i) jRoot := u.find(j) if iRoot != jRoot { u.Parents[jRoot] = iRoot // 每次连接一个之后 最大连通分量就要 -- u.Count-- }}func (u *unionFind) find(i int) int { if u.Parents[i] == i { return i } return u.find(u.Parents[i])}func (u *unionFind) GetCount() int { return u.Count} 连通网络的操作次数题目所述，给定一个图，找到将其所有最大连通分量连通所需更改的最少的边的数量为多少。 图的所有最小连通为一个树，即需要 n 个节点有 n - 1 条边。 所以题目其实是要找到这个图里面有多少独立的连通分量，然后判断其是否可以连接 第一种思路就是直接 dfs 遍历，找到所有的连通分量。首先判断边的数量是否足够 n - 1 这个时候，如果有多个连通分量，说明某个连通分量一定有多的边，随意选取其中的边即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445package classic// makeConnected 方法查看func makeConnected(n int, connections [][]int) int { // 最短的话肯定是形成一棵树 才能联通所有 // 所以 边 至少要达到 n - 1 的数量 // 这个时候不能连通 if len(connections) &lt; n-1 { return -1 } // map 的邻接表表示 cMap := make(map[int][]int) for _, connection := range connections { if _, ok := cMap[connection[0]]; !ok { cMap[connection[0]] = make([]int, 0) } cMap[connection[0]] = append(cMap[connection[0]], connection[1]) if _, ok := cMap[connection[1]]; !ok { cMap[connection[1]] = make([]int, 0) } cMap[connection[1]] = append(cMap[connection[1]], connection[0]) } // 到这里的时候 由于边的数量够 所以一定是可以连通的 // 这个时候 只需要知道有 m 块是不相连的 然后就知道需要连接的次数就为 m - 1 memo := make([]bool, n) res := 0 for i := 0; i &lt; n; i++ { if !memo[i] { res++ dfs(memo, cMap, i) } } return res - 1}func dfs(memo []bool, cMap map[int][]int, start int) { memo[start] = true for _, next := range cMap[start] { if !memo[next] { dfs(memo, cMap, next) } }} 并查集，找到每个群组的数据的一个代表点 12345678910111213141516171819202122232425262728293031323334353637383940414243// findRoot 找到根节点func findRoot(parents []int, index int) int { if parents[index] == -1 { return index } return findRoot(parents, parents[index])}// makeConnected 并查集func makeConnected(n int, connections [][]int) int { if len(connections) &lt; n - 1 { return -1 } // 并查集的 parents 数组，标识 当前索引的 节点的父节点的索引是谁 // 相同的数最后均能找到同样的父节点 parents := make([]int, n) // 初始化所有的为 -1 for i := 0; i &lt; n; i++ { parents[i] = -1 } // 执行 union 的操作 for _, connection := range connections { sRoot := findRoot(parents, connection[0]) eRoot := findRoot(parents, connection[1]) // 两个点上有连接线 但是现在还没有连接起来 // 让其根节点相连 if sRoot != eRoot { // 将 e 节点连接到 s 上 parents[eRoot] = sRoot } } // 剩下的还是 -1 的就一定是整个群里面的代表节点 res := 0 for _, val := range parents { if val == -1 { res++ } } return res - 1} 由斜杠划分区域采用并查集，但是这道题有特殊的地方。 题目中所示，针对一个方格有 / 和 \\ 两种，如下 ---- ---- |\\ | | /| | \\| |/ | ---- ---- 总之，针对一个 方格 ，可以把他看成四个部分 那么，也就是说， 如果当前 char == ‘ ‘ 表示 0 1 2 3 都是联通的 如果 char == ‘\\‘ 表示 01 23 分别连通 char == ‘/‘ 表示 03 12 分别连通 内部的连通完毕后， 还可以知道 1 一定跟下一个 3 连通 2 一定跟下一行的 0 连通 1234567891011121314151617181920212223242526272829303132333435363738394041424344// regionsBySlashes 通过斜杠划分func regionsBySlashes(grid []string) int { // n * n 的矩阵的长度 length := len(grid) // 为了使用 并查集 将一个1*1 的正方形，即 一个 grid[i] 标识的区域分成 四个地方 // 然后再根据 / \\\\ 两个符号的位置进行合并 最后看有几个节点 unionSize := 4 * length * length u := NewUnionFind(unionSize) for i, str := range grid { for j, char := range str { // 0 号位置 uIndex := 4 * (i*length + j) // 同一个单元格里面的连接起来 switch char { // 0 1 2 3 都要连接起来 case ' ': u.union(uIndex, uIndex + 1) u.union(uIndex + 1, uIndex + 2) u.union(uIndex + 2, uIndex + 3) case '\\\\': // 反斜杠的话 01 23 分别连接 u.union(uIndex, uIndex + 1) u.union(uIndex + 2, uIndex + 3) case '/': // 斜杠的话 03 12 分贝连接 u.union(uIndex, uIndex + 3) u.union(uIndex + 1, uIndex + 2) } // 单元格外面的连接起来 // 不管是 \\\\ 还是 / 这个区域的1一定可以和右边下一个区域( j+ 1)的 3 连接 // 这个区域的 2 一定可以和下边(i + 1)下一个区域的 0 连接 if j + 1 &lt; length { u.union(uIndex+1, 4*(i*length+j+1)+3) } if i + 1 &lt; length { u.union(uIndex+2, 4*((i+1)*length+j)) } } } return u.GetCount()} 水位上升的泳池中游泳这道题没想明白最开始，肯定是明白要知道到什么时候 [0,0] 跟 [n - 1, n - 1] 的右下角相连 相连的判断可以通过并查集实现 那么就要解决几个问题： 怎么遍历 并查集连接的条件是什么 怎么把二维数组的位置抽象到一维 从以下几个方面入手 题目中所述 grid 中的数值从 [0, nn-1] 的唯一数值，也就是说每个格子的高度都是独立的，因此只需要遍历高度，在遍历高度中如果 [0, nn-1] 相连，即完成连接 由于题目中 当遍历的位置达到一个高度的时候，他可以直接和上下左右上的相连，也就是说遍历到高度更高的地方能够直接比高度更低的地方连接 而题目中的 grid 的棋盘的二维数组可以通过简单的 n*x+y 抽象到一维 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package classicfunc union(parents []int, i, j int) { iRoot, jRoot := findRootOfParents(parents, i), findRootOfParents(parents, j) if iRoot != jRoot { parents[jRoot] = iRoot }}func findRootOfParents(parents []int, i int) int { if parents[i] == i { return i } return findRootOfParents(parents, parents[i])}func isConnectedParents(parents []int, i, j int) bool { return findRootOfParents(parents, i) == findRootOfParents(parents, j)}var ( // 表示上下左右四个方向 DIRECTIONS = [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}})func swimInWater(grid [][]int) int { if grid == nil { return -1 } n := len(grid) index := make([]int, n*n) for i := 0; i &lt; n; i++ { for j := 0; j &lt; n; j++ { // 因为题目中所述，grid 里面的数值从 0 -&gt; n * n - 1 // 所以让高度作为下标索引 方便下面遍历 index[grid[i][j]] = n*i + j } } // grid 的二位数组 可以转为 n * i + j 的一维坐标 parents := make([]int, n*n) for i := 0; i &lt; n*n; i++ { parents[i] = i } for i := 0; i &lt; n*n; i++ { x, y := index[i]/n, index[i]%n for _, direction := range DIRECTIONS { newX, newY := x+direction[0], y+direction[1] // 因为这个是从高度相距只有1的地方开始的 所以可以直接关联 // 这样当 0 n - 1 连接到一起的时候 说明已经达到的最小的高度 // 只有新的节点的高度 小于 当前的高度 才是可以游过去的！！！ if !(newX &lt; 0 || newX &gt;= n || newY &lt; 0 || newY &gt;= n) &amp;&amp; grid[newX][newY] &lt;= i { // index 的索引用在这个地方 union(parents, index[i], newX*n+newY) } if isConnectedParents(parents, 0, n*n-1) { return i } } } return -1} 拓扑排序 逆后续排列 遍历出度为 0 的点 课程表这道题本质上就是拓扑排序 简单的做法就是用 dfs 去判断是否成环 1234567891011121314151617181920212223242526272829303132333435363738394041func canFinish(numCourses int, prerequisites [][]int) bool { // 有向图 mapOfCourses := make([][]int, numCourses) for i := 0; i &lt; numCourses; i++ { mapOfCourses[i] = make([]int, 0) } for _, prerequisite := range prerequisites { mapOfCourses[prerequisite[1]] = append(mapOfCourses[prerequisite[1]], prerequisite[0]) } // 保存已经访问过的节点 这样可以避免重复访问 totalMemo := make([]bool, numCourses) for i := 0; i &lt; numCourses; i++ { if !dfsCanFinish(mapOfCourses, make([]bool, numCourses), totalMemo, i) { return false } } return true}// 通过 dfs 的方法判断是否成环// 用 memo 来记录一次循环中访问的节点func dfsCanFinish(mapOfCourses [][]int, memo, totalMemo []bool, start int) bool { if totalMemo[start] { return true } totalMemo[start] = true memo[start] = true for _, adj := range mapOfCourses[start] { if !memo[adj] { // 截断 有环直接返回 if !dfsCanFinish(mapOfCourses, memo, totalMemo, adj) { return false } } else { // 这个地方就是找到了环 return false } } memo[start] = false return true} 拓扑排序 遍历入度为 0 的点 1234567891011121314151617181920212223242526272829303132333435363738func canFinish(numCourses int, prerequisites [][]int) bool { // 入度为 0 的点为起点 inDegree := make([]int, numCourses) for _, prerequisite := range prerequisites { // 让有向图的接受线的一端 入度++ inDegree[prerequisite[0]]++ } // 保存入度为 0 的点 inDegreeEqualZero := list.New() for i, in := range inDegree { if in == 0 { inDegreeEqualZero.PushBack(i) } } // 遍历入度为 0 的点 // 每次删除一条边 判断下一个点 是否入度为0 入度为 0 加入到 map 中 不停的遍历 直到没有点 for inDegreeEqualZero.Len() &gt; 0 { node := inDegreeEqualZero.Remove(inDegreeEqualZero.Front()).(int) for _, prerequisite := range prerequisites { if node == prerequisite[1] { inDegree[prerequisite[0]]-- if inDegree[prerequisite[0]] == 0 { inDegreeEqualZero.PushBack(prerequisite[0]) } } } } for i := 0; i &lt; numCourses; i++ { // 这个地方说明还有点相连，因此是无法完成的 if inDegree[i] != 0 { return false } } return true} 杂题递增的三元子序列首先想到嘛，用两个数组分别存储从左到右的最小值和最右到左的最大值，那么如果 nums 中一个数 num 大于这个最小值小于这个最大值，是一定可以的 123456789101112131415161718192021222324252627282930313233343536func increasingTriplet(nums []int) bool { if len(nums) == 0 { return false } mins, maxes := make([]int, len(nums)), make([]int, len(nums)) mins[0] = nums[0] for i := 1; i &lt; len(nums); i++ { mins[i] = min(mins[i-1], nums[i]) } maxes[len(nums)-1] = nums[len(nums)-1] for i := len(nums) - 2; i &gt;= 0; i-- { maxes[i] = max(maxes[i+1], nums[i]) } for i, num := range nums { if num &gt; mins[i] &amp;&amp; num &lt; maxes[i] { return true } } return false}func max(a, b int) int { if a &gt; b { return a } return b}func min(a, b int) int { if a &lt; b { return a } return b} 二分找出第 k 小的距离对距离差定义为 数组中 任意一对数之间的差的绝对值 因此找到第 K 个最小距离，一个直观的解法就是，遍历所有的差，放入到只有 k 个数的大顶堆中，那么堆顶都是结果。（memory 爆了） 12345678910111213141516171819202122232425262728293031323334353637type IntHeap []intfunc (h IntHeap) Len() int { return len(h) }func (h IntHeap) Less(i, j int) bool { return h[i] &gt; h[j] }func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }func (h *IntHeap) Push(x interface{}) { // Push and Pop use pointer receivers because they modify the slice's length, // not just its contents. *h = append(*h, x.(int))}func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x}// 找到 nums 中第k小一对数之间的最短距离（距离为两数之差）// heap outOfMemoryfunc smallestDistancePairWithHeap(nums []int, k int) int { hp := &amp;IntHeap{} heap.Init(hp) for i := 0; i &lt; len(nums); i++ { for j := i + 1; j &lt; len(nums); j++ { heap.Push(hp, int(math.Abs(float64(nums[i]-nums[j])))) if hp.Len() &gt; k { heap.Pop(hp) } } } return (*hp)[0]} 另外一个想法就是二分 二分的范围是从差值的范围出发，即 0 -&gt; max(nums) - min(nums)，那么 max min 可以直接排序取首尾即可 但是如何统计，二分中小于 mid 的差值的数量 以 [1,2,2,3,4] 为例，固定右边界为 4 的时候 1 -&gt; 4 中间可能小于 k 的数字组合为 [1,4] [2,4] [2,4] [3,4] 其结果为 j - i = 4 - 0 (4 的下标 4 1 的下标 1) 12345678910111213141516171819202122232425262728293031323334353637383940func smallestDistancePair(nums []int, k int) int { if len(nums) == 0 { return -1 } sort.Ints(nums) // i, j 表示的是 nums 中的 数据差 的范围 i, j := 0, nums[len(nums)-1] - nums[0] for i &lt; j { // mid 表示的是中间的差值 mid := i + (j - i) / 2 // 找到小于等于 mid 的数值差的数量 count := findDistancePair(nums, mid) if count &gt; k { j = mid - 1 } else if count &lt; k { i = mid + 1 } else { // 因为是小于等于 所以可能 mid 是解 也可以是在左边 j = mid } } return i}func findDistancePair(nums []int, distance int) int { res := 0 // 固定右边界 i, j := 0, 0 for j &lt; len(nums) { // 统计出来的是小于等于 distance 的数量 for i &lt; j &amp;&amp; nums[j] - nums[i] &gt; distance { i++ } // 因为是递增的 如果这个时候 1,2,2,3,4 相当于固定右边界 那么排序完的数组 左边能够形成的满足条件的数对 应该是 j - i 个 res += j - i j++ } return res} 字典树猜字谜暴力解法，用 word 去匹配 puzzle 的 set 超时了。 而原题目中 words 的数量比 puzzles 的数量高一个数量级，因此可以使用 字典树 压缩 word 的数量，用 puzzle 进行比较 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private class TrieTree { int currency; TrieTree[] child; public TrieTree() { this.currency = 0; // 因为只包含小写字母 this.child = new TrieTree[26]; } public void add(char[] word) { TrieTree cur = this; for (char c : word) { if (cur.child[c - 'a'] == null) { cur.child[c - 'a'] = new TrieTree(); } cur = cur.child[c - 'a']; } // currency 表示有一个 word 到达了这个底 cur.currency++; }}public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { // 因为实际上并不在意 word 的顺序 而且根据题目要求 word 不定长 而且比 puzzle 大 因为 puzzle 是 7 为固定长度 // 所以固定 word 为 字符树 TrieTree root = new TrieTree(); // 加入字典树中相当于 压缩了 words for (String word : words) { // 排序去重加入 因为这样才能统计 currency 并进行压缩 root.add(getCharArray(word)); } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(puzzles.length); for (int i = 0; i &lt; puzzles.length; i++) { res.add(0); } // 比较 puzzle 与 字典树 // puzzle 最大深度为 7 // 最后只需要加上 currency 即可 for (int i = 0; i &lt; puzzles.length; i++) { char[] puzzleArray = getCharArray(puzzles[i]); char required = puzzles[i].charAt(0); res.set(i, recursionSearch(root, puzzleArray, 0, required)); } return res;}// puzzle 去匹配字典树 找到一个 节点 返回其 currency 即对应的 word 数量public int recursionSearch(TrieTree node, char[] puzzleArray, int pos, char required) { if (node == null) { return 0; } // puzzle 最深就打到这儿 if (pos == puzzleArray.length) { return node.currency; } // 可以选择用当前 pos 这个位置来匹配 然后都 ++ int res = recursionSearch(node.child[puzzleArray[pos] - 'a'], puzzleArray, pos + 1, required); // 因为去重了 所以 required 等于的时候 一定要匹配 // 不等于的时候，可以维持 node 引用 然后不匹配 跳过 puzzle 的这个字符 继续往下走 if (puzzleArray[pos] != required) { // + 是因为 可以用多条路走 实际上就是要或者不要 res += recursionSearch(node, puzzleArray, pos + 1, required); } return res;}public char[] getCharArray(String word) { char[] tmp = word.toCharArray(); Arrays.sort(tmp); int newIndex = 0; int l = 0, r = 0; while (r &lt; tmp.length) { while (r &lt; tmp.length &amp;&amp; tmp[r] == tmp[l]) { r++; } tmp[newIndex++] = tmp[l]; l = r; } char[] res = new char[newIndex]; System.arraycopy(tmp, 0, res, 0, newIndex); return res;}","link":"/2021/01/18/leetcode/"}],"tags":[{"name":"code","slug":"code","link":"/tags/code/"},{"name":"求职","slug":"求职","link":"/tags/%E6%B1%82%E8%81%8C/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"summary","slug":"summary","link":"/tags/summary/"},{"name":"init","slug":"init","link":"/tags/init/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"笔试","slug":"笔试","link":"/tags/%E7%AC%94%E8%AF%95/"},{"name":"concurrent","slug":"concurrent","link":"/tags/concurrent/"},{"name":"kmp","slug":"kmp","link":"/tags/kmp/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"qrcode","slug":"qrcode","link":"/tags/qrcode/"},{"name":"life","slug":"life","link":"/tags/life/"},{"name":"undergraduate","slug":"undergraduate","link":"/tags/undergraduate/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"图算法","slug":"图算法","link":"/tags/%E5%9B%BE%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"}],"categories":[{"name":"code","slug":"code","link":"/categories/code/"},{"name":"life","slug":"life","link":"/categories/life/"},{"name":"tutorial","slug":"tutorial","link":"/categories/tutorial/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}
{"pages":[{"title":"å…³äºæˆ‘","text":"è‹¦é€¼å­¦ç”Ÿå…š è¯»ç ”ä¸­","link":"/about/index.html"}],"posts":[{"title":"18å¹´å¹´ç»ˆæ€»ç»“","text":"&emsp;&emsp;18 å¹´å¹´ç»ˆæ€»ç»“è™½ç„¶ä¼šè¿Ÿåˆ°ï¼Œä½†æ°¸è¿œä¸ä¼šç¼ºå¸­ å›é¡¾ 2018 å¹´ è€ƒç ” ï¼ˆæ˜¯ä¸æ˜¯è¯¥ç®—åˆ° 2017 å‘€ï¼‰2333 è€ƒç ”å¤è¯• æœ¬ç§‘æ¯•ä¸š æ¯•ä¸šè®¾è®¡&amp;ç­”è¾© è¯»ç ” åŠ©æ•™ å®éªŒå®¤é¡¹ç›® å­¦ä¹ å‰ç«¯åŸºç¡€ æ­å»ºåšå®¢ï¼ˆå§‘ä¸”ç°åœ¨ç®—æ˜¯æ­äº†ä¸ªé›å½¢å‡ºæ¥äº†ï¼‰ è¡¥ java åŸºç¡€ï¼ˆç®—äº†ä¹°äº†ä¹¦ è¿˜æ²¡çœ‹å®Œçš„æ„Ÿè§‰ï¼‰ ç®—æ³•ï¼ˆç®—æ˜¯å‡†å¤‡å¼€å§‹è¡¥åŸºç¡€å§ï¼‰ spring boot &amp; spring cloudï¼ˆäº†è§£ä¸‹ç°åœ¨è¾ƒâ€œæ–°â€çš„å¾®æœåŠ¡æ¶æ„å§ï¼‰ è€ƒç ”åˆè¯•&emsp;&emsp;ä» 17 å¹´ä¸ŠåŠå¹´å¼€å§‹å‡†å¤‡åˆ° 17 å¹´ 12 æœˆ 22 å·è€ƒè¯•,æ•´ä¸ª 17 å¹´éƒ½åœ¨å¤ä¹ ä¸­åº¦è¿‡ã€‚æœ¬æ¥å¼€å§‹çš„å‡†å¤‡å¦‚ä¸‹ï¼š 17 å¹´ä¸ŠåŠå¹´è¿‡å®Œæ•°äºŒçš„ä¸¤é—¨æ•°å­¦çš„ç¬¬ä¸€é &amp; è‹±è¯­çš„å•è¯ æš‘å‡ \b è¿‡ç¬¬äºŒéå¼ºåŒ– &amp; å¤ä¹ æ”¿æ²» 9 æœˆä»½å¼€å§‹è¿‡æ•°å­¦çš„ç¬¬ä¸‰é &amp; å„ç§‘çš„å¾€å¹´è¯•é¢˜ï¼ˆåŒ…æ‹¬æ•°ä¸€ï¼‰&amp; ä¸“ä¸šè¯¾ &emsp;&emsp;ç»“æœæœ€åå˜æˆäº†ï¼š ä¸ŠåŠå¹´åŠæ‘¸é±¼çŠ¶æ€ï¼Œç»“æœæœ€ååªæŠŠé«˜æ•°çš„ä¸ŠåŠå†Œç»™å¤ä¹ å®Œåšå®Œé¢˜ï¼›è‹±è¯­çš„å•è¯ä¹Ÿå¤§æ¦‚èƒŒäº†ä¸€åŠ æš‘æœŸå­¦æ ¡è¿˜è§„å®šå¿…é¡»è‡ªä¸»å®ä¹ ï¼Œè‡ªå·±æ‰¾å®ä¹ ã€‚äºæ˜¯ä¹æ•´ä¸ªæš‘å‡å¤§éƒ¨åˆ†æ˜¯å’•å’•å’•çŠ¶æ€ã€‚æ¯•ç«Ÿæ‰¾äº†è€å¸ˆå®éªŒå®¤ï¼Œæ¥äº†ä¸€ä¸ªæ´»å„¿ï¼Œä»é›¶å¼€å§‹å…¥é—¨ \bjava webã€‚å¹¸è€Œåœ¨å®¤å‹çš„å¸®åŠ©ä¸‹è¿˜æ˜¯é¡ºé¡ºåˆ©åˆ©çš„äº¤å·®èµ°äººã€‚ è™½è¯´æš‘å‡è¿˜å»æŠ¥äº†ä¸ªæ•°å­¦çš„å¤ä¹ ç­ï¼ŒèŠ±è´¹äº† 2K å¤§æ´‹å¤ä¹ ä¸¤å‘¨ï¼Œæ„Ÿè§‰è¿˜éå¸¸ä¸€èˆ¬ï¼Œå¤§éƒ¨åˆ†è‡ªå·±çœ‹ä¹¦åšé¢˜çš„æ—¶å€™éƒ½èƒ½æ€»ç»“ \b å‡ºæ¥ï¼Œåªæœ‰ä¸€é“é¢˜å’Œä¸€ä¸ªæé™å››åˆ™è¿ç®—çš„æ¡ä»¶å°è±¡æ·±åˆ»ã€‚æ€»ä¹‹å°±æ˜¯ \b ç€å®ä¸å¤ªå€¼ï¼Œå¦‚è‹¥çœŸéœ€è¦è¡¥ä¹ ï¼Œè¿˜ä¸å¦‚æŠ¥å…¨ç¨‹ç­ï¼ˆç”šè‡³çº¿ä»£æ˜¯è¾¹ä¸Šè¯¾è¾¹å¤ä¹ çš„ï¼‰ï¼ˆæ¯å¤©ä¸Šè¯¾éƒ½æ˜¯åæœ€åé¢ä¸¤æ’ï¼Œç„¶è€Œä¸æ˜¯å› ä¸ºå»å¾—æ™šï¼Œåªæ˜¯å› ä¸º\bå‰é¢çš„æ˜¯ç•™ç»™VIPå’Œå…¨ç¨‹ç­çš„ï¼Œæ¯ä¸ªä½ç½®ä¸Šè¿˜æœ‰ç¼–å·ï¼ŒçœŸæ˜¯å¤ªçœŸå®äº†ï¼‰ ä» 9\b\b æœˆä»½ä¸­ä¸‹æ—¬å¼€å§‹ç€æ‰‹ç¬¬äºŒéæ•°å­¦å¤ä¹  + æ”¿æ²»å¤ä¹ ã€‚æ¯å¤©ä¸Šåˆ 10 ç‚¹èµ·åºŠï¼ˆåæ­£ä¹Ÿä¸å»å›¾ä¹¦é¦†æŠ¢ä½ç½®ï¼‰èƒŒä¸¤ä¸ªå°æ—¶å•è¯ï¼Œåƒå®Œé¥­å»è‡ªä¹ ï¼Œæ™šä¸Š 10 ç‚¹å›æ¥ï¼Œ12 ç‚¹ç¡è§‰ æœŸé—´æ‰¾äº†ä¸€ä½ dalao å» \b ä¸€èµ·å¤ä¹ ï¼Œä¸å¾—ä¸è¯´æ²¡å¼€æš–æ°”ä¹‹å‰çš„ä¸»æ¥¼å’Œä¸»å— 10 æœˆä»½å’Œ 11 æœˆä»½æ˜¯çœŸçš„å†· 11 æœˆå¼€é¢˜ç›´æ¥è¢«å¦ï¼Œ1 æœˆé‡å¼€ æœ€åä¸å¾—ä¸è¯´è‚–ç§€è£è€å¸ˆ ğŸ‚ğŸºï¼Œç”šè‡³è¿˜è®°å¾—è€ƒè¯•å‰å‡ å¤©åœ¨ä¸»æ¥¼èµ°é“èƒŒè‚–å››çš„æ„Ÿè§‰ï¼Œä¸å¾—ä¸è¯´æœ€åè¿˜æ˜¯æŒºç¨³çš„ emmmï¼Œå› ä¸ºæˆ‘ä»¬ç³»çš„ä¸“ä¸šè¯¾è€ƒè¯•æ˜¯ C è¯­è¨€å’Œæ•°æ®ç»“æ„ï¼ŒèŠ±äº†ä¸€å‘¨æ—¶é—´åšäº†åšå¾€å¹´çš„é¢˜ç›®ï¼Œæœ€åç»“æœä¹Ÿé¢‡ä¸ºæ»¡æ„ &emsp;&emsp;è€ƒç ”çš„ \b åˆè¯•è¿˜æ˜¯å…¨å‡­å®åŠ›çš„ï¼Œå¤§å®¶éƒ½åœ¨åŒä¸€ä¸ªèµ·ç‚¹ä¸Šï¼ŒåšåŒä¸€ä¸ªå·å­ï¼Œé¢‡æœ‰ä¸€ç§é«˜è€ƒçš„æ„Ÿè§‰ï¼Œå¯æ˜¯å´ä¹Ÿå›ä¸åˆ°é«˜è€ƒçš„çŠ¶æ€äº†ï¼ˆè™½è¯´é«˜è€ƒä¹Ÿä¸æƒ³å†ç»å†äº†ï¼‰ã€‚æœ€åæ€»ç»“åˆè¯•çš„ç»å†ï¼Œæ„Ÿè§‰è¿˜æ˜¯æœ‰å‡ ç‚¹å¯ä»¥è¯´ä¸€ä¸‹ï¼š æ¯å¹´çš„è€ƒè¯•èŒƒå›´éƒ½ä¼šåœ¨ç ”æ‹›ç½‘ä¸Šå…¬å¸ƒï¼Œè¦è€ƒç ”é¦–å…ˆå»äº†è§£è‡ªå·±è€ƒå•¥ï¼Œå…·ä½“éƒ½æ˜¯å•¥ å¦‚æœä½ å¯¹è‡ªå·±çš„åˆè¯•æœ‰ \b å®‰æ’ï¼Œé‚£ä¹ˆä½ ä¸€å®šè¦äº†è§£ä¸€ä¸‹å­¦æ ¡åœ¨å¤§ä¸‰å’Œå¤§å››çš„å®‰æ’ï¼Œå› ä¸ºä½ æ°¸è¿œä¸çŸ¥é“å­¦æ ¡ä¼šåœ¨ä»€ä¹ˆæ—¶å€™ç»™ä½ æ‰”ä¸€å †è«åå…¶å¦™çš„äº‹å„¿æ¥ æ”¿æ²»æ—©ç‚¹å¼€å§‹å¥½ï¼Œ9 æœˆåå¼€å§‹çš„æˆ‘ï¼Œé‚£ä¸¤ä¸ªæœˆç—›ä¸æ¬²ç”Ÿï¼Œæ¯å¤©å¤ä¹ å¾—ç¬¬ä¸€ä»¶äº‹å„¿å°±æ˜¯èƒŒæ”¿æ²»ï¼ŒèƒŒä¸ä¸‹å»äº†ï¼Œå„ç§æ•°å­¦é¢˜æ³¡ç€ã€‚é‡å¤ç€æ”¿æ²»=&gt;æ•°å­¦=&gt;æ”¿æ²»çš„æ— é™å¾ªç¯ å› ä¸ºæ—¶é—´çš„å…³ç³»ï¼Œæˆ‘æ˜¯ä¸å¯èƒ½æœ‰å¤§é‡çš„æ—¶é—´ç»ƒä¹ è‹±è¯­å†™ä½œå•¥çš„ï¼Œäºæ˜¯è‹±äºŒå°±é ç€è€ƒç ”å•è¯å’Œæœ€åä¸¤ä¸ªæœˆçš„çªå‡»å†™ä½œç»ƒä¹ æ’‘èµ·æ¥ï¼Œæœ€åç»“æœä¹Ÿç®—æ»¡æ„ï¼Œæœ¬æ¥ä¹Ÿæ²¡æ‰“ç®—æ‹¿é«˜åˆ†ï¼Œäº‹å®è¯æ˜å•è¯ä¹Ÿç¡®å®é‡è¦ ä¸“ä¸šè¯¾ï¼Œçœ‹è‡ªå·±çš„ \b å­¦æ ¡çš„æƒ…å†µå§ å¤è¯•&emsp;&emsp;18 å¹´ 3 æœˆåˆå°±æ˜¯å‡†å¤‡å¤è¯•ï¼Œå„ç±»ä¸“ä¸šè¯¾å‡†å¤‡å‘€å•¥çš„ï¼Œåæ­£å’±ä¹Ÿæ²¡ä¸Šæœºå•¥çš„ã€‚å…¶ä»–ä¹Ÿæ²¡å•¥å¥½è¯´çš„ï¼Œåªæ˜¯å½“æ—¶æ¯•è®¾è€å¸ˆäººæ‹›æ»¡äº†ï¼Œå¦å¤–è”ç³»äº†ä¸€ä½å¯¼å¸ˆï¼Œä¹Ÿå°±æ˜¯æˆ‘ç°åœ¨çš„å¯¼å¸ˆã€‚\b&emsp;&emsp;PSï¼šå¦‚æœä½ åˆè¯•é«˜ï¼Œåˆè”ç³»äº†è€å¸ˆâ€¦â€¦ æœ¬ç§‘æ¯•è®¾&emsp;&emsp;è¯´å®è¯ï¼Œå½“æˆ‘ä»æ¯•è®¾è€å¸ˆæ‰‹é‡Œé¢ç¬¬ä¸€æ¬¡æ‹¿åˆ°è¿™ä¸ªé¢˜ç›®çš„æ—¶å€™ï¼Œè§‰å¾—ä¸éš¾å˜›ã€‚å¯å„ç§æŠ€æœ¯éƒ½ä¸å¤ªä¼šï¼Œå¤–åŠ è¿˜è¦å»é’ˆå¯¹å½“å‰é¡¹ç›®æå‡ºä¸€ç§å¯è¡Œçš„è§£å†³æ–¹æ¡ˆã€‚å½“æ—¶çš„æˆ‘ç¡®å®åšä¸åˆ° ç°åœ¨å¥½åƒä¹Ÿä¸ä¸€å®šã€‚æ¯•ç«Ÿå’±ä»¬è½¯ä»¶å·¥ç¨‹ï¼Œå¼•ç”¨ç™¾åº¦ç™¾ç§‘å¦‚ä¸‹ è½¯ä»¶å·¥ç¨‹æ˜¯ä¸€é—¨ç ”ç©¶ç”¨å·¥ç¨‹åŒ–æ–¹æ³•æ„å»ºå’Œç»´æŠ¤æœ‰æ•ˆçš„ã€å®ç”¨çš„å’Œé«˜è´¨é‡çš„è½¯ä»¶çš„å­¦ç§‘ã€‚ ç™¾åº¦ç™¾ç§‘baike.baidu.com/item/è½¯ä»¶å·¥ç¨‹/25279 ç®€è¨€ä¹‹å°±æ˜¯éœ€è¦é’ˆå¯¹ç”¨æˆ·éœ€æ±‚åšå‡ºç”¨æˆ·æ»¡æ„è½¯ä»¶åˆ¶å“ã€‚ &emsp;&emsp;è™½è¯´æ•´ä¸ªæ¯•è®¾è¿‡ç¨‹ä¸­ï¼Œå¼€é¢˜ã€äºŒæ¬¡å¼€é¢˜ã€ä¸­æœŸå’Œæœ€ç»ˆç­”è¾©éƒ½è¢«æ€¼å‡º shit äº†ï¼Œä¸è¿‡æœ€ç»ˆè¿˜æ˜¯åœ¨å­¦é•¿çš„å¸®åŠ©ä¸‹è¿˜æ˜¯å†™äº†ä¸ª Demo å‡ºæ¥ã€‚\b æ‰“å¿ƒåº•é‡Œæ˜¯ååˆ†æ„Ÿè°¢å½“æ—¶çš„é‚£ä½å­¦é•¿çš„ ä»æ¯•è®¾æ¥è¯´ã€‚å½“æ—¶çš„ç¬¬ä¸€ç‰ˆ Demo æ˜¯å­¦é•¿å†™å‡ºæ¥çš„ï¼Œä¹Ÿæ˜¯å­¦é•¿ç»™æˆ‘è®²äº† \b ä»–å¯¹ç€è¿™ä¸ªä¸œè¥¿çš„è®¾è®¡æ€è·¯å’Œæƒ³æ³•ã€‚ç„¶ååœ¨æ­¤åŸºç¡€ä¸Šæ…¢æ…¢å®Œå–„äº†è¿™ä¸ª Demoï¼ˆè™½ç„¶æ„Ÿè§‰æ²¡å•¥å¤§ç”¨ï¼‰ã€‚ ä»æŠ€æœ¯æ¥è¯´ã€‚å½“æ—¶ç”¨çš„æ˜¯ Spring boot + Spring Security + Oauth2.0 å®Œæˆçš„ Demoï¼Œå› ä¸ºæ•´ä¸ªé¡¹ç›®æ˜¯åŸºäº Spring cloud çš„å¾®æœåŠ¡æ¶æ„ï¼Œæ‰€ä»¥ä½¿ç”¨äº†èƒ½å¤Ÿè¿™äº›èƒ½å¤Ÿæ–¹ä¾¿é›†æˆçš„æ¡†æ¶ã€‚å¯ä»¥è¯´ä» Java Web ä»¥åŠå¾®æœåŠ¡æ¶æ„çš„è§’åº¦æ¥è¯´ï¼Œå­¦é•¿ç»™æˆ‘å¼€äº†ä¸€æ‰‡çª—ã€‚ æ¯•ä¸š&emsp;&emsp;\b å¤©ä¹‹æ¶¯æµ·ä¹‹è§’æ¥å½¢å®¹æ¯•ä¸šçš„æƒ…å†µæ„Ÿè§‰ååˆ†è´´åˆ‡ã€‚æœ¬ç§‘çš„å‡ ä½å®¤å‹ï¼Œä¸€ä½å·²ç»è¿œåœ¨ç¾å›½æ±‚å­¦ï¼Œä¸€ä½ \b åœ¨åŒä¸€å­¦æ ¡è¯»ç ”ã€‚\b&emsp;&emsp;å›æ²™æ²³æ‹ç…§é‚£å¤©ï¼Œç«™åœ¨åŸæ¥çš„å¯å®¤é—¨å£ï¼Œ\b åˆæƒ³èµ·æœ¬ç§‘åˆšå…¥å­¦çš„æ—¶å€™åˆå…¥åŒ—äº¬ã€‚ç‹¬è‡ªä¸€äººæ¥åˆ°å­¦æ ¡ï¼Œåˆ°æœ€åæ¯•ä¸šçš„æ—¶å€™ï¼Œæ™®èˆª julaoã€å°å¼ºã€ä¹å“¥ã€ç”·ç¥ã€æ‰˜å„¿ã€å„¿å­â€¦â€¦å¤§å­¦ä¹Ÿå·²æ˜¯ç»™äº†æˆ‘å¤ªå¤šå¤ªå¤šã€‚ è¯»ç ”&emsp;&emsp;æˆ˜æˆ˜å…¢å…¢åœ°åº¦è¿‡äº†åˆè¯•ã€å¤è¯•ã€æ¯•è®¾åï¼Œæœ€ç»ˆè¿˜æ˜¯é¡ºåˆ©æœ¬ç§‘æ¯•ä¸šè¯»ç ”äº†ã€‚ç ”ç©¶ç”Ÿçš„æ•´ä½“ç”Ÿæ´»ç»™æˆ‘çš„æ„Ÿè§‰æ˜¯è¾ƒå¿™çš„ï¼Œè€å¸ˆçš„é¡¹ç›®ã€å­¦æ ¡çš„è¯¾ç¨‹å’Œè€ƒè¯•ç­‰ç­‰ï¼Œåˆ°å¯’å‡æœ€å¼€å§‹çš„æ—¶å€™ï¼ˆå°±æ˜¯ç°åœ¨ï¼‰è¿˜åœ¨å¿™åŠ©æ•™æœŸæœ« \b æˆç»©çš„äº‹å„¿ã€‚ é¡¹ç›®&emsp;&emsp;ç¬¬ä¸€æ¬¡æ¥åˆ°è€å¸ˆç»™çš„é¡¹ç›® \b åº”è¯¥æ˜¯åœ¨ 4 æœˆä¸­æ—¬ï¼ˆ\b å·§äº†ï¼Œé‚£æ—¶å€™æ¯•è®¾è¿˜æ­£å¼€å§‹åšï¼‰ã€‚æ•´ä½“çš„å†…å®¹å¤§æ¦‚æ˜¯åš NLPï¼ˆæ€ä¹ˆå¤§å®¶éƒ½æ˜¯æœºå™¨å­¦ä¹ ï¼Œè‡£å¦¾ä¸ä¼šå‘€ï¼‰ï¼Œå¯¹çˆ¬å–åˆ°çš„æ–‡æœ¬çš„è¯­ä¹‰å®ä½“è¿›è¡Œè¯†åˆ«ï¼Œå¦‚æ—¶é—´ã€äººç­‰ã€‚ &emsp;&emsp;æ¯•ç«Ÿæ˜¯è€å¸ˆç»™çš„ç¬¬ä¸€ä¸ªé¡¹ç›®ï¼Œè¿˜æ˜¯é¢‡ä¸ºé‡è§†ï¼ŒèŠ±äº†ä¸€ä¸ªæœˆä»é›¶å…¥é—¨æœºå™¨å­¦ä¹ ã€‚å´æ©è¾¾çš„ coursera ä¸Šçš„å’Œæ–¯å¦ç¦å¤§å­¦çš„å…¬å¼€è¯¾ç¨‹éƒ½å¼ºè¡Œçœ‹äº†ä¸€éï¼Œæœ€åå¾—å‡ºçš„ç»“è®ºæ˜¯ â€”â€”â€”â€” è‡£å¦¾çœ‹ä¸æ‡‚ï¼ˆæ•°å­¦å®åœ¨æ˜¯éš¾ï¼Œç‰¹åˆ«æ˜¯æ¦‚ç‡è®ºï¼‰ã€‚ &emsp;&emsp;äºæ˜¯è½¬å¤´ç›´æ¥å¯»æ‰¾ä»Šå¹´çš„ \bNLP å®ä½“è¯†åˆ«å®ç°ã€‚è¿˜çœŸæ‰¾åˆ°äº†,16 å¹´çš„è®ºæ–‡ï¼ŒBidirectional LSTM-CRFå®ç°ã€‚äºæ˜¯æƒ³é€šè¿‡ python\b å®ç°è¿™ä¸ª \b æ€è·¯ï¼Œå†ä¸€çœ‹ kerasã€tensorflow ç­‰ä¸€å †ä¸œè¥¿ï¼Œemmmï¼Œè¿˜æ˜¯ç›´æ¥å»æ‰¾åˆ«äººå®ç°çš„å§ã€‚ &emsp;&emsp;å°±è¿™æ ·ç›´åˆ°ä¸ƒæœˆä¸­æ—¬ï¼Œç»ˆäºåœ¨æŠŠåˆ«äººçš„ \b å®ç°æ‰’ä¸‹æ¥æ”¹æ”¹çš„æƒ…å†µä¸‹ï¼Œé€šè¿‡ä¸€ä¸ªå¼€æºçš„ Word2Vec çš„é¢„è®­ç»ƒå‘é‡é›†å’Œä¸€ä¸ªå°é‡çš„è®­ç»ƒé›†ï¼Œè¿™ä¸œè¥¿ç»ˆäºèƒ½è·‘èµ·æ¥å¹¶ä¸”èƒ½è¯†åˆ«ä¸€å®šé‡çš„ \b å®ä½“äº†ã€‚ &emsp;&emsp;æœ€ç»ˆè¿™ä¸ªæ–¹æ¡ˆè¿˜æ˜¯å¤±è´¥äº†ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿåšäº†è¿™å¤šï¼Œåˆ°æœ€åä¸€æ­¥æ‰å‘ç°â€”â€”â€”â€”æ²¡æœ‰æ•°æ®ï¼ï¼çˆ¬å–çš„æ•°æ®æ²¡äººå»æ‰‹åŠ¨æ¸…æ´—ï¼ˆå·¥ä½œé‡å¤ªå¤§ï¼‰ï¼Œè€Œä¸”æ•°æ®é‡å¤ªå°ï¼Œä¹Ÿä¸èƒ½ä¿è¯è®­ç»ƒå‡ºæ¥çš„æ­£ç¡®æ€§ã€‚ä½†æ˜¯é¡¹ç›®æ€»å¾—ç»§ç»­ï¼Œäºæ˜¯ä¹ç¡¬ç€å¤´çš®ç›´æ¥äººå·¥æ¸…ç†äº†çˆ¬å–çš„æ•°æ®ï¼Œç„¶ååšä¸ªå¯è§†åŒ–ã€‚æœ¬æ¥è¿˜æƒ³æ¸…æ´—å®Œæ‰”è¿›å»è®­ç»ƒçœ‹çœ‹ï¼Œå¯å½“æ¸…æ´—å·¥ä½œå¿«ç»“æŸæ—¶ï¼Œæ‰å‘ç°æœ€å¼€å§‹çš„æ¸…æ´—æ–¹æ³•é”™äº†ï¼Œå¯¼è‡´æ¸…æ´—çš„æ•°æ®å®Œå…¨æ— æ³•æ‰”è¿›å»è®­ç»ƒã€‚äºæ˜¯æˆ‘çš„å·¥ä½œå°±å˜æˆäº†å¯è§†åŒ–å‰ç«¯+åç«¯ã€‚ &emsp;&emsp;å¯¹äºè¿™ä¸ªé¡¹ç›®ï¼Œåªèƒ½ç”¨å¿ƒæƒ…å¤æ‚æ¥å½¢å®¹äº†ã€‚ æš‘å‡&emsp;&emsp;æš‘å‡ç•™ä¸‹æ¥å‚ä¸äº†å®éªŒå®¤çš„å…¶ä»–é¡¹ç›®ï¼ˆå¯æ€œé‚£æ—¶å€™è¿˜è¦å»çœ‹æœºå™¨å­¦ä¹ ï¼‰ï¼Œä»å­¦å§æ‰‹é‡Œåˆ†åˆ°äº†ä¸€ä¸ªè¿˜ç®— \b ä¸é‚£ä¹ˆå›°éš¾çš„éƒ¨åˆ†ï¼ˆæ„Ÿè°¢ä¸‹å­¦å§çš„æ€œæ‚¯ï¼‰ã€‚ &emsp;&emsp;æš‘å‡çš„é¡¹ç›®åœ¨æˆ‘çš„ç†è§£ä¸Šæ„Ÿè§‰åƒä¸€ä¸ª proxyï¼Œå„ç±»è¯·æ±‚çš„è½¬å‘å’Œå­˜å‚¨ã€‚\bKoa2 å®ç°ï¼Œäºæ˜¯è¾¹å­¦ nodejsã€es6ã€koa2 è¾¹å†™ã€‚ä¸å¾—ä¸è¯´ js å†™èµ·æ¥å°±æ˜¯æ¯” java æ„Ÿè§‰ç®€å•Â·Â·Â·æ¯•è®¾çš„ Demo å†™å¾—å®åœ¨æ˜¯å¤ªéš¾å—äº†ã€‚ åŠ©æ•™&emsp;&emsp;è¿™å­¦æœŸçš„å¦ä¸€ä¸ªå¤§äº‹å„¿å°±æ˜¯å½“äº†ä¸€é—¨æœ¬ç§‘è¯¾çš„åŠ©æ•™ã€‚å…¶å®è¯»ç ”ä¹‹å‰æ›¾ç»å¹»æƒ³è¿‡å½“åŠ©æ•™ï¼ˆä¸»è¦æ˜¯å½“æ—¶ä¹Ÿæƒ³å¤ä¹ ç‚¹å•¥ï¼Œæ¯”å¦‚ç®—æ³•ï¼Ÿæ•°æ®ç»“æ„ï¼Ÿï¼‰ã€‚å¯çœŸæ­£è¦å»å½“åŠ©æ•™çš„æ—¶å€™ï¼Œæ‰è§‰å¾—ååˆ†è›‹ç–¼â€”â€”â€”å› ä¸ºç ”ä¸€åˆè¦ä¸Šè¯¾ã€è¿˜æœ‰å®éªŒå®¤çš„å„ç§æ´»å„¿ã€‚è·Ÿæˆ‘æ­æ¡£çš„å¦ä¸€ä½åŠ©æ•™ï¼Œç»å¸¸è‡ªå˜²ä¸ºå®éªŒå®¤æœ€å¿™çš„äººï¼Œå¤§æ¦‚æ˜¯å°±æ˜¯å› ä¸ºè¿™äº›äº‹å„¿å§ã€‚ &emsp;&emsp;å½“åŠ©æ•™ï¼Œæ¯å‘¨éƒ½è¦æ‰¹æ”¹ã€ç»Ÿè®¡ 180 ä»½å„ä½åŒå­¦çš„ä½œä¸šã€‚å¯¹æˆ‘æ¥è¯´ä¸€ä¸ªæ™šä¸Šæ‰èƒ½å‹‰å¼ºæ”¹å®Œä½œä¸šï¼Œå†èŠ±ä¸€ä¸ªæ™šä¸Šæ‰èƒ½ç»Ÿè®¡å®Œæˆã€‚ç„¶è€ŒåŠ©æ•™æœ€éš¾å—çš„åœ°æ–¹æ˜¯ \b åŒå­¦ä»¬çš„é—®é¢˜ï¼ˆè™½ç„¶å¹³æ—¶æ¥é—®çš„åŒå­¦ä¸å¤šï¼ŒæœŸæœ«é™¡å¢ï¼‰ã€‚æ¯•ç«Ÿæ˜¯ä¸¤å¹´å‰çš„ \b ç§‘ç›®ï¼Œå¥½å¤šç»†èŠ‚éƒ½è®°ä¸å¤ªæ¸…æ¥šäº†ï¼Œå¯ç ”ä¸€çš„è¯¾ç¨‹ã€å®éªŒå®¤çš„æ´»å„¿ä¸€åšå®Œï¼Œæ ¹æœ¬æ²¡å•¥æ—¶é—´å’Œç²¾åŠ›å»å¤ä¹ è¿™é—¨è¯¾ï¼Œæˆ‘åªèƒ½è¯´å¯¹åŒå­¦ä»¬è¯´è¿™é—¨è¯¾çš„åŠ©æ•™æˆ‘å°½åŠ›äº†ã€‚\b &emsp;&emsp;å½“ç„¶ï¼Œæœ€åç»Ÿè®¡æœŸæœ«æˆç»©çš„ \b æ—¶å€™è¿˜å‡ºäº†ä¸€ç‚¹å°çº°æ¼ \bï¼Œå‡ ä½ \b åŒå­¦çš„æœ€åä¸€æ¬¡ç­¾åˆ°ç»™è®¡ç®—æ‰äº†ï¼Œåªèƒ½çœŸè¯šçš„ç»™å„ä½åŒå­¦è¯´ä¸€å£°å¯¹ä¸èµ·äº†ï¼ˆè™½ç„¶ä»–ä»¬ä¹Ÿçœ‹ä¸åˆ°å°±æ˜¯äº†\bï¼‰ã€‚ å­¦ä¹ &emsp;&emsp;æ•´ä¸ª 18 å¹´å¯ä»¥è¯´æ˜¯è¢«å„ç§äº‹æƒ… drive ç€å»å­¦ä¹ çš„ä¸€å¹´ è€ƒç ”çš„æ—¶å€™è¢«è‡ªä¸»å®ä¹  drive å­¦äº†ä¸€æ³¢ Java Web è¢«æ¯•è®¾ drive\b äº†è§£äº†ä¸€æ³¢ Spring Securityã€Oauthã€Spring Cloud è¢«é¡¹ç›® drive å­¦äº†ä¸€æ³¢æœºå™¨å­¦ä¹ ï¼Œè™½ç„¶æœ€åæ— ç–¾è€Œç»ˆï¼Œä¹Ÿè®©æˆ‘æ˜ç™½æˆ‘ç¡®å®æä¸æ‡‚æœºå™¨å­¦ä¹  è¢«é¡¹ç›® drive å­¦äº†ä¸€æ³¢å‰ç«¯ï¼Œè™½ç„¶åˆ°ç°åœ¨ css ä¾ç„¶æ˜¯ä¸€å—ç—›å¤„ &emsp;&emsp;ä»¥ä¸Š 18 å¹´çš„å­¦ä¹ ä¹Ÿè®©æˆ‘å¯¹è‡ªå·± 19 å¹´çš„æœ‰äº†ä¸€å®šæƒ³æ³•ï¼Œä¸»è¦åˆ†ä¸ºé¢å‘å·¥ç¨‹æ‰©å……è‡ªå·±å§ å·¥ç¨‹ è®¾è®¡æ¨¡å¼ ç®—æ³•ã€æ•°æ®ç»“æ„ æ¡†æ¶ vue spring node åˆ·é¢˜ leetcode? (é¢å‘å·¥ä½œå­¦ä¹  23333)","link":"/2019/01/25/18summary/"},{"title":"hash-code","text":"ç®€å•å®ç°äº† hash å®¹å™¨åˆ†åˆ«é‡‡ç”¨æ‹‰é“¾æ³•å’Œå¼€æ”¾å¯»å€æ³• hashsetleetcode ä¾‹é¢˜ï¼Œè®¾è®¡ä¸€ä¸ª hash é›†åˆï¼Œä¸èƒ½ä½¿ç”¨ built-in çš„ hash ç±» è¿™è¾¹ä½¿ç”¨äº†å¼€æ”¾å¯»å€æ³•ç®€å•æ˜¯å®ç°äº†ä¸€ä¸ª hashsetï¼Œä½†æ˜¯æ²¡æœ‰å®ç°æ•´ç†ä»¥åŠæ¸…é™¤ã€‚ å¼€æ”¾å¯»å€æ³•ï¼Œå®é™…ä¸Šæ˜¯ä¸€ä¸ªä½¿ç”¨æ•°ç»„ï¼Œæ ¹æ® key çš„ hashcode è¿›è¡Œå®šä½å­˜å‚¨ã€‚ é’ˆå¯¹ hash ç¢°æ’ï¼Œä¼šçº¿æ€§çš„å¯»æ‰¾ä¸‹ä¸€ä¸ªèƒ½å¤Ÿæ”¾å…¥çš„åœ°å€æ”¾å…¥ï¼Œè€Œå¦‚æœ åˆ é™¤å…¶ä¸­ä¸€ä¸ªå…ƒç´ ï¼Œç›´æ¥å°†å…¶å¼•ç”¨åˆ é™¤çš„è¯ï¼Œä¼šé€ æˆç¢°æ’é“¾çš„æ–­è£‚ï¼Œå› æ­¤åˆ é™¤æ˜¯ä½¿ç”¨ç‰¹æ®Šçš„æ ‡è¯†ä½æ¥è¡¨ç¤ºçš„ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100 // ä¸èƒ½ä½¿ç”¨ä»»ä½• built-in çš„ hash åº“ private static class Pair { Object val; boolean isDeleted; int hashcode; public Pair(Object val, boolean isDeleted, int hashcode) { this.val = val; this.isDeleted = isDeleted; this.hashcode = hashcode; } } private Pair[] objs; private int size; /** * Initialize your data structure here. */ public MyHashSet() { this.objs = new Pair[16]; } public void add(int key) { if (++size &gt;= this.objs.length) { // å…ˆåˆ¤æ–­å¢é•¿ grow(); } int addedIndex = getAddedIndex(key); if (addedIndex != this.objs.length) { this.objs[addedIndex] = new Pair(key, false, Integer.hashCode(key)); return; } // è¿™ä¸ªæ—¶å€™ä¹Ÿåº”è¯¥ grow å› ä¸ºæ²¡æœ‰åœ°æ–¹æ”¾ç½®äº† // æŒ‰é“ç†è¯´ è¿™ä¸ªæ—¶å€™åº”è¯¥å»æ‰«æå‰å å»é™¤æ— ç”¨çš„å¼•ç”¨ grow(); add(key); } private int getAddedIndex(int key) { int i = Integer.hashCode(key) &amp; (this.objs.length - 1); for (; i &lt; this.objs.length; i++) { if (this.objs[i] == null || (int) this.objs[i].val == key || this.objs[i].isDeleted) { return i; } } return i; } private void grow() { int newLen = this.objs.length &lt;&lt; 1; Pair[] objs = new Pair[newLen]; for (Pair old : this.objs) { if (old == null) continue; // åˆ é™¤çš„å°±ä¸ç®¡äº† if (old.isDeleted) continue; int j = old.hashcode &amp; (newLen - 1); for (; j &lt; newLen; j++) { if (objs[j] == null) { objs[j] = old; break; } } } this.objs = objs; } // è·å– remove contains çš„ index // å…¶å®å¯ä»¥ç”¨ lambda è¡¨è¾¾å¼æ¥ä¼ å…¥ä¸åŒçš„å‡½æ•° å°†ä¸¤ä¸ª index æ•´åˆ private int getOtherIndex(int key) { int j = Integer.hashCode(key) &amp; (this.objs.length - 1); // å¼€æ”¾å¯»å€æ³• ç»§ç»­å¾€åæ‰¾ for (; j &lt; this.objs.length; j++) { if (this.objs[j] != null &amp;&amp; (int) this.objs[j].val == key) { return j; } } return j; } public void remove(int key) { int j = getOtherIndex(key); if (j &lt; this.objs.length) { this.objs[j].isDeleted = true; --size; } } /** * Returns true if this set contains the specified element */ public boolean contains(int key) { int j = getOtherIndex(key); if (j &lt; this.objs.length) { return !this.objs[j].isDeleted; } return false; }} hashMapleet code ä¾‹é¢˜ é‡‡ç”¨æ‹‰é“¾æ³•å¤„ç†ï¼Œhash ç¢°æ’è¿æ¥åˆ°åŸæ¥çš„é“¾ä¸Šã€‚ åŒæ—¶ç°åœ¨æ˜¯é‡‡ç”¨çš„å¤´æ’æ³•æ¥å¤„ç†çš„ï¼Œå¤´æ’æ³•ä¼šåœ¨å¤šçº¿ç¨‹æƒ…å†µä¸‹GGï¼Œæœ€å¥½ä¸ç”¨è¿™æ ·ç”¨ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157import java.io.BufferedWriter;import java.io.IOException;import java.io.OutputStreamWriter;import java.io.Writer;import java.util.Arrays;import java.util.HashMap;public class MyHashMap { // æ‹‰é“¾æ³• private static class Node { int key, val; int hashcode; Node next; public Node(int key, int val, int hashcode) { this.key = key; this.val = val; this.hashcode = hashcode; this.next = null; } @Override public String toString() { return &quot;Node{&quot; + &quot;key=&quot; + key + &quot;, val=&quot; + val + &quot;, hashcode=&quot; + hashcode + &quot;, next=&quot; + next + '}'; } } private int DEFAULT_CAPACITY = 16; private Node[] nodes; private int size; // è´Ÿè½½å› å­ private double factor = 0.75; private int threshold = (int) (DEFAULT_CAPACITY * factor); public MyHashMap() { this.nodes = new Node[16]; } /** * value will always be non-negative. */ public void put(int key, int value) { int hashcode = Integer.hashCode(key); int index = hashcode &amp; (this.nodes.length - 1); if (!headPut(index, hashcode, key, value, nodes)) return; if (++size &gt;= threshold) grow(); } // è¿”å›åŠ å…¥æˆåŠŸæˆ–è€…å¤±è´¥ private boolean headPut(int index, int hashcode, int key, int value, Node[] nodes) { // å¤´æ’æ³•æ’å…¥ Node tmp = nodes[index]; while (tmp != null) { // æ‰¾åˆ°é‡å¤ key è·³å‡º if (tmp.key == key) { tmp.val = value; return false; } tmp = tmp.next; } Node newHead = new Node(key, value, hashcode); newHead.next = nodes[index]; nodes[index] = newHead; return true; } // é‡æ–°å®šä½ private void grow() { int newCapacity = this.nodes.length &lt;&lt; 1; int newThreshold = (int) (newCapacity * this.factor); int oldCapacity = this.nodes.length; Node[] newNodes = new Node[newCapacity]; this.threshold = newThreshold; // å¤´æ’æ³•æ¯”è¾ƒç®€å• ä½†æ˜¯ä¼šæœ‰é—®é¢˜ // å®é™…ä¸Šç”¨ä¸€ä¸ª NodeHolder æŠ“ä½æ•´ä¸ª node ä¿å­˜ å¤´å°¾ æ›´æ–¹ä¾¿ for (int i = 0; i &lt; oldCapacity; i++) { Node old = this.nodes[i]; while (old != null) { // æ ¹æ®åŸæ¥çš„ hashcode è¿›å»åœ¨æ–°æ•°ç»„çš„ä½ç½® ä¸‹é¢è¿™ä¸ªæ˜¯ç”±æ•°å­¦ç‰¹æ€§å¾—åˆ°çš„ int newIndex = (old.hashcode &amp; oldCapacity) == 0 ? i : i + oldCapacity; headPut(newIndex, old.hashcode, old.key, old.val, newNodes); old = old.next; } this.nodes[i] = null; } this.nodes = newNodes; } /** * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */ public int get(int key) { int hashcode = Integer.hashCode(key); int index = hashcode &amp; (this.nodes.length - 1); Node tmp = this.nodes[index]; while (tmp != null) { if (tmp.key == key) return tmp.val; tmp = tmp.next; } return -1; } /** * Removes the mapping of the specified value key if this map contains a mapping for the key */ public void remove(int key) { int hashcode = Integer.hashCode(key); int index = hashcode &amp; (this.nodes.length - 1); Node tmp = this.nodes[index]; if (tmp == null) return; // å¤´æ˜¯ key if (tmp.key == key) { this.nodes[index] = tmp.next; --size; return; } // å¼€å§‹åˆ é™¤ Node mv = tmp.next; while (mv != null) { if (mv.key == key) { tmp.next = mv.next; --size; return; } mv = mv.next; tmp = tmp.next; } // æ²¡æœ‰æ‰¾åˆ° } public static void main(String[] args) throws IOException { MyHashMap map = new MyHashMap(); Writer out = new BufferedWriter(new OutputStreamWriter(System.out)); out.write(&quot;[null,&quot;); map.put(504, 155); map.remove(89); out.write(&quot;,&quot; + String.valueOf(map.get(334))); out.flush(); }}","link":"/2021/03/13/hash-code/"},{"title":"hexoé™æ€åšå®¢æ­å»ºï¼ˆä¸€ï¼‰hexoç®€ä»‹&amp;ç¯å¢ƒ","text":"ä¸€ç›´ä»¥æ¥éƒ½æœ‰æ­å»ºåšå®¢çš„æƒ³æ³•ï¼Œç²—ç•¥äº†è§£äº†ä¸€ä¸‹WordPresså’Œhexoï¼Œ\båœ¨å°è¯•è¿‡WordPressçš„å®‰è£…éƒ¨ç½²åæœæ–­é€‰æ‹©äº†hexoã€‚å‡†å¤‡ä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢ä»‹ç»ä¸‹hexoçš„æ­å»ºè¿‡ç¨‹ hexoç®€ä»‹ &amp; ç¯å¢ƒ hexoå‘½ä»¤ &amp; ä¸»é¢˜ hexoè‡ªåŠ¨éƒ¨ç½² hexoç®€ä»‹æˆ‘ä»¬é¦–å…ˆæ¥çœ‹çœ‹hexoå®˜ç½‘å¯¹hexoçš„ä»‹ç» è¶…å¿«é€Ÿåº¦ æ”¯æŒ Markdown ä¸€é”®éƒ¨ç½² ä¸°å¯Œçš„æ’ä»¶ \bç®€è€Œè¨€ä¹‹ï¼Œhexoå°±æ˜¯ ä¸€ä¸ªåŸºäºnodejsçš„åšå®¢å¼•æ“ æ”¯æŒejsç­‰æ¨¡æ¿å¼•æ“ é€šè¿‡æ¸²æŸ“Markdownæ–‡ä»¶ç”Ÿæˆåšå®¢æ‰€éœ€å„ç±»é™æ€æ–‡ä»¶ æœ‰è¾ƒä¸ºå®Œæ•´çš„\bç”Ÿæ€æ”¯æŒï¼ŒåŒ…å«å„ç§æ’ä»¶ï¼Œæ»¡è¶³å¤§éƒ¨åˆ†éœ€æ±‚ æ‰€ä»¥å¯¹äºç†Ÿæ‚‰nodejsçš„ç”¨æˆ·èƒ½å¤Ÿé€šè¿‡hexoå¿«é€Ÿæ­å»ºä¸€ä¸ªåšå®¢ hexoç¯å¢ƒnodejsç¯å¢ƒnvm + nrm å¯ä»¥ä½¿ç”¨nvmè¿›è¡Œnodejsç‰ˆæœ¬åˆ‡æ¢å’Œç®¡ç† å›½å†…ç¯å¢ƒä¸‹æ¨èä½¿ç”¨æ·˜å®çš„npmæºcnpmæˆ–è€…ä½¿ç”¨nrmåˆ‡æ¢åˆ°æ·˜å®æº å…¨å±€å®‰è£…hexo-cli1npm install hexo-cli -g ä½¿ç”¨åŒ…ç®¡ç†å™¨ osxç¯å¢ƒä¸‹ä½¿ç”¨homebrewå®‰è£… 1brew install nodejs gitç¯å¢ƒwindowså¯ä»¥é€šè¿‡è®¿é—®gitå®˜ç½‘ä¸‹è½½å®‰è£…åŒ…å³å¯ å„ç±»linuxç³»ç­‰å»ºè®®é€šè¿‡åŒ…ç®¡ç†å™¨ä¸‹è½½","link":"/2019/01/26/hexo-1/"},{"title":"Hello World","text":"&emsp;&emsp;å»ºç«‹è¿™ä¸ªåšå®¢åªæ˜¯å…´è¶£æ‰€è‡´ä¸ºäº†å®Œæˆ18å¹´çš„æ—¢å®šç›®æ ‡ &amp; æ‰¾ä¸€ä¸ªèƒ½å¤Ÿå†™äº›ä¸œè¥¿çš„åœ°æ–¹ï¼ˆæ¯•ç«Ÿå·¥ä½œä¹‹ä½™å¿ƒæƒ…çƒ¦é—·ä¹‹æ—¶ï¼Ÿï¼ï¼‰ &emsp;&emsp;æŒ‡ä¸å®šå†™äº›å•¥å°±å’•å’•å’•äº† &emsp;&emsp;è°¨ä»¥æ­¤hello world\bçºªå¿µä¸‹åšå®¢æ­£å¼æ­å¥½","link":"/2019/01/23/hello-world/"},{"title":"hexoé™æ€åšå®¢æ­å»ºï¼ˆä¸‰ï¼‰hexoè‡ªåŠ¨éƒ¨ç½²","text":"ç»è¿‡å‰ä¸¤æ­¥ï¼Œä¸€ä¸ªèƒ½çœ‹çš„blogå·²ç»æ­èµ·æ¥äº†ï¼Œåœ¨æœ¬åœ°è°ƒè¯•å®Œæˆåï¼Œè¿˜æ˜¯éœ€è¦ä¸€ä¸ªåœ°æ–¹éƒ¨ç½²è¿™ä¸ªblogã€‚å› ä¸ºæœ‰ä¸€ä¸ªæœåŠ¡å™¨æ¥ç§‘å­¦ä¸Šç½‘ï¼Œæ‰€ä»¥å°±å§è¿™ä¸ªblogéƒ¨ç½²åˆ°äº†åŒä¸€ä¸ªvpsä¸Šï¼ˆè¿™ä¸¤ä¸ªåº”ç”¨éƒ½ä¸æ˜¯å¤ªåƒèµ„æºï¼‰ã€‚æ‰€ä»¥æ¥ä¸‹æ¥ä»‹ç»å¦‚ä½•å°†blogéƒ¨ç½²åˆ°ä¸€ä¸ªè¿œç¨‹çš„æœåŠ¡å™¨ä¸Šã€‚ è‡ªåŠ¨éƒ¨ç½²åˆ°VPSéœ€è¦ç”¨åˆ°çš„hexoå‘½ä»¤hexoæ˜¯ä¸€ä¸ªéƒ¨ç½²é™æ€blogçš„å·¥å…·ï¼Œå› æ­¤æ‰€æœ‰çš„æ–‡ä»¶æœ€åéƒ½ä¼šè¢«ç”Ÿæˆæµè§ˆå™¨èƒ½è®¤è¯†çš„htmlã€cssã€jsæ–‡ä»¶ã€‚ 12hexo cleanhexo deploy å› æ­¤éœ€è¦åœ¨éƒ¨ç½²å‰ä½¿ç”¨hexo cleanå‘½ä»¤ï¼Œæ¸…ç†å·²ç»ç”Ÿæˆçš„/publicä¸‹çš„é™æ€æ–‡ä»¶å’Œdb.jsonï¼Œå†è°ƒç”¨hexo deployå‘½ä»¤ä½¿ç”¨hexoæä¾›çš„éƒ¨ç½²å‘½ä»¤å°†æœ¬åœ°çš„é™æ€æ–‡ä»¶éƒ¨ç½²åˆ°è¿œç¨‹æœåŠ¡å™¨ã€‚ hexo deploy use rsynchexo deployæä¾›äº†å¤šç§æ–¹å¼æ¥éƒ¨ç½²åˆ°è¿œç¨‹ï¼Œè¿™é‡Œä½¿ç”¨äº†rsyncæ¥éƒ¨ç½²ã€‚ éœ€è¦åœ¨æœåŠ¡å™¨ç«¯åšä»€ä¹ˆéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¦æ±‚æ‚¨æä¾›çš„å®é™…ä¸Šæ˜¯ä¸€ä¸ªèƒ½é€šè¿‡SSHç™»é™†è¿œç¨‹ä¸»æœºçš„Linuxç”¨æˆ·ã€‚Hexoä¼šè‡ªåŠ¨å¤„ç†å…³äºrsyncä½¿ç”¨çš„ä¸€åˆ‡æ“ä½œã€‚å› æ­¤ï¼Œæ‚¨éœ€è¦åœ¨è¿œç¨‹ä¸»æœºä¸Šä¸ºæ‚¨çš„Hexoç«™ç‚¹å»ºç«‹ä¸€ä¸ªç”¨æˆ·ï¼Œå¹¶å…è®¸å…¶é€šè¿‡SSHç™»é™†ã€‚ä¸è¿‡ï¼Œè¿™é‡Œçš„portï¼Œçš„ç¡®æ˜¯æŒ‡rsyncç›‘å¬çš„ç«¯å£ï¼Œè¯·ç¡®ä¿é˜²ç«å¢™æ‰“å¼€äº†è¯¥ç«¯å£ã€‚ hexoå¯¹äºrsyncçš„ä»‹ç» ä¹Ÿå°±æ˜¯è¯´rsyncéœ€è¦æˆ‘ä»¬æä¾›ä¸€ä¸ªå¯ä»¥é€šè¿‡sshç™»å½•çš„ç”¨æˆ·ï¼Œè¿™æ ·hexoå¯ä»¥ä½¿ç”¨è¯¥ç”¨æˆ·é€šè¿‡sshå°†éœ€è¦éƒ¨ç½²çš„æ–‡ä»¶ç§»åŠ¨åˆ°è¿œç¨‹æœåŠ¡å™¨ä¸Š æœ¬åœ°è®¾ç½®åœ¨æå®šäº†ç”¨æˆ·ä¹‹åæˆ‘ä»¬å°±éœ€è¦åœ¨blogçš„é…ç½®æ–‡ä»¶_config.ymlä¸­é…ç½®deployé€‰é¡¹æ¥å¯ç”¨rsyncå¸®åŠ©æˆ‘ä»¬æ¥è¿›è¡Œè¿œç¨‹éƒ¨ç½²ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºã€‚ ä½¿ç”¨git hooksæ¥è‡ªåŠ¨è°ƒç”¨hexo deployåœ¨å®Œæˆäº†deployé€‰é¡¹çš„è®¾ç½®åï¼Œå¯ä»¥é€šè¿‡hexo deployå‘½ä»¤ä¸€é”®å°†é™æ€æ–‡ä»¶è¿œç¨‹éƒ¨ç½²åˆ°æœåŠ¡å™¨ä¸Šï¼Œä½†æ˜¯æ¯æ¬¡éƒ½éœ€è¦æ‰‹åŠ¨è°ƒç”¨ä¸‹è¿™ä¸ªå‘½ä»¤ï¼ŒåŒæ—¶å› ä¸ºblogæ”¾åˆ°äº†githubä¸Šï¼Œæ‰€ä»¥ä¸ºäº†å·ä¸ªå°æ‡’å°±åˆ©ç”¨git hooksï¼Œåœ¨æœ¬åœ°commitåï¼Œè°ƒç”¨hexo deployå‘½ä»¤å°†æœ¬åœ°çš„æ–‡ä»¶éƒ¨ç½²åˆ°è¿œç¨‹ã€‚ é¦–å…ˆè¿›å…¥åˆ°hooksæ–‡ä»¶ä¸­ 1cd .git/hooks æ·»åŠ ä»¥ä¸‹å†…å®¹åˆ°post-commitæ–‡ä»¶ä¸­ï¼Œè¿™æ ·æ¯æ¬¡åœ¨æœ¬åœ°commitåï¼Œéƒ½ä¼šå‡ºå‘è¿™ä¸ªhookï¼Œè°ƒç”¨è¿™ä¸ªæ–‡ä»¶ä¸­çš„å‘½ä»¤ 1234567#!/bin/bashcd /path/to/your/blogecho &quot;----- å¼€å§‹ -----&quot;hexo cleanhexo generatehexo deployecho &quot;----- ç»“æŸ -----&quot; warning:é¦–å…ˆéœ€è¦è¿›å…¥åˆ°ä½ çš„blogçš„æ ¹ç›®å½•ä¸‹ï¼Œè¿™æ ·hexoçš„å‘½ä»¤æ‰ä¼šè¢«æ­£ç¡®çš„è°ƒç”¨","link":"/2019/05/17/hexo-3/"},{"title":"æ˜¥æ‹›javaåç«¯å®ä¹ å²—ç¬”è¯•æ€»ç»“","text":"æ˜¥æ‹›å®ä¹ ç”ŸæŠ•é€’å°ç»“æ˜¥æ‹›å®ä¹ ç”Ÿä¸€å…±æŠ•äº†4å®¶ä¼ä¸šï¼ŒåŒ…æ‹¬å­—èŠ‚ã€ç¾å›¢ã€é˜¿é‡Œå’Œå¿«æ‰‹ï¼Œå› ä¸ºä¸¤è¾¹éƒ½ç›¸å¯¹è¾ƒå¤šï¼Œå› æ­¤å°†ç¬”è¯•å’Œé¢è¯•åˆ†å¼€å§ å­—èŠ‚å€’åœ¨äº†äºŒé¢ ç¾å›¢åˆšåˆšå®Œæˆäº†äºŒé¢ é˜¿é‡Œå®Œæˆäº†ä¸‰é¢(ä¸è¿‡æˆ‘è§‰å¾—æˆ‘è·Ÿä»–ä»¬éœ€æ±‚çš„æ–¹å‘ç›¸å¯¹è¾ƒè¿œï¼Œå› æ­¤å¸Œæœ›æ¸ºèŒ«) å¿«æ‰‹ï¼Œå¯èƒ½æ˜¯æŠ•é€’å¾—æ¯”è¾ƒæ™šï¼Œè‡³ä»Š(4æœˆ24æ—¥æ— ä»»ä½•æ¶ˆæ¯) å› ä¸ºè§‰å¾—å¤§éƒ¨åˆ†å¸Œæœ›æ¸ºèŒ«ï¼Œæ‰€ä»¥ç‰¹åœ°è®°å½•ä¸‹æ˜¥æ‹›çš„ç¬”è¯•å’Œé¢è¯•æƒ…å†µï¼Œå¸Œæœ›æœ‰æ‰€å¸®åŠ©ã€‚ æœ‰å‡ å®¶æ˜¯åœ¨ç‰›å®¢ç½‘æä¾›çš„å¹³å°ä¸Šç¬”è¯•çš„ï¼Œä¸è¿‡ç¬”è¯•çš„æ–¹å¼éƒ½æ˜¯å¤§åŒå°å¼‚ï¼Œä¿è¯å…¥å£classæ˜¯Mainå³å¯ï¼Œå¯ä»¥å…ˆå»ç‰›å®¢ç½‘ä¸Šè¯•è¯• ä¸ä¿è¯è‡ªå·±çš„è´´å‡ºçš„ä»£ç èƒ½å¤Ÿå…¨éƒ¨ACï¼Œä»…ä¾›å‚è€ƒ é˜¿é‡Œé˜¿é‡Œçš„ç¬”è¯•æ˜¯æ‰€æœ‰äººç»Ÿä¸€æ—¶é—´å‚åŠ ç¬”è¯•ï¼Œæˆ‘æ˜¯åœ¨4æœˆ13æ—¥å‚åŠ çš„æ™šä¸Šçš„ç¬”è¯•ï¼ŒæŠ½åˆ°çš„ç¬”è¯•é¢˜éƒ½æ˜¯è·Ÿå›¾ç›¸å…³çš„ ç¬¬ä¸€é¢˜é¢˜ç›®æè¿°ä¸€ä¸ªæ•°ç»„ï¼Œè¡¨ç¤ºä¸€ç»„åŠ¨ç‰©ï¼ˆåŠ¨ç‰©çš„ä¸‹æ ‡ä»1å¼€å§‹ï¼‰ï¼Œæ•°ç»„ä¸­çš„æ•°å€¼è¡¨ç¤ºä»°æ…•çš„å¯¹è±¡ï¼Œè¿™ä¸ªåŠ¨ç‰©å¯ä»¥ç»™è‡ªå·±æŠ•ç¥¨ï¼Œæˆ–è€…è·Ÿè‡ªå·±ä»°æ…•çš„äººæŠ•åŒæ ·çš„ç¥¨ï¼Œå¦‚æœæ•°ç»„ä¸­æ•°å€¼ä¸º0 é‚£ä¹ˆä»–åªèƒ½ç»™è‡ªå·±æŠ•ç¥¨ï¼Œè€Œä¸”æ•°ç»„ä¸­çš„ä½ç½®ä»£è¡¨äº†è¿™ä¸ªåŠ¨ç‰©çš„èƒ½åŠ›å¤§å° åé¢çš„åŠ¨ç‰©è¶Šä½ï¼Œä»–ä»¬åªèƒ½ä»°æ…•å‰é¢çš„åŠ¨ç‰©ã€‚ é—®ï¼šæ¯ä¸ªåŠ¨ç‰©å¯èƒ½æ‹¿åˆ°çš„æœ€å¤§çš„æŠ•ç¥¨æ•°ä¸ºå¤šå°‘ 1234567ä¾‹ï¼šè¾“å…¥[0,1,1,1,1]è¾“å‡º4 1 1 1 1 è§£é‡Šï¼šç¬¬ä¸€ä¸ªåŠ¨ç‰©åªèƒ½ç»™è‡ªå·±æŠ•ç¥¨ï¼Œæ‰€ä»¥ä»–ç»™è‡ªå·±æŠ•ç¥¨ï¼Œè€Œåé¢çš„åŠ¨ç‰©ä»°æ…•1å·åŠ¨ç‰©ï¼Œå› æ­¤å…¨éƒ¨è·Ÿè‡ªå·±ä»°æ…•çš„å¯¹è±¡æŠ•ç›¸åŒçš„ç¥¨ï¼Œå³1æŠ•è‡ªå·±åï¼Œåé¢çš„2 3 4 5å·åŠ¨ç‰©å…¨è·Ÿ1æŠ•ç›¸åŒçš„ç¥¨ï¼ŒæŠ•1ï¼Œå› æ­¤1å·æœ€å¤š4ç¥¨ï¼Œå…¶ä»–çš„åªæœ‰è‡ªå·±æŠ•è‡ªå·±ã€‚ ä¾‹ç¨‹ï¼ˆç¬”è¯•ä¸­å†™çš„ä»£ç æ²¡æœ‰è€ƒè™‘åˆ°é€’å½’æƒ…å†µï¼Œåªå¯¹äº†10%ï¼‰ å¯èƒ½è§£æ³•1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.company;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Scanner;public class First { // é€’å½’çš„å»å¯»æ‰¾åé¢èƒ½å¤ŸæŠ•ç¥¨çš„æ˜¯å“ªäº› public static int dfs(HashMap&lt;Integer, List&lt;Integer&gt;&gt; map, int start, boolean[] memo) { List&lt;Integer&gt; temp = map.get(start); memo[start] = true; int res = temp.size(); for (Integer admire : temp) { if (start &lt; admire &amp;&amp; !memo[admire]) res += dfs(map, admire, memo); } memo[start] = false; return res; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(); int[] admires = new int[n + 1]; for (int i = 1; i &lt;= n; i++) { admires[i] = scanner.nextInt(); } HashMap&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); // ç®€å†å´‡æ‹œè€…å›¾ for (int i = 1; i &lt; admires.length; i++) { if (!map.containsKey(i)) { map.put(i, new ArrayList&lt;&gt;()); } if (admires[i] != 0 &amp;&amp; admires[i] != i) { if (!map.containsKey(admires[i])) { map.put(admires[i], new ArrayList&lt;&gt;()); } List&lt;Integer&gt; temp = map.get(admires[i]); temp.add(i); } } System.out.println(map); for (int i = 1; i &lt;= n; i++) { System.out.println(dfs(map, i, new boolean[n + 1]) + 1); } }} ç¬¬äºŒé¢˜é¢˜ç›®æè¿°ç»™å®šä¸‰ä¸ªå‚æ•°ï¼Œ3ä¸ªå‚æ•°è¡¨ç¤ºï¼ŒåŸå¸‚æ•°ï¼Œè·¯å¾„æ•°å’Œç›®æ ‡åŸå¸‚ï¼Œç„¶åä¸‹é¢æœ‰è·¯å¾„æ•°çš„è¾“å…¥i,j,kï¼Œåˆ†åˆ«è¡¨ç¤ºä»iåŸå¸‚åˆ°jåŸå¸‚èŠ±è´¹çš„æ—¶é—´æ˜¯kã€‚ é—®ï¼šå¦‚æœæ¯ä¸ªåŸå¸‚éƒ½æœ‰ä¸€ä¸ªäººï¼Œé‚£ä¹ˆè¿™äº›äººï¼Œåˆ°è¿™ä¸ªç›®æ ‡åŸå¸‚ï¼Œç„¶åå›æ¥ï¼Œåœ¨è·¯ä¸ŠèŠ±è´¹çš„æ—¶é—´çš„æœ€å°å€¼ (ps:å®é™…ä¸Šå°±æ˜¯ä¸ªæœ€çŸ­è·¯å¾„çš„é—®é¢˜ï¼Œä½†æ˜¯æˆ‘å½“æ—¶æ ¹æœ¬å°±æ²¡å’‹å¼„è¿‡å›¾ç®—æ³•ï¼Œåªäº†è§£åŸºæœ¬çš„dfsï¼Œbfså’Œè¿é€šåˆ†é‡å•¥çš„ï¼Œå› æ­¤ç¬”è¯•çš„æ—¶å€™æ˜¯ç”¨ä¸¤è¾¹dfsåšçš„ï¼Œå­˜åœ¨é—®é¢˜ï¼Œæœ€çŸ­è·¯ç®—æ³•åº”è¯¥å»å¤ä¹ ä¸€ä¸‹) å¯èƒ½è§£æ³•12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.company;import java.util.*;public class Second { static class Pair { public Integer key; public Integer value; public Pair(Integer key, Integer value) { this.key = key; this.value = value; } } public static int resolve(HashMap&lt;Integer, List&lt;Pair&gt;&gt; map, int start, int end, int size) { boolean[] memo = new boolean[size]; return dfs(map, start, end, memo, 0); } public static int dfs(HashMap&lt;Integer, List&lt;Pair&gt;&gt; map, int start, int end, boolean[] memo, int current) { if (start == end) return current; memo[start] = true; List&lt;Pair&gt; temp = map.get(start); int res = Integer.MAX_VALUE; for (Pair tempPair : temp) { if (!memo[tempPair.key]) { res = Math.min(res, dfs(map, tempPair.key, end, memo, current + tempPair.value)); } } memo[start] = false; return res; } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(), x = scanner.nextInt(); HashMap&lt;Integer, List&lt;Pair&gt;&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; m; i++) { int a = scanner.nextInt(), b = scanner.nextInt(), l = scanner.nextInt(); if (!map.containsKey(a)) { map.put(a, new ArrayList&lt;&gt;()); } List&lt;Pair&gt; temp = map.get(a); temp.add(new Pair(b, l)); } int res = Integer.MIN_VALUE; for (int i = 1; i &lt;= n; i++) { res = Math.max(res, resolve(map, i, x, n + 1) + resolve(map, x, i, n + 1)); } System.out.println(res); }} ç¾å›¢ç¾å›¢çš„ç¬”è¯•ï¼Œæˆ‘ä»¬åŒå­¦æŠ•çš„å‰ç«¯å’Œåç«¯æ˜¯ä¸€æ ·çš„ï¼Œç¾å›¢çš„ç¬”è¯•ç¯å¢ƒè·Ÿç‰›å®¢ç½‘å·®ä¸å¤šï¼Œæ³¨æ„ä¸€ä¸‹å³å¯ ç¬¬ä¸€é¢˜é¢˜ç›®æè¿°ç»™å®šä¸¤ä¸ªæ•´æ•°n,mã€‚nè¡¨ç¤ºæœ‰å¤šå°‘ä¸ªå­¦ç”Ÿï¼Œmè¡¨ç¤ºæœ‰å¤šå°‘é—¨è¯¾ç¨‹ï¼Œæ¥ä¸‹æ¥è¾“å…¥nè¡Œï¼Œæ¯è¡Œmä¸ªï¼Œè¡¨ç¤ºè¿™ä¸ªå­¦ç”Ÿåœ¨è¿™é—¨è¯¾çš„å¾—åˆ†æ˜¯å¤šå°‘ã€‚ é—®ï¼šæ¯é—¨è¯¾è·å¾—æœ€é«˜æˆç»©çš„äººï¼ˆå¯èƒ½æœ‰å¤šä¸ªï¼‰ä¸€å…±æœ‰å¤šå°‘ä¸ªï¼Œé‡å¤çš„äººåœ¨ä¸åŒçš„è¯¾ç¨‹ä¸­æ‹¿ç¬¬ä¸€é—¨ï¼Œç®—åŒä¸€ä¸ªäººã€‚ å¯èƒ½è§£æ³•ï¼ˆç¬”è¯•æ—¶ACï¼‰123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.*;public class MFirst { public static class Pair { public Integer index; public Integer credit; public Pair(int i, int i1) { this.index = i; this.credit = i1; } } public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); HashSet&lt;Integer&gt; res = new HashSet&lt;&gt;(); int[][] credits = new int[n][m]; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; m; j++) { credits[i][j] = scanner.nextInt(); } } PriorityQueue&lt;Pair&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; b.credit - a.credit); for (int j = 0; j &lt; m; j++) { for (int i = 0; i &lt; n; i++) { queue.add(new Pair(i, credits[i][j])); } if (queue.size() &gt; 0) { int max = queue.peek().credit; Pair temp; while (queue.size() &gt; 0 &amp;&amp; (temp = queue.poll()).credit == max) { res.add(temp.index); } } queue.clear(); } System.out.println(res.size()); }} ç¬¬äºŒé¢˜é—®é¢˜æè¿°ç»™å®šä¸€ä¸ªè¾“å…¥ï¼Œaã€bã€må’Œxã€‚é‡‡ç”¨ä¸€ä¸ªå¾ªç¯ç®—æ³•ï¼Œå¦‚ä¸‹ 12while (true) x = (a * x + b) % m; é—®å¾ªç¯å‡ æ¬¡ï¼Œè¿™ä¸ªç®—æ³•ä¸­xå€¼ä¼šè·Ÿæœ€å¼€å§‹ä¸€æ · å¯èƒ½è§£æ³•ï¼ˆå› ä¸ºæ²¡æœ‰æ³¨æ„åˆ°é¢˜ç›®çš„æ•°æ®èŒƒå›´ï¼Œçˆ†äº†intï¼ŒACäº†65%ï¼‰1234567891011121314151617181920212223242526import java.util.HashSet;import java.util.Scanner;import java.util.Set;public class MSecond { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int a = scanner.nextInt(), b = scanner.nextInt(), m = scanner.nextInt(); long x = scanner.nextLong(); int counter = 0; Set&lt;Long&gt; set = new HashSet&lt;&gt;(); while (true) { x = (a * x + b) % m; if (!set.contains(x)) { set.add(x); counter++; } else { break; } } System.out.println(counter); }} ç¬¬ä¸‰é¢˜é—®é¢˜æè¿°ç»™å®šä¸€ä¸ªè¾“å…¥nå’Œmï¼Œæ¥ä¸‹æ¥è¾“å…¥nä¸ªæ•°ã€‚ é—®ï¼šå¦‚æœè¿™ä¸ªnä¸ªæ•°ï¼ˆè¿™nä¸ªæ•°æœ‰å¯èƒ½é‡å¤ï¼‰è¿›è¡Œæ’åˆ—ç»„åˆä¼šäº§ç”Ÿn*nçš„ç»„åˆï¼ˆè‡ªå·±å¯ä»¥å’Œè‡ªå·±ç»„åˆï¼‰ï¼Œé‚£ä¹ˆå¦‚æœå°†è¿™äº›ç»„åˆä»å¤§åˆ°å°æ’åºï¼ˆæ’åºçš„è§„åˆ™æ˜¯å¯¹äºä¸€ä¸ªç»„åˆ[i,j] å¦‚æœiç›¸åŒï¼Œåˆ™æŒ‰ç…§jçš„å¤§å°æ’åºï¼Œå¦‚æœiä¸åŒï¼Œiå¤§çš„æ’åœ¨å‰é¢ï¼‰ï¼Œé—®ç¬¬må°çš„ä¸€ä¸ªç»„åˆæ˜¯ä»€ä¹ˆ 12345678ä¾‹è¾“å…¥ï¼š3 41 2 3è¾“å‡º(2,1) å¯èƒ½è§£æ³•(å½“æ—¶ACäº†)123456789101112131415161718192021222324252627282930import java.util.Arrays;import java.util.Scanner;public class MThird { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), m = scanner.nextInt(); int[] nums = new int[n]; for (int i = 0; i &lt; n; i++) { nums[i] = scanner.nextInt(); } Arrays.sort(nums); int divide; if (m % n == 0) { divide = m / n - 1; } else { divide = m / n; } int counter = 0, counter1 = 0; for (int num : nums) { if (nums[divide] &gt; num) counter1++; if (nums[divide] == num) counter++; } int temp = (m - counter1 * n) / counter; System.out.format(&quot;(%d,%d)\\n&quot;, nums[divide], nums[temp - 1]); }} ç¬¬å››é¢˜é—®é¢˜æè¿°ç»™å®šä¸€ä¸ªè¾“å…¥nï¼Œkã€‚nè¡¨ç¤ºè¦è¾“å…¥çš„æ•°ç»„çš„æ•°çš„æ•°é‡ï¼Œkè¡¨ç¤ºå…¶ä¸­çš„æŸä¸ªæ•°ï¼Œç„¶åè¾“å…¥nä¸ªæ•°ã€‚ é—®ï¼šå¦‚æœè¦è®©kè¿™ä¸ªæ•°æˆä¸ºä¸­ä½æ•°ï¼Œé‚£ä¹ˆéœ€è¦å†å¾€è¿™ä¸ªæ•°ç»„é‡Œé¢æ·»åŠ å‡ ä½æ•°æ‰è¡Œ 12345678ä¾‹è¾“å…¥4 11 2 2 3è¾“å‡º2 è§£é‡Šï¼šè¦è®©1æˆä¸ºä¸­ä½æ•°ï¼Œé‚£ä¹ˆå°±éœ€è¦å†åœ¨1å‰é¢æ·»åŠ ä¸¤ä¸ªæ•°å³å¯æˆä¸ºæ–°æ•°ç»„çš„ä¸­ä½æ•° å¯èƒ½çš„è§£æ³•ï¼ˆTODOï¼‰æˆ‘å½“æ—¶ä»¥ä¸ºæ•´ä¸ªæ•°ç»„çš„è¾“å…¥é¡ºåºï¼ŒåŒ…æ‹¬ç°åœ¨çš„ä¸€åˆ‡éƒ½ä¸èƒ½æ”¹å˜ï¼Œå› æ­¤æˆ‘åªæ‰¾äº†ç¦»ç°åœ¨çš„ä¸­å¿ƒæœ€è¿‘çš„kçš„ä½ç½®ï¼Œç„¶åçœ‹çœ‹å®ƒéœ€è¦å‡ ä½æ•°æ‰èƒ½åˆ°ä¸­å¿ƒï¼ˆAC 10%ï¼‰ å®é™…ä¸Šè¿™é“é¢˜æ˜¯ä¸€ä¸ªæ¡¶æ’åºï¼Œåªéœ€è¦ç»Ÿè®¡å°äºKçš„æœ‰å¤šå°‘ä¸ªæ•°ï¼Œç­‰äºKçš„æœ‰å¤šå°‘ä¸ªæ•°ï¼Œå¤§äºKçš„å¤šå°‘ä¸ªæ•°ï¼Œç„¶åå†å»è·Ÿmidæ¯”è¾ƒï¼Œæœ€åå¾—åˆ°ç­”æ¡ˆï¼ˆæ„Ÿè°¢é•‡å®‡dalaoï¼‰ æˆ‘çš„è§£æ³• 1234567891011121314151617181920212223import java.util.ArrayList;import java.util.List;import java.util.Scanner;public class MFourth { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); int n = scanner.nextInt(), k = scanner.nextInt(); int mid = (n + 1) / 2; int[] nums = new int[n]; int remember = Integer.MAX_VALUE; for (int i = 0; i &lt; n; i++) { nums[i] = scanner.nextInt(); if (nums[i] == k) remember = Math.min(remember, Math.abs(mid - i)); } int res = Integer.MAX_VALUE; System.out.println(res); }} æ­£ç¡®çš„è§£æ³•(æ¨¡ä»¿é•‡å®‡dalaoçš„æ€è·¯æ¥çš„ TODO) 1 ç¬¬äº”é¢˜é—®é¢˜æè¿°ç»™å®šä¸¤ä¸ªå­—ç¬¦ä¸²s1,s2 é—®ï¼šs1å­ä¸²ä¸s2çš„çš„å­åºåˆ—çš„åŒ¹é…ä¸ªæ•°ï¼ˆå­ä¸²å°±æ˜¯è¯´æ˜¯è¿ç»­çš„ï¼Œå­åºåˆ—å°±æ˜¯è¯´æ˜¯ä¸è¿ç»­çš„ï¼‰ è§£æ³•æ–¹æ³•å½“æ—¶ç¬¬ä¸€ååº”å°±æ˜¯dpï¼Œå¯æ˜¯æ²¡æœ‰æ‰¾åˆ°é€’æ¨å…¬å¼ï¼Œæ™®èˆªjulao ACäº†ï¼Œè¯·æ•™äº†ä¸€ä¸‹ï¼Œå¤§è‡´ç†è§£äº†æ€è·¯ï¼Œå°±æ˜¯ç”¨dp[i][j] è¡¨ç¤ºä»¥s1[i]ç»“å°¾å­ä¸²å’Œs2[j]ç»“å°¾çš„å­åºåˆ—èƒ½å¤ŸåŒ¹é…çš„æ•°é‡ è½¬ç§»æ–¹ç¨‹çš„è¯å°±æ˜¯éœ€è¦è€ƒè™‘s1[i] == s[j],ç›¸ç­‰å°±è¯´æ˜æˆ‘ä»¬åªéœ€è¦çœ‹dp[i - 1][k](k = 0 â€¦â€¦â€¦â€¦ j-1)çš„å’Œ+1å³å¯ ï¼Œå› æ­¤æœ€åä¸€ä½æ˜¯åŒ¹é…çš„ï¼Œè€Œä¸ç­‰ï¼Œå°±ç›´æ¥èµ‹å€¼ä¸º0å³å¯ è®¨è®ºåŸæ–‡ï¼šdp[i][j]æ˜¯s[i]ä¸ºå°¾çš„çš„å­ä¸²ä¸t[j]ä¸ºå°¾çš„çš„å­åºåˆ—çš„åŒ¹é…ä¸ªæ•° å¦‚æœs[i] != t[j]é‚£ç›´æ¥å°±æ˜¯0äº† å¦‚æœä¸æ˜¯çš„è¯ é‚£å°±æ˜¯ä»¥s[i-1]ä»¥åŠæ‰€æœ‰t[k]ï¼ˆ0&lt;=k&lt;=j-1ï¼‰çš„åŒ¹é…ä¸ªæ•°çš„å’Œï¼ˆå› ä¸ºè¿™äº›åŒ¹é…çš„æ¥ä¸Šs[i] t[j]è¿˜æ˜¯åŒ¹é…çš„ï¼‰å†+1ï¼ˆåªæœ‰è¿™ä¸€ä¸ªä½ç½®åŒ¹é…å‰é¢å…¨éƒ¨ä¸åŒ¹é…çš„æƒ…å†µï¼‰ ä»£ç ï¼ˆTODOï¼‰ 1","link":"/2020/04/24/interview-1/"},{"title":"hexoé™æ€åšå®¢æ­å»ºï¼ˆäºŒï¼‰hexoå‘½ä»¤&amp;ä¸»é¢˜","text":"ç®€å•è¯´ä¸‹å¸¸ç”¨çš„å‘½ä»¤ hexoå‘½ä»¤hexo å®‰è£…nodejsç¯å¢ƒå®‰è£…å®Œæˆåï¼Œåœ¨å…¨å±€ä¸‹å®‰è£…hexo\b-cliï¼Œå‘½ä»¤å¦‚ä¸‹ 1npm install -g hexo-cli hexo-cliå®‰è£…å®Œæ¯•åæ‰å¯ä»¥æ‰§è¡Œhexoå‘½ä»¤ hexo init1hexo init [folder] folderæ˜¯å½“å‰åšå®¢ç›®å½•ï¼Œé€šè¿‡hexo initå‘½ä»¤å¯ä»¥åœ¨æŒ‡å®šçš„folderç›®å½•ä¸‹è‡ªåŠ¨å…‹éš†ä¸€ä¸ªhexoé¡¹ç›®æ¨¡æ¿ï¼ˆä¸€ä¸ªnodejsé¡¹ç›®ï¼‰ï¼Œå¹¶è‡ªåŠ¨å®‰è£…ç›¸åº”çš„ä¾èµ–ï¼Œå…¶ç›®å½•æ–‡ä»¶ç»“æ„å¦‚ä¸‹. â”œâ”€â”€ _config.yml - hexoçš„ç›¸å…³é…ç½®ä¿¡æ¯ â”œâ”€â”€ db.json â”œâ”€â”€ node_modules - nodejsä¾èµ– â”œâ”€â”€ package.json - nodejsé¡¹ç›®ä¿¡æ¯ â”œâ”€â”€ scaffolds - å‘å¸ƒæ¨¡æ¿ â”œâ”€â”€ source - å­˜æ”¾ç”¨æˆ·èµ„æºï¼Œå¦‚æ–‡ç« ç­‰ â””â”€â”€ themes - ä¸»é¢˜ï¼Œä¼šæ ¹æ®ä¸»é¢˜ç”Ÿæˆ ã€å¯¹åº”çš„é¡µé¢ \bhexo serveré€šè¿‡hexo initå‘½ä»¤å»ºç«‹åšå®¢æ¨¡æ¿æ–‡ä»¶åï¼Œå…¶è‡ªå¸¦äº†landscapeä¸»é¢˜ï¼Œå¯ä»¥é€šè¿‡hexo serverç›´æ¥å¯åŠ¨ hexo new1hexo new [layout] &lt;title&gt; æ–°å»ºä¸€ä¸ªåä¸ºtitleçš„æ–‡ç« ã€‚å¦‚æœæ²¡æœ‰è®¾ç½® layout çš„è¯ï¼Œé»˜è®¤ä½¿ç”¨ _config.yml ä¸­çš„ default_layout å‚æ•°ä»£æ›¿ hexo publish1hexo publish [layout] &lt;filename&gt; hexoå°†æ–‡ç« ç»„ç»‡ä¸ºdraftå’Œpostä¸¤ç§çŠ¶æ€ï¼Œå› æ­¤åœ¨ä½¿ç”¨äº†hexo new draft someFileåéœ€è¦é€šè¿‡hexo publishå‘½ä»¤å°†å¤„äºdraftä¸‹çš„æ–‡ç« æ­£å¼å‘è¡¨ï¼Œè¿™æ ·æ‰èƒ½åœ¨blogä¸­æ­£å¸¸æŸ¥çœ‹ã€‚ hexo generate &amp; hexo deployhexo generateä¼šå°†markdownæ–‡ä»¶ç­‰ä¸€ç³»åˆ—çš„æ–‡ä»¶ç¼–è¯‘è½¬æ¢æˆæ ‡å‡†çš„é™æ€æ–‡ä»¶ã€‚hexo deployå‘½ä»¤ä¼šå°†æœ¬åœ°ç”Ÿæˆçš„é™æ€æ–‡ä»¶ä¸€é”®éƒ¨ç½²åˆ°è¿œç¨‹æœåŠ¡å™¨ã€‚ hexo ä¸»é¢˜hexoæä¾›äº†ä¸°å¯Œçš„ä¸»é¢˜ï¼Œè¿™ä¸ªblogä½¿ç”¨äº†icarus å®‰è£… å¦‚æœblogé€šè¿‡gitæ¥è¿›è¡Œç‰ˆæœ¬æ§åˆ¶ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡gitå®‰è£…1git submodule add https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus å¯ä»¥å»å…¶githubé¡µé¢ä¸Šä¸‹è½½releaseåŒ…ï¼Œè§£å‹åˆ°themes/icarusä¸‹ å¾®è°ƒæ ·å¼å¤§éƒ¨åˆ†å¯¹äºæ ·å¼çš„å¾®è°ƒéƒ½èƒ½åœ¨issuesé¡µé¢æ‰¾åˆ° é˜…è¯»é¡µé¢ä¸‰æ è½¬äºŒæ  æ·»åŠ abouté¡µé¢icaruså°†abouté¡µé¢æŒ‚è½½åœ¨äº†ç½‘é¡µçš„/abouté¡µé¢123cd blogæ ¹ç›®å½•/sourcemkdir abouttouch index.md ä¸­æ–‡è®¾ç½® icarusè‡ªå¸¦ä¸­æ–‡è®¾ç½®1vim blogæ ¹ç›®å½•/_config.yml å°†languageé¡¹è°ƒæ•´æˆzh-CNï¼Œhexoä¼šè‡ªåŠ¨åŠ è½½themes/icarusä¸‹çš„i18næ–‡ä»¶ å¯¼èˆªæ ä¸­æ–‡è®¾ç½®ä¿®æ”¹/themes/icarusä¸‹çš„_config.ymlå°† æ·»åŠ commentæ’ä»¶icarusæä¾›äº†å¯¹äºgitalkã€Valineç­‰è¯„è®ºæ’ä»¶çš„æ”¯æŒï¼Œè¿™ä¸ªblogä½¿ç”¨äº†valineå¯¹è¯„è®ºæ’ä»¶ valineç”³è¯·åˆ›å»ºåº”ç”¨ç”³è¯·leancloud åº”ç”¨ç”³è¯·æˆåŠŸåå°†ä¸‹åˆ—keyå¡«å…¥icarusä¸‹çš„_config.ymlä¸­ æ·»åŠ valineäººæ•°ç»Ÿè®¡åœ¨æ·»åŠ valineçš„commentç»„ä»¶çš„æ—¶å€™ï¼Œå‘ç°valineæ”¯æŒæ–‡ç« çš„æµè§ˆæ•°é‡ç»Ÿè®¡ï¼Œè€ƒè™‘æ·»åŠ valineé˜…è¯»æ•°é‡ç»Ÿè®¡ã€‚æ‰¾åˆ°layout/comment/valine.ejsï¼Œæ·»ä»¥ä¸‹åˆ°else blockä¸­ 1234&lt;span id=&quot;&lt;Your/Path/Name&gt;&quot; class=&quot;leancloud-visitors&quot; data-flag-title=&quot;Your Article Title&quot;&gt; &lt;em class=&quot;post-meta-item-text&quot;&gt;é˜…è¯»é‡ &lt;/em&gt; &lt;i class=&quot;leancloud-visitors-count&quot;&gt;1000000&lt;/i&gt;&lt;/span&gt; 123456(function () { var span = document.getElementsByClassName('leancloud-visitors')[0]; span['id'] = window.location.pathname; // è²Œä¼¼ title æœ‰bug // span.dataset.flagTitle = document.title;})(); spançš„idä¼šä½œä¸ºvalineç»Ÿè®¡çš„ä¸»é”®ï¼Œæ‰€ä»¥ç›´æ¥å¡«å…¥æ¯ä¸ªlocationå¯¹è±¡çš„pathnameå³å¯ï¼Œå³å¯åšå‡ºé˜…è¯»é‡ç»Ÿè®¡","link":"/2019/03/06/hexo-2/"},{"title":"javaå¤šçº¿ç¨‹(ä¸€)","text":"ä¸€ç›´ä»¥æ¥ï¼Œå¯¹äºjavaçš„å¤šçº¿ç¨‹å˜æˆéƒ½ä¸æ˜¯ååˆ†äº†è§£ï¼Œè¶ç€é¡¹ç›®éœ€è¦ä¸€ä¸ªå¤šçº¿ç¨‹çš„çˆ¬è™«å­¦ä¹ äº†ä¸€ä¸‹ï¼Œä¸»è¦æ˜¯ä¸€äº›åŸºç¡€çš„ç›¸å…³çŸ¥è¯†ï¼Œä»¥ä¸Šã€‚ Runnableå’ŒThreadè¸©çš„ç¬¬ä¸€ä¸ªå‘æ˜¯å…³äºå®ç°Runnableæ¥å£å’Œç»§æ‰¿Threadç±»æ¥buildä¸€ä¸ªæ–°çš„å¯è¿è¡Œçº¿ç¨‹ã€‚ 12345678910111213141516// Runnableæ¥å£å®šä¹‰public class MyRunnable implements Runnable { private int count = 5; @Override public void run() { System.out.println(this.count--); }}// Threadç±»å®šä¹‰public class MyThread extends Thread { private int count = 5; @Override public void run() { System.out.println(this.count--); }} 1234567// å¯åŠ¨public static void main(String[] args) { while (int i = 0; i &lt; 5; i++) { new MyRunnable().run(); // new MyThread().start(); }} åœ¨mainä¸­åˆ†åˆ«å¯åŠ¨ä¸¤ä¸ªç±»çš„5ä¸ªçº¿ç¨‹ï¼Œå¯ä»¥çœ‹åˆ°Runnableæ¥å£å¹¶æ²¡æœ‰å®é™…ä¸Šçš„å¹¶å‘çš„å¯åŠ¨å‡ ä¸ªçº¿ç¨‹ï¼Œè€Œæ˜¯åœ¨ç¬¬ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œå®Œæ¯•ä¹‹åï¼Œå†å»æ‰§è¡Œç¬¬äºŒä¸ªçº¿ç¨‹ï¼Œé˜»å¡å¼åœ°æ‰§è¡Œå®Œnewå‡ºæ¥çš„5ä¸ªçº¿ç¨‹ï¼Œç©¶å…¶åŸå› ï¼Œæ˜¯å› ä¸ºRunnableæ¥å£å®é™…ä¸Šå¹¶ä¸æ˜¯å®é™…çš„Threadçš„å…¥å£ï¼ŒRunnableæ¥å£åªæ˜¯å®šä¹‰äº†Threadçš„ä»»åŠ¡é€»è¾‘ï¼Œä¹Ÿå°±æ˜¯è¯´Runnableæ¥å£ä¸­çš„run()æ–¹æ³•åªæ˜¯å®ç°äº†ç°åœ¨éœ€è¦çš„ä¸šåŠ¡é€»è¾‘ï¼Œå®é™…çš„å¤šçº¿ç¨‹ä»ç„¶éœ€è¦é€šè¿‡Threadç±»å¼€å§‹ã€‚ å¤šçº¿ç¨‹çš„æ‰§è¡Œåœ¨å®é™…çš„çº¿ç¨‹æ‰§è¡Œçš„æ—¶å€™ï¼Œè¾ƒä¸ºä¼ ç»Ÿçš„åšæ³•æ˜¯é€šè¿‡new Thread(new Runnable()).start()æ¥æ‰§è¡Œï¼Œç„¶è€Œæ–°å»ºçº¿ç¨‹å®é™…ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªè¾ƒä¸ºç¹é‡çš„æ“ä½œï¼Œä»¥ä¸‹æ˜¯åç¼–è¯‘çš„Threadç±»ä»£ç  123456789101112131415161718192021222324public synchronized void start() { if (this.threadStatus != 0) { throw new IllegalThreadStateException(); } else { this.group.add(this); boolean started = false; try { this.start0(); started = true; } finally { try { if (!started) { this.group.threadStartFailed(this); } } catch (Throwable var8) { } } }}private native void start0(); ä»¥ä¸Šå¯ä»¥çœ‹å‡ºï¼ŒThreadç±»çš„start()æ–¹æ³•ï¼Œæœ€ç»ˆè°ƒç”¨äº†nativeçš„start0()ï¼Œæœ€ç»ˆé€šè¿‡JNI(java native interface)è°ƒç”¨åº•å±‚æä¾›çš„pthread_createæ–¹æ³•ï¼Œæœ€ç»ˆè¿›å…¥linuxç³»ç»Ÿæä¾›çš„åˆ›å»ºçº¿ç¨‹çš„æ¥å£ã€‚ åœ¨javase 1.5æä¾›äº†ä¸€ä¸ªConcurrentçš„åŒ…æ¥æä¾›æ–¹ä¾¿è¿è¡Œçš„å¤šçº¿ç¨‹ç±»åº“ï¼Œå¦‚æä¾›è¿è¡Œçš„ExecutorServiceï¼Œæä¾›çº¿ç¨‹å®‰å…¨çš„å„ç±»Blocking Queueã€Blocking Listã€Concurrent Listç­‰ï¼Œä»¥åŠä¸€äº›åŸå­æ“ä½œç±»åº“ã€‚ å…¶ä¸»è¦é€šè¿‡ExecutorServiceæ¥å¯åŠ¨éœ€è¦æ‰§è¡Œçš„çº¿ç¨‹ 12345678910111213// åˆ›å»ºæ— é™å¤§çš„çº¿ç¨‹æ± ï¼Œå½“ä»»åŠ¡åˆ°æ¥çš„æ—¶å€™ExecutorService e1 = Executors.newCachedThreadPool();// åˆ›å»ºæŒ‡å®špool sizeçš„çº¿ç¨‹æ± ExecutorService e1 = Executors.newCachedThreadPool(int poolSize);// åˆ›å»ºä¸€ä¸ªæŒ‡å®špool sizeçš„å®šæ—¶çº¿ç¨‹æ± ExecutorService e3 = Executors.newScheduledThreadPool(int poolSize);// åˆ›ä¸€ä¸ªæ‰§è¡Œå•ä¸ªçº¿ç¨‹çš„ExecutorService e4 = Executors.newSingleThreadExecutor();// é€šè¿‡submitæ–¹æ³•å¯ä»¥å°†éœ€è¦æ‰§è¡Œçš„Runnable Callableæ¥å£å®ç°ç±»å¯åŠ¨e1.submit(() -&gt; { // do something}) ä»»åŠ¡é€šè¿‡ExecutorServiceæäº¤åˆ°æŒ‡å®šçš„çº¿ç¨‹æ± ï¼Œæˆ–è€…æ‰§è¡Œçº¿ç¨‹ä¸­å¼‚æ­¥çš„æ‰§è¡Œï¼Œå³submitå‡½æ•°ä¸ä¼šé˜»å¡ä¸»çº¿ç¨‹çš„æ‰§è¡Œï¼Œæœ€ç»ˆå­ä»»åŠ¡çš„é€»è¾‘ä¼šå¼‚æ­¥çš„åœ¨æ–°çº¿ç¨‹ä¸­æ‰§è¡Œ ä½†æ˜¯å¦‚æœä¸»çº¿ç¨‹ä¾èµ–å­çº¿ç¨‹çš„è¿è¡Œç»“æœï¼Œåœ¨submitæ–¹æ³•æ‰§è¡Œåï¼Œè¿”å›äº†ä¸€ä¸ªFutureå¯¹è±¡ï¼ŒFutureå¯¹è±¡å¯ä»¥åœ¨ä¸»çº¿ç¨‹ä¸­æ§åˆ¶å­çº¿ç¨‹ 12345678910111213141516171819ExecutorService ex = Executors.newCachedThreadPool();Future f = ex.submit(() -&gt; { try { Thread.sleep(10000) } catch (Exception e) { e.printStackTrace(); }})// è·å–å­çº¿ç¨‹çš„è¿è¡Œç»“æœf.get()// åœ¨1sä¹‹ågetæ²¡æœ‰è¿”å›æ‰§è¡Œç»“æœ å³æ²¡æœ‰æ‰§è¡Œå®Œæ¯• åˆ™å‡ºå‘timeout å¯ä»¥é€šè¿‡è¿™ç§æ–¹å¼æ¥å¯¹ä¸€äº›ä»»åŠ¡åšè¶…æ—¶å¤„ç†try { f.get(1000, TimeUnit.MilliSeconds)} catch(TimeoutException | InterruptedException | ExecutionException e) { e.printStackTrace();}","link":"/2019/12/10/javaConcurrent/"},{"title":"kmp","text":"ç®—æ³•ä¹¦ä¸Šä½¿ç”¨çš„æ˜¯ æœ‰é™çŠ¶æ€æœº æ¥æè¿°çš„ kmp ç®—æ³•ã€‚ ä¹‹å‰å­¦ä¹ çš„æ˜¯é€šè¿‡å‰åç¼€åŒ¹é…çš„æ–¹å¼æ¥åšçš„ kmp ç®—æ³•ã€‚ ç°åœ¨è®°å½•ä¸€ä¸‹ã€‚ å‚è€ƒï¼šé˜®ä¸€å³° blog å‰åç¼€åŒ¹é…å®é™…ä¸Š kmp çš„æ€æƒ³å°±æ˜¯åœ¨å­—ç¬¦ä¸²å¤±é…çš„æ—¶å€™ï¼Œè·³è¿‡ä¸€å®šçš„è·ç¦»ï¼Œå°±å¯ä»¥ä¸ç”¨é‡ç½®æ¨¡å¼ä¸²çš„æŒ‡é’ˆåˆ°å¼€å¤´ã€‚ å¦‚ å­—ç¬¦ä¸² a b a b a b a b c a æ¨¡å¼ä¸² a b a b a b c a kmp a b a b a b c a å¦‚ä¸Šæ‰€ç¤ºï¼Œåœ¨å¤±é…çš„æ—¶å€™(çº¢è‰²æ‰€ç¤º)ï¼Œä¼šæ‰¾åˆ°å‰é¢å­—ç¬¦ä¸²ä¸­ç›¸åŒé•¿åº¦çš„å‰ç¼€å’Œåç¼€(ç»¿è‰²æ‰€ç¤º)ï¼Œè¿™æ ·åœ¨åŒ¹é…çš„æ—¶å€™ï¼Œå°±å¯ä»¥ç›´æ¥è·³è¿‡è¿™äº›é•¿åº¦çš„å‰åç¼€ï¼Œå‘å³ç§»åŠ¨ 6 - 4 = 2 ä½é•¿åº¦å³å¯ã€‚ é‚£ä¹ˆå®é™…ä¸Š kmp çš„åŸå§‹è¿ç®—ç®—æ³•å°±å¯ä»¥å¾—åˆ°äº† 1234567891011121314151617181920public int kmp(String origin, String pattern) { // è·å¾— kmp æ•°ç»„ int[] next = getNext(String pattern); int i = 0, j = 0; while (i &lt; origin.length() &amp;&amp; j &lt; pattern.length()) { if (origin.charAt(i) == pattern.charAt(j)) { i++; j++; } else { // å› ä¸ºæœ‰ç›¸åŒçš„å‰åç¼€ æ‰€ä»¥ç›´æ¥èµ‹å€¼ å°±æ‰¾åˆ°æ¨¡å¼ä¸²ç›¸ç­‰çš„å‰ç¼€çš„ä½ç½® j = next[j]; } } // è¿”å›å¼€å§‹çš„ index if (j == pattern.length()) return i - j; // æ²¡æœ‰æ‰¾åˆ°åŒ¹é… return -1;} è€Œ next æ•°ç»„çš„æ±‚æ³•ï¼Œå®é™…ä¸Šæ˜¯ pattern å­—ç¬¦ä¸²è‡ªå·±è·Ÿè‡ªå·±åŒ¹é…ï¼Œæ‰¾åˆ°ç›¸ç­‰çš„å‰åç¼€çš„é•¿åº¦ ä»¥ a b a b a b c a ä¸ºä¾‹ å­—ç¬¦ä¸² å‰ç¼€ åç¼€ åŒ¹é…çš„æœ€å¤§é•¿åº¦ a [] [] 0 a b [a] [b] 0 aba [a, ab] [a, ba] 1ï¼ˆa ä¸ a åŒ¹é…ï¼‰ abab [a, ab, aba] [bab, ab, b] 2 (ab åŒ¹é…) ababa [a, ab, aba, abab] [baba, aba, ba, a] 3(aba åŒ¹é…) â€¦â€¦ â€¦â€¦ â€¦â€¦ â€¦â€¦ ä¸Šé¢çš„è¡¨æ ¼è¡¨ç¤ºäº†å‰åç¼€çš„åŒ¹é…æƒ…å†µï¼Œä¸‹ä¸€æ­¥å°±æ˜¯æ±‚å¾—è¿™ä¸ªå‰åç¼€åŒ¹é…é•¿åº¦çš„ next æ•°ç»„ 12345678910111213141516171819public int[] getNext(String str) { int n = str.length(); int[] next = new int[n]; next[0] = -1; // è®©æ¨¡å¼ä¸²é”™ä½ä¸€ä¸ªå¼€å§‹ kmp çš„åŒ¹é…è¿‡ç¨‹ int k = -1, j = 0; while (j &lt; n - 1) { if (k == -1 || str.charAt(k) == str.charAt(j)) { k++; j++; next[j] = k; } else { // æ ¹æ®å·²ç»åŒ¹é…çš„é•¿åº¦ é‡æ–°å®šä½ k = next[k]; } } return next;}","link":"/2021/03/07/kmp/"},{"title":"ç­¾åˆ°äºŒç»´ç ç”Ÿæˆ","text":"åšè¿™ä¸ªä¸œè¥¿çš„çµæ„Ÿæ¥è‡ªäº[lufer blog]('http://coder.lufer.cc/2018/06/11/%E7%8C%AB%E9%80%94%E6%A0%A1%E5%9B%AD%E7%AD%BE%E5%88%B0%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81%E4%BC%AA%E9%80%A0/')ä»¥åŠå®¤å‹çš„å¾®ä¿¡å°ç¨‹åºæ‹†åŒ…å¸®åŠ© åšè¿™ä¸ªäº‹å„¿çš„åŸå› å˜›ï¼Œæœ€è¿‘è€å¸ˆå‡†å¤‡æ´¾å‡ºå»å‡ºå·®å»å­¦ä¹  2 å‘¨ï¼Œä½†æ˜¯äººå‡ºå»äº†ï¼Œè¯¾è¿˜æ˜¯è¦ä¸Šçš„ï¼Œå°¤å…¶æ˜¯æœåšå£«çš„è¯¾åˆåœ¨æœ€è¿‘å¼€äº†ã€‚æœåšå£«è¿˜æ˜¯æœ‰ç‚¹æ€•çš„ï¼Œè€Œå¥½å·§ä¸å·§æœåšå£«åˆå–œæ¬¢ç”¨å¾®ä¿¡å°ç¨‹åºçš„çŒ«é€”æ ¡å›­æ¥è¿›è¡ŒäºŒç»´ç ç­¾åˆ°ï¼Œæ‰€ä»¥æ‰æœ‰äº†åšè¿™ä¸ªä¸œè¥¿çš„åŠ¨åŠ›å’ŒåŸå› ã€‚ çŒ«é€”æ ¡å›­ç­¾åˆ°äºŒç»´ç ç”Ÿæˆå»å¹´å·²ç»æœ‰å­¦é•¿å¤§è‡´åšè¿‡äº†è¿™ä¸ªäºŒç»´ç çš„ä¼ªé€ ç­¾åˆ°ï¼Œç²—ç•¥çš„çœ‹äº†ä¸€ä¸‹ï¼Œå¤§æ¦‚å¯¹é¢åªæ˜¯åœ¨äºŒç»´ç é‡Œé¢æ˜æ–‡æ”¾äº†ä¸€ä¸ªè¯¾ç¨‹ID&amp;å­¦ç”ŸID&amp;&amp;å½“å‰æ—¶é—´çš„ä¸‰å…ƒç»„ï¼Œé€šè¿‡åœ¨ä¸€ä¸¤ç§’çš„æ—¶é—´å†…ä¸æ–­å˜æ¢å½“å‰æ—¶é—´æ¥å˜åŒ–äºŒç»´ç ï¼Œè¾¾åˆ°å¿…é¡»åœ¨ç°åœºæ‰èƒ½ç­¾åˆ°çš„ç›®çš„ã€‚å¯æ˜¯å’±å¦å¤–ç»™ä½ ç”Ÿæˆä¸€ä¸ªäºŒç»´ç ä¸å°±è¡Œäº†å˜›ï¼Œ23333ã€‚ é—®é¢˜è¿™å‘¨ï¼Œä¸“é—¨æˆªå›¾äº†ä¸€ä¸ªç­¾åˆ°äºŒç»´ç æ¥æ‰«ç è¯•è¯•ï¼Œæ‰«ç ç»“æœå¦‚ä¸‹ã€‚ 1x%97%C5%94joj%97%93%92%98ggf%60%60f%9C%C8%C6%C7%94a%95%8B%5B%98%C7%C6%9Bke%98%98chni%95%92%60foo%99%9Anm%99%89Wfjloqljnnikp%5D%u5F46%uC46F%uC8C6 å—¯ï¼Ÿï¼ï¼è¿™å’Œè¯´å¥½çš„æœ‰ç‚¹ä¸å¤ªä¸€æ ·å‘€ï¼Œä¸æ˜¯è¯´å¥½çš„æ˜æ–‡å­˜å‚¨å˜›ã€‚åœ¨çœ‹åˆ°%åé¢è·Ÿç€æ•°å­—çš„æ—¶å€™ï¼Œæœæ–­çŒœæƒ³æ˜¯ä½¿ç”¨äº† js çš„encodeURI()æ¥è½¬æ¢äº†ä¸€ä¸‹æ— æ³•åœ¨æµè§ˆå™¨è·¯å¾„æ é‡Œé¢è¯†åˆ«çš„å­—ç¬¦ï¼Œç„¶åæœç„¶Â·Â·Â·çŒœé”™äº†ã€‚ å°ç¨‹åºåç¼–è¯‘ï¼ˆè¿™æ—¶å€™åˆè¦è†œä¸€æ³¢å®¤å‹äº†ï¼‰åœ¨å°è¯•äº†å¸¸è§äº†ç¼–ç å’ŒåŠ å¯†æ–¹å¼éƒ½æ²¡åŠæ³•æ‹¿åˆ°åŠ å¯†ä¿¡æ¯åï¼Œåœ¨å®¤å‹çš„å¸®åŠ©ä¸‹å§å¾®ä¿¡å°ç¨‹åºåç¼–è¯‘æ‹¿åˆ°äº†æºä»£ç ã€‚(å¾®ä¿¡å°ç¨‹åºä¼šåœ¨æœ¬åœ°ç¼“å­˜ä¸€ä¸ª.wxapkgçš„æ–‡ä»¶ï¼Œè¯¥æ–‡ä»¶å¯ä»¥åç¼–è¯‘å‡ºæºä»£ç ï¼Œåç¼–è¯‘å·¥å…·)ï¼ˆä»¥åå°±ç®—ä»–çš„åŠ è§£å¯†æ–¹æ³•å˜äº†ï¼Œä»ç„¶å¯ä»¥é€šè¿‡è¿™ç§æ–¹æ³•é‡æ–°æ‹¿åˆ°ä»–çš„åŠ è§£å¯†æ–¹æ³•ï¼‰ã€‚æ€»å€¼æœ€åæ‹¿åˆ°çš„åŠ è§£å¯†æ–¹æ³•å¦‚ä¸‹ã€‚ 1234567891011121314151617181920212223// åŠ å¯†function encrypt(str) { for ( var t = String.fromCharCode(str.charCodeAt(0) + str.length), n = 1; n &lt; str.length; n++ ) { t += String.fromCharCode(str.charCodeAt(n) + str.charCodeAt(n - 1)); } return escape(t);}// è§£å¯†function decode(str) { str = unescape(str); for ( var t = String.fromCharCode(str.charCodeAt(0) - str.length), n = 1; n &lt; str.length; n++ ) t += String.fromCharCode(str.charCodeAt(n) - t.charCodeAt(n - 1)); return t;} æ€»ä½“æ¥è¯´å°±æ˜¯é€šè¿‡ js æ¥äº§ç”Ÿäº† unicode ç çš„åç§»ï¼Œåœ¨åŠ å¯†æ—¶ï¼Œé™¤äº†ç¬¬ä¸€ä½åç§»äº†å­—ç¬¦ä¸²é•¿åº¦çš„ä½æ•°ï¼Œå…¶ä»–çš„å‡æ˜¯åç§»äº†åä¸€ä¸ªä½ç½®çš„ä½æ•°ã€‚å”¯ä¸€ä¸æ‡‚çš„æ˜¯escape()å’Œunescape()æ–¹æ³•ï¼Œä¸€æŸ¥ï¼Œè¿™ä¸¤æ–¹æ³•éƒ½å·²åºŸå¼ƒÂ·Â·Â·ï¼Œä¸ä¹‹å¯¹åº”çš„æ˜¯ encodeURI()å’ŒdecodeURI()ã€‚äºæ˜¯å°†ä¹‹å‰æ‰«ç æ‹¿åˆ°çš„å­—ç¬¦ä¸²ä¸¢è¿›å»è§£ç ï¼Œå¯ä»¥å¾—åˆ° ç°åœ¨å˜æˆäº†ä¸€ä¸ªå››å…ƒç»„(&amp;åˆ†éš”)ï¼Œç¬¬ä¸‰ä¸ªæ˜¯æ ‡å‡†çš„ unix æ—¶é—´æˆ³ï¼Œå› æ­¤æˆ‘ä»¬åªéœ€è¦æ‹¿åˆ°å››å…ƒç»„çš„å…¶ä»–ä¸‰ä¸ªä¿¡æ¯ï¼Œç„¶åè‡ªå·±ç”Ÿæˆä¸€ä¸ªæ—¶é—´æˆ³ï¼Œå°±å¯ä»¥ç”Ÿæˆè·Ÿä»–å®Œå…¨ä¸€æ ·çš„äºŒç»´ç äº†ã€‚æœ€åå®ƒæ¯ 3 ç§’é’Ÿç”Ÿæˆä¸€æ¬¡äºŒç»´ç ï¼Œä¸è¶…è¿‡ 5s çš„æ—¶é—´å·®å°±æ¥å—è¯¥äºŒç»´ç ã€‚ è‡ªå·±å†™äº†ä¸ªç”Ÿæˆçš„é¡µé¢ï¼Œéœ€è¦ä¸Šä¼ ä¸€ä¸ªè‡ªå·±çš„ç­¾åˆ°æˆªå›¾ï¼Œå°±ä¼šæ¯ 1s ä¸­åœ¨é¡µé¢ä¸­ç”Ÿæˆä¸€ä¸ªäºŒç»´ç å’Œåˆ†äº«é“¾æ¥ï¼ŒæŠŠåˆ†äº«é“¾æ¥å‘é€ç»™åœ¨æ•™å®¤çš„å¤§ä½¬ä»¬å¸®å¿™ç­¾åˆ°å³å¯ã€‚å®ä¾‹å¦‚ä¸‹majexh.xyz/qrcode","link":"/2019/05/17/maotuQrcode/"},{"title":"ä¸€äº›åæ§½","text":"4d5b354008a79032227bf4d2dcfc8ac348f0e256e558eca4a30f845895870ce8fb5e8f8fb0907b486c29aa2a1c5cfe43a0705892748bdafa18044d53171cc282a0158f686b95a14bcaf0529f57c540003c62a7154aa095f6ec434dc400a39f688aa811682f6add45ab148d3b3db137d2504a6ba23d02bf8e27fcf15870338c4189be78f818213f6d0522cdd8c983de66fb311b49504a97e808e3f21cb7db10b53ca9b3923add8b1fdbbabfa5505967f64ec0ff60944b56fae433a1a74f7511ca8f8484fd9e4c481bac1c5829892916b279fe4a04d6650e7345a86eec364bb88cc1ce5b9ec114091d2db12cf261a8b4c313c5279a406feac438b048099a81be4ccd0e527e5545c2addecac06e02f4259258e053a883f827d340a069c2e6dc79cba72c5e343b07f7fb171ed5d5a7f6959bbc4ec8b7d56865439f31bb687714f6aabb20f004b8f27c03a695740f8f25f1c4f0798638972112bcb01278020cb2f89b6f8dad32a32e44d30138ef398f48e664ac41e3ff2b7d229e32562a738bb1bb3666a21a1a15cbb514b0058c93ba847b27e2aa44b16ee36138e3471e09d4753074a8c22d35dc22984534e293d8710ab2390695a782c21421e260949d26f064bb2042b1eb9b6eb0ae2eb3c703f0bc8dfd570ae6e64bcf5d4108bde72bee146f5e74d4feaed1084dae44bc28f68195647dd0c66257794f96a29f123328ef4ce41794ad0221ae1a32a8d20ccb7ca9f48b046b66a992abdbd182a94fba8688137e73aad952d6551255bf24338bb63fc044529af044db22ff678bb676397f297d2b549c73ce8aa848a18af352b3bc5478ce6fab9a7310c71d441218457c40a7e16191c7a98ea448ff0e6a30fd22c5bdf1296217d60093d531fd138917a6c497ec6fef4cd3b7ce973d957b9f0083e175c3c392053854791752186d1ae1d0cfd23665ea1f81dfcc0d8c3a647cbee8698e8df8838632342bd3bed47ba0efcadaafcfb625dab57f98a2a0a7aaef180e83c39395a0f78ab3c0c20873785277ad190341831ae827000c9266e624852fbb029e4361bcbdead34af7a9e45a5503459f16bb7cffdd828c6cd17a7178b479d734860935147cc0b3a8752204e62c22332eb5ef60c1e940fb83cff797bfa0e0638b64ac3dd5033f877669bc3bd8fb00e190728a0e5ca524581466ebac3e6be2f356ad33f31c58e06fa9d381c4ca0d2c1f37262df51e24cfe0b82db1556c713298204522c5c1fd68f0b3d9c9624988c71e15374570ffa63ed576d998d0c667c90f4e2b6c14e43f4f0d7845b15afd741653752c4185d9753baacd2030daebe63adc3298129ca30acbbb20de0eae03e7537329e899bb8044499cdc58aaa0eb586261f0fa27d63372cd6b7c57735c0e8ec8735a514cb2ad3918bbe9424eb9acd8deaf9ca50518d905e79581401fd37da4b950e63f80269aa498b0f98dfad2786f19b2af0813f5c4877c8fcfcf6c8e105686cf5e206ec2ac3411b57299a22317cbf5aa898f3bd2b3a2d5aa983545c0a1d427f114405ae63f8d1929ccc6575f64a417cb61ebad62e5972f566504b0f1b0b434656fe94427f40b77526e4706d083378101c4cba3c1d1fa63c6005e34b0422a483e6e71eb2c0b6a77d7399bab425594cb11593f933f6ee0646b7fb1fd26e148b0908356d9ad990f1fa1cc5a6e0f1a2b7b5e50de6f4d27d8bd5d3c282fb8217891689671d82878fea61049e4d28e2b1a5212f3e19dcb1a48d982a2d4d2c6d9ac4fe5f9c0eb3ac13b31bbbe188340703d3821ae4fd53216c1238d96296f91ce3b70bd22f84cd96b047738bea76f779a9ab11180e23dd59e45dfdc8ca08770872c0b585cb2467618882ee089b0b497e01a1b889e2300a983e90cf7077703eed7bb3575435c612946c469de05bdaba01a37aede9c4d949cdfbde171917c49d933c790a6980a2c02fff811f725174c5c16f8799db9336a47d19e8c700627f5c55727b6faa41a0d6c2664044f0ed693536cd1f7d78fc7630c4e6e46ddc6d54854cae7da43dc257d4f183d728ad961fb3aed31255385cb403b3c6df996b7a57645ea608f8e452e5eeb9b38eb372434c1c66b7b203a4dfb80c55f5ab17ed7a94a84e955a2a91c76ee066cb72544cde387a7f8a20ac2c4d8e7653d2940780e637bfa5d6022b9d246d561c99f985bbc1a62aec6a1874a96ad20f0434ed6e77120ea669fdf4d685b09faf6e98c2ec5992d90676927f5fcf53c4601c666795731946e67b2d71f2d52cb6ae91e4155d735bc069610459d814103a0c72eec23569413a268853f5a8f4947e7430664a2648aa1c57cec3ca37559ffdb43ae1dee24c039b66bf660bfdd0ae7aecbb9b95dc1f1d6a2ab44f915fb1b7396d350b72bb8a4d42f60c085f40aaed15be042475efe8a59c2e087875f747c2f9d3820659e985a78e7e3f28a9b13142c033d7c5c303fe436286eb6aeff8030b6157d4208d4e863e089c6d85027dc20f94c372d9cc3f07733a1282a59390c6b7acfb5a7eea9968ea701e812fb5f1350d37e4544f67533ddd45b4092e404eac1439aea27efc5bf008d1660ba7563185f1f173e8e4b9c06befb0379e21fc595f97619944ae9ecfeb13ed9663c36886d68daebc3f7e711d9f25e75802119d69e3c3827f71bb43df7fab27e25b165a2b8a452394fec9e0728f4d25e129cbb36d31e7854bd9d4693e3a37d1820aef9084547dacf914f74f40b50a597dbff19ffd07ff6150de3e26d58a1109727b4bf8800d928bb38ac236dde1638567af7dd8ad952841930ddfabcba921bad528c9adae8276429c0bb17c0c94b050183a670302a5a248e5c8a08e3858d7fcc5090a543b33f71f516ff8f08a494dadafd151a657d906ef916a36a08f41f57b3e25ccb00b50340cb7e39c711ca8d34a9f4e016a338edc18e04a68dc0f04135ec3d3f31198d50853b3ff0edbbd9860ca9c81eafd302e5fc4437c60d5ebbdf68a38ce6c3f83c78405efc213fa97eb0c794b6dd05ffdc5f1fb077d586a2e6253c836517ad099ff05e0aebe0f3e6647feba34a82698baf06f712a85e78c96dcda8c0e8a638e33d608f42674b40b86baaa8a4733aa7b848e4e5e09a5c40e77fab935376631db73555c16b2b38a696a802e3a6e8ed370af64ca5a0faf274e092ed71d1c4db0c62e67b1c714963ec16ccda1959d8ba6712d350b0a9a2c3db51f456b3badd8906d8f0888f48333c51724a3680a615d0a2f3973ba48dddb52723d6291802348a199a59f8bc38017439d2209133740c6b9e8f78c0ea9df1d575db892f6e0ca9d4afbe629536872a8f01f0e2479f4b785b09702924e4a739666d0a5bb247f8f504401891ce00c527b7fad8b74faed7fd74fe93189601ec046d2527d2736c5719b72d96fd06a3670b0d230fbb15a90e8c433a1141061a5fc45cc34a000bd0bc202b9d14e53fd78368421f3222a55c5f0fcd26dbf2c544d8b2f13926bdaf1801762ccdb04725cc998788ec31d0737ef3bb5409261ebe4990e689b9a38dd3cbb4dc45e90a22642b2b87ffaaab1aba29af1fc44212f6c7e13f19cb0fe6be9cdb99baf0bb3108a2e85dfc0f8b67b35298ff1b4bbf61356a14b5ab9b89e0c31ac728216a6aacb5a53ef039c3cdd4daec86f5f41b3f641cd46f7e285793f2cb26128ca14b05546f9ec7966e0438f4db8c014b2c0273689378ed09e519f4e7267a1d5471814f277a955cb1baee7676a3b17c03988c2aee7bbd7ecac07b8b737049f1817f4a1ca9a76a98f5834eafe5d2c593b6ec5e4348a1c6d7d83a1005258a28677c254e9565c05ae2c57d157040dfc2098b7066cbb17b6a7d36b4f127dd6ca8bb0db615d760f8929aa53b75856b954c5fe0fae0bf5b5c210903dc14d09ac01622cd59fcb03dca7ca20bf5b0365978a91e3c3f5fde00d155aa0a68471c5ae2f65f788b8e58e865122c91db123aeb6de64a3addbf563b79427ad1c2c35537518c3e1b2da839c070bd7d3f9a16f91cf474dd55fac9d00922b7fd6701497dd88e9dcd75a1addeefc49046f0be0ddff92afd7dfca598ac58c7ad90b3a5e8a0e8f0294e866520e3e78a7c3a077e95d2d6a7703318832db8b3c5f54e8c4dc39c18ae57576777f0b4b697560c5ee566248f812cc6512388f6e12ed462da3116e81de74ede576d6b91e8d1294cdc7e312ffdda47448e004aa4e1bea540f68359a28dbef30dbcaf3a08b6eb4a8f7464ede227148bdfd07f1a1871330f0bee4b596223cf9f58de545ac9e7a1c9f3fa37048573a0a57208fb358ef319276887fec7dcff3df6d1cbe5c80320c0b47b25b4ee8aa456d4fe68d971a7254e964b039d2abdce999f682deab5f8638545e2fbce9f8ab351874332300c6c1f08c97d7f11788824c3489e92394b833ea2bc4831c023a48400d5282a4116ade049eb4072131ecd78b36e62ad5c7a4777f5985192a41fdc5f67f435c3cf88cd5c0e8bf6afe1aacdfda46518f3d2d35365ef414c90181d88d9f3d533453b60c5860fac4097303120b65858d92f7069590bfe95a16556c1a3d2959629c205dfb1f5e90fb506f0812e34a9a7f928d176a57edeef33f3ed331b5a7f646ea799ac6be92ae3a9deb6e0c5e22714462523f1d196e3a7353cf73bba326bc2c5f0f98c2beb226f2fe2d5e7979c5d7792cb5dc61d10e86feb5dcf7cc00fe4ebc69451c7d3203a25d90702bcc0c4c5c675fb3e7605cc0eeda56210a92f0f28550387c1519c1cf8205afad3608ac96f7d8e857e6712ea38b17017d7148224e99b6cf7612d24630d28b3b3fe278e18c9b036b7cdae3440f1c6f7a96965fa423d2196751763654fbae9688792a19fd12097390e2013f1eaf57bd1226338bec7dcf9e0ebbc8a570cea7856a08d6c00522b98aae7c48cbbea62773bf66cd08ce72b154ead879c762736ef874869c8d176587bf7f4bda03845c43d0cd84dda632181b3636f4a14b91a464416582f12ef6761b319507f9e74fc24d70c66bd4cf7bf6f0e7cae7a932a96b9aec9cee1873dd1d35a80a2aee1d9cc074925559b8bbf0e9f5772fac4d6738f36479f631390aea94a96812fe651d9b3d5896cd89910ce3cf78490d1c874434a43d7c9dd24fc54de74090cf0b302a21be8942f1057bef175edd1cf6229059e777f53effc833178e4c88ffa08f1ed647ce575e6abc26a5aade790b181c936861c5f8ed6722ec84a43a21832957972832684e7e6498689f3abb78f2f84823e272b25f9a6e425a845b8333a83d08d521be9a9af1fde78bd70de54ebc1e58293ae11038d32c3ca8ac5b833a72a95ab251bc2ae11a5a0c611ca8c96dadf3ecb8bf5a5d50e47a665680b67d3ff3c427d3b5d5094d5dfab2fdf1d3693635bc22c946a62a2d482dc072cae1ee671beb8df147d1b099d7da37d3c413af71a75e77a236a1be10f3bafc8f4231347ac2902f0570b76ac7fb90d4dc2530afdf4364d1229e98f2d4dc3360e438663877b0c087108e9068367ab663a1a0bffcb663d61f4047ef9f906034d879fef1eefe48d30427d1976972c8236a5243a67ea0025987da2e80f172b32a638975853f26f8bc932487be81722756babf1650e182c07bd4c76d33106261db6769f9cf75869b212542440d14a69b2f118c95980cc2e69d0df802fc20a7ae2bf2146753894b92ddb87c8de59fcd4047ab09b22595f7e410810b89d40b2a64741009b4be258e4d7a655f59d13042467eb37e18dd4e5bf2a07455af6b8717294a7cda59d31e3444edcae18bb561ada2824adb0ae0620d935d3ee724e6c5ae3ae79acad04ac56f2632301912fbca0de68b6befc0018c1277c3a42f081682b69bcee5c8441f47c45b9146693ec8a6b935e66c99b2db8441db819b29af1a7eb4807becc40999438bfcebc8d6c78ebaaa4fa15e603fed563f6b930fce0ad747d93572e68af2b5de135d1882f7e0b47c9b2511137c727318b879d17e1cca17d12d28dcbfae7fa81b2e7eef237d51b03678c9b906e2a6eab2a630600af09cb3d04eea3a12827af4535f7c50d954eb88b0b10e86051d8033d134061c6f67d1f986af3ce9da9c5fd3b563976a729d039fa72567c749d50d3b3ce746d11f508a1ebd7389599420c4e012e7dbd986a40288b9be6e2939bfb75b4eebd334405532822daa32e85e2ab375d70ed8d9ba2badcc4250dc848cd8ff3358726fd8d04fde49f9b5f273ba3b37e8e6df0f46884a4f3ee6dc227c91b8caf4a5492cc336c6b1be8f1f81435416a09e6d155a39cb181b06b187d4943981e888fd169cfdd7e097bfd7a8aa4c3f3a6185c963cee12328850f97ca6d536de86d7e74263e620a0994f32cc09dcf3a4eea5f589c9b767039ba7121dfc1187c9a99fccc4b3b341c8c41705f08f06dcd61c8d2ff73b63f91cb99b40eeb21f4e65690851578a07b9b31710bd0f9b71d98117767a57dcae11aabfe93b5fb87d680bef7a2de954da595d0c4f49ce5a2d45d87d51e15c7cba5c93401d85fe1297c123d60573b17193ea17430b57591a51e7afb2534b11028dfb5ef4607f3d9f5235f05021d395f72864ccc83becd4e109b6a8cce14ba86dd75b301ffd2acac7a9c9bb35cf6bfdeb1e8c8f56fe3167184214d04c5411717b5421300277b517f387bd1f3874119e57b22742242b81ab65018f104e0d6396ea17d1f1ca48611c02c927755a8a4c09bd63af2f7223fd4fc1d57ab53f603285dd9e9540da4082256187c50b2d9ca8d055a2cae61f1a2249f86231cb9e0ef13237efbce5a36a040e31221fc74572bac84fc8023384b47f6fde437045db25ea33e26df7abaf144efdb05ee1b96c95c6f088fb5027cc6d375301c9f9c7f8186f55e09e19f045cebd0dc7e8d4ad43bc2539cb619994a564807638ecd6211917d43a9afaeaafe58472314b9baa1ce9ba6495d90346af8f52c037936ea66d7393cf79dbcc0639ea6ed093df58055003226a44f1c3d4b21cb2b4925b30b567c888c0af70224cfb32dc70038df637cc1f23748c6cfe690a5be6fc76a3781a69db413bb92c7d3812cdea9e63d39865364ff9aeb8d1e8357184a4c5d08c7bf7303b01acef09d417552ac6d2bc1fe2132fb2d836437b55e1aed40809db2b2163e31f4ae78b3409ac6f79c96fbf391a9cd298843fcc572c8bbd1bf739b88e0dbabb3e82824a894e5465b7a67602d41e682f6f7dc0f1a0f1048cd945912e8cb3fdce312fb245653d56de7b49c66bd722f4d9a50f28b2e90954f86f93c4072c3881b7a108ab16e7c3a4b7df172741774772e22083963a16c5ca4c7b07611451a0c0603d89d731908352e97855983def85a6e0218e6753afdd787790763a91417dd396c19b74da6f3277e2f6e771977b0db1bc875269cb94b92c747c77edf79cb00e3cff95550e279e78b5cefd4dd2e4561b625550e3f80b75abd840f08e86fc233552b70e9cd6ddb71f2f5effdeb950e03fa3c261585252f76116550102073610820ae9f98ff86fd83cedacce9657480e913a93fa36020d52bb3835aafa92048bd7a52988ead550a0e03efd546b8826962ebbb07b57899067a9fe455ec3df86b0e57477fb87816ea63662f52df221f61ac52f208f140e9cb525bec09225ba6af0ab7854b236949a31a9d3855516bda811412a772cdbe62ad27fbaa0e012b97610b3ba6a8fe0edc5962a9fb7cca652a87efe81e0eefac379f229261e35c7cfe025ecc12a32518c8b28b1f69d5e3650e33da460ed186b4a913c5943d0274ae4d659ac0a91d2bc685d47b157034447aa7761c493f3663d22dda3a590588348942c689f401f17bcebea7ed399f445b2dbafb9c77d332bbd24e858657e6c7a7ee331aed150abc2aadd352e3abd59f7b77c62317e51bb21249fa8905e2608162307a418052299fa9ab051e9d2b0067300b0820b7a11fef103098d602bbeb456bb20e33dbbe32a476a27fdb71361d85ee9b2a264021439aa471410bef2686c03842434d14d8b93ca60c4c0281da4ae93748096df8b4e21f3c11b2c3e6f5b6ac96ac8079073d18bb0aaaeff933ea51cceac2746509b2c70574d14b31cce44099670e1e58a701c4d55132c5593927f1457ddda8110a76b3dcf0e10d77ddf21593e43eb98e6c09d628114da0aa06a8d162a1f8e4d5e1320c3824bcccf3c1ce3a4d9875ebc1fb38855a98d8c39d9015abca386c0b56b983261510c639e366990c1c89d3a1f74864f1ef13b15f94c2efd7fbb28bc6ea75c4ac66b6aef012ea577f579ad2d4e34543945c9c854ccda362f15a2d4189f2849495878f08d50277d3306953e5b64d6bbdd63d277a4e096ee586852eb2d58e16b923dd569abf53475f1a61f31bf22bcbb3af5c8 è¯·è¾“å…¥å¯†ç æŸ¥çœ‹.","link":"/2019/09/15/master-complaints/"},{"title":"sort","text":"æ’åºç®—æ³•ç®€å•å®ç°äº†ä¸€ä¸‹å‡ ç§å¸¸è§çš„å†…æ’åºç®—æ³• å¸Œå°”æ’åº å½’å¹¶æ’åº å¿«é€Ÿæ’åº å †æ’åº åŸºæ•°æ’åº æ¡¶æ’åº æ’åºç®—æ³• å¹³å‡æ‰§è¡Œæ•ˆç‡ ç¨³å®šæ€§ å¤‡æ³¨ æ’å…¥æ’åº o(n^2) ç¨³å®š æˆ‘è§‰å¾—è¿™ä¸ªç¨³å®šæ€§å–å†³äºå®ç°çš„æ—¶å€™çš„åœæ­¢æ¡ä»¶ å†’æ³¡æ’åº o(n^2) ç¨³å®š é€‰æ‹©æ’åº o(n^2) éç¨³å®š å› ä¸ºé€‰æ‹©æœ€å° or æœ€å¤§å…ƒç´ äº¤æ¢çš„æ—¶å€™å›æ”¹å˜åŸæ¥çš„é¡ºåº å¸Œå°”æ’åº o(nlogn) ç¨³å®š å¸Œå°”æ’åºæ˜¯ä¸€ä¸ªæ ¹æ®æ­¥é•¿çš„æ¥çš„æ’å…¥æ’åº å¿«æ’ o(nlogn) éç¨³å®š åˆ†æ²»çš„æ–¹æ³•ï¼Œé€’å½’çš„å¤„ç†å­æ•°ç»„ï¼Œæ¯æ¬¡å¯»æ‰¾åˆ°ä¸€ä¸ªæ•°å­—çš„ä½ç½® å †æ’åº o(nlogn) éç¨³å®š ç”¨å¤§é¡¶å † or å°é¡¶å †å®ç°ï¼Œè°ƒæ•´å †çš„æœ‰åºæ€§éœ€è¦ logn çš„æ—¶é—´ å½’å¹¶æ’åº o(nlogn) ç¨³å®š ä½¿ç”¨åˆ†æ²»ï¼Œæ¯æ¬¡åˆå¹¶ä¸¤ä¸ªå·²ç»æœ‰åºçš„æ•°ç»„ å¸Œå°”æ’åºå¸Œå°”æ’åºå®é™…ä¸Šå°±æ˜¯å¸¦æ­¥é•¿çš„æ’å…¥æ’åºã€‚ä¸åŒäºæ’å…¥æ’åºæŒ‰ç…§æ­¥é•¿ä¸º 1 è¿›è¡Œæ’åºï¼Œå¸Œå°”æ’åºé‡‡ç”¨äº†ç¼©è¿›çš„æ­¥é•¿ã€‚æ¯æ¬¡åªåœ¨ç›¸åŒæ­¥é•¿çš„ä¸€ç»„æ•°æ®ä¸­è¿›è¡Œæ’åºã€‚ å‚è€ƒç»´åŸºç™¾ç§‘çš„è§£é‡Šï¼Œä¾‹å¦‚å¯¹äºæ•°ç»„ []int{1,5,4,2,7,45,75,3,4,87} æ’åºï¼Œé€‰å–æ­¥é•¿ä¸º len() / 2ï¼Œä¸”æ¯æ¬¡æ­¥é•¿ç¼©è¿›ä¸€åŠ å…¶æ’åºçš„è¿‡ç¨‹å¦‚ä¸‹ ç¬¬ä¸€æ¬¡åˆ†ç»„ ï¼ˆæ­¥é•¿ä¸º 5ï¼‰ æ’åºå‰ 1 5 4 2 7 45 75 3 4 87 è°ƒç”¨æ’å…¥æ’åº å¯¹ç«–ç€çš„æ•°ç»„è¿›è¡Œæ’åº 1 5 3 2 7 45 75 4 4 87 ç¬¬äºŒæ¬¡åˆ†ç»„ (æ­¥é•¿ä¸º 2) æ’åºå‰çš„æ•°ç»„ä¸º {1,5,3,2,7,45,75,4,4,87}ï¼Œå› æ­¤åˆ†ç»„ä¸º 1 5 3 2 7 45 75 4 4 87 æ’å…¥æ’åº 1 2 3 4 4 5 7 45 75 87 ç¬¬ä¸‰æ¬¡åˆ†ç»„ ï¼ˆæ­¥é•¿ä¸º 1ï¼‰ æ­¥é•¿ä¸º 1 ç›¸å½“äºæ’å…¥æ’åº ç›´æ¥æ’åºå³å¯ 123456789101112131415161718192021222324252627package sort// shell æ’åºæ˜¯ä¸€ä¸ªæŒ‰ç…§æ­¥é•¿çš„æ’åº// å…¶æœ¬è´¨æ˜¯ä¸€ä¸ªä¼˜åŒ–äº†æ­¥é•¿çš„æ’å…¥æ’åºfunc shellSort(nums []int) { if nums == nil || len(nums) == 0 { return } step := len(nums) / 2 // æ­¥é•¿ä¸åœçš„ç¼©çŸ­ ç›´åˆ°æœ€åæˆä¸ºæ’å…¥æ’åºï¼ˆä½†æ˜¯æ’å…¥æ’åºè¿™ä¸ªæ—¶å€™å·²ç»åŸºæœ¬æœ‰åº æ‰€ä»¥è·Ÿå®Œå…¨ä¹±åºçš„ç›¸æ¯” ä¼šæœ‰æ¯”è¾ƒå¤§çš„æ€§èƒ½æå‡ï¼‰ for step &gt;= 1 { // æ’å…¥æ’åº for i := step; i &lt; len(nums); i++ { exchange := nums[i] j := i - step // å°† i ä½ç½®çš„æ•° æ’å…¥åˆ° ä»¥ step ä¸ºæ­¥é•¿çš„æ•°ç»„ä¸­é—´ for ; j &gt;= 0 &amp;&amp; exchange &lt; nums[j]; j -= step { nums[j + step] = nums[j] } // ä¸Šé¢å·²ç»æŠŠæ•°æ®è¿ç§»å®Œæ¯• åªéœ€è¦åœ¨ j+step å³ç»“æŸè¿ç§»çš„ä½ç½® æŠŠéœ€è¦æ’å…¥çš„æ•°æ®æ’å…¥å³å¯ nums[j + step] = exchange } step /= 2 }} å½’å¹¶æ’åº1234567891011121314151617181920212223242526272829303132333435363738394041424344package sortfunc mergeSort(nums []int, i, j int) { if i &gt;= j { return } mid := (i + j) / 2 mergeSort(nums, i, mid) mergeSort(nums, mid+1, j) // è¿™ä¸€æ­¥ i -&gt; mid mid + 1 -&gt; j å·²ç»æ˜¯æœ‰åºçš„äº† merge(nums, i, mid, j)}func merge(nums []int, i, mid, j int) { tmp, index := make([]int, j-i+1), 0 iStart, jStart := i, mid+1 for iStart &lt;= mid &amp;&amp; jStart &lt;= j { if nums[iStart] &gt; nums[jStart] { tmp[index] = nums[jStart] jStart++ } else { tmp[index] = nums[iStart] iStart++ } index++ } for iStart &lt;= mid { tmp[index] = nums[iStart] index++ iStart++ } for jStart &lt;= j { tmp[index] = nums[jStart] index++ jStart++ } for m, n := 0, i; m &lt; len(tmp); m, n = m+1, n+1 { nums[n] = tmp[m] }} é“¾è¡¨çš„å½’å¹¶æ’åºå…¶å®æ€æƒ³è·Ÿæ™®é€šçš„å½’å¹¶æ’åºåŸºæœ¬ä¸€æ ·ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ã€‚å½’å¹¶åˆ†é“¾è¡¨çš„æ—¶å€™ï¼Œè¦ç›´æ¥æˆªæ–­é“¾è¡¨ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func sortList(head *ListNode) *ListNode { return mergeSort(head)}func mergeSort(head *ListNode) *ListNode { if head == nil || head.Next == nil { return head } mid := divideList(head) return mergeTwoListNode(mergeSort(head), mergeSort(mid))}func mergeTwoListNode(left, right *ListNode) *ListNode { res := new(ListNode) mov := res for left != nil &amp;&amp; right != nil { if left.Val &gt; right.Val { mov.Next = right right = right.Next } else { mov.Next = left left = left.Next } mov = mov.Next } if left != nil { mov.Next = left } if right != nil { mov.Next = right } return res.Next}// divideList ä¼šæŠŠ list åˆ†ä¸ºä¸¤ä¸ª list// ä¼šæˆªæ–­åŸæ¥çš„ nodefunc divideList(node *ListNode) *ListNode { if node == nil || node.Next == nil { return node } fast := node.Next for fast != nil &amp;&amp; fast.Next != nil { fast = fast.Next.Next node = node.Next } mid := node.Next node.Next = nil return mid} å¯»æ‰¾é€†åºæ•°å¯¹leet code åŒ…å«ä¸€ä¸ªé€†åºæ•°å¯¹çš„ä¾‹é¢˜ï¼Œ315. è®¡ç®—å³ä¾§å°äºå½“å‰å…ƒç´ çš„ä¸ªæ•° æ‰¾åˆ°å½“å‰æ•°å­—å³ä¾§çš„å°äºè¿™ä¸ªæ•°çš„æ•°é‡ï¼Œå®é™…ä¸Šå°±æ˜¯å»æ‰¾åˆ° å½“å‰è¿™ä¸ªæ•° å¤§äº åé¢å¤šå°‘æ•°çš„æ•°é‡ï¼Œä¸€å¤§ä¸€å°ï¼Œå³æ„æˆé€†åºæ•°å¯¹ï¼Œæ‰€ä»¥å¯ä»¥ç”¨å½’å¹¶æ¥åš 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;public class CountRightSmaller_315 { public List&lt;Integer&gt; countSmaller(int[] nums) { int n = nums.length; int[] res = new int[n], indexes = new int[n]; // ä¿å­˜åŸå§‹æ•°ç»„çš„æ•°ç»„ å¥½åœ¨ res æ•°ç»„ä¸­å®šä½ for (int i = 0; i &lt; n; i++) { indexes[i] = i; } mergeSort(nums, 0, n - 1, res, indexes); return Arrays.stream(res).boxed().collect(Collectors.toList()); } public void mergeSort(int[] nums, int i, int j, int[] res, int[] indexes) { if (i &gt;= j) return; int mid = i + (j - i) / 2; mergeSort(nums, i, mid, res, indexes); mergeSort(nums, mid + 1, j, res, indexes); merge(nums, i, mid, j, res, indexes); } public void merge(int[]nums, int start, int mid, int end, int[] res, int[] indexes) { int i = start, j = mid + 1; int[] tmp = new int[end - start + 1], tmpIndexes = new int[end - start + 1]; int index = 0; while (i &lt;= mid &amp;&amp; j &lt;= end) { if (nums[i] &lt;= nums[j]) { // è¯´æ˜ j ä¹‹å‰ç›¸å½“äº i æ¥è¯´éƒ½æ˜¯é€†åºäº† tmp[index] = nums[i]; res[indexes[i]] += j - mid - 1; tmpIndexes[index++] = indexes[i++]; } else { // nums[j] &lt; nums[i] tmp[index] = nums[j]; tmpIndexes[index++] = indexes[j++]; } } while (i &lt;= mid) { // è¯´æ˜ j ä¹‹å‰ç›¸å½“äº i æ¥è¯´éƒ½æ˜¯é€†åºäº† tmp[index] = nums[i]; res[indexes[i]] += j - mid - 1; tmpIndexes[index++] = indexes[i++]; } while (j &lt;= end) { tmp[index] = nums[j]; tmpIndexes[index++] = indexes[j++]; } index = 0; while (start &lt;= end) { nums[start] = tmp[index]; indexes[start++] = tmpIndexes[index++]; } } public static void main(String[] args) { System.out.println(new CountRightSmaller_315().countSmaller(new int[]{-1, -1})); }} å¿«é€Ÿæ’åº12345678910111213141516171819202122232425262728293031323334353637383940414243444546package sortfunc QuickSort(nums []int, i, j int) { if i &gt;= j { return } p := partition(nums, i, j) QuickSort(nums, i, p-1) QuickSort(nums, p+1, j)}func partition(nums []int, start, end int) int { base := nums[start] i, j := start, end+1 for true { i++ for i &lt; len(nums) &amp;&amp; nums[i] &lt; base { i++ } j-- for j &gt;= 0 &amp;&amp; nums[j] &gt; base { j-- } if i &gt;= j { break } swap(nums, i, j) } swap(nums, start, j) return j}func swap(nums []int, i, j int) { if nums[i] == nums[j] { return } nums[i] = nums[i] ^ nums[j] nums[j] = nums[i] ^ nums[j] nums[i] = nums[i] ^ nums[j]} å †æ’åº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package sortfunc defaultCompare(a, b int) bool { return a &gt; b}// Heap æ ¹æ®è¾“å…¥çš„ compare æ„å»ºä¸åŒçš„å †// é»˜è®¤å°é¡¶å † -&gt; ä»å¤§åˆ°å°æ’åˆ—type Heap struct { nums []int compare func(a, b int) bool}// shiftDown ç§»åŠ¨é¡¶å±‚çš„å‘ä¸‹func (h *Heap) shiftDown(k, n int) { for 2*k+1 &lt;= n { j := 2*k + 1 // æ³¨æ„è¿™ä¸ªåœ°æ–¹ å¤§é¡¶å †çš„æ—¶å€™ å› ä¸ºéœ€è¦æŠŠå°çš„ä¸œè¥¿å¾€ä¸‹æ²‰ æ‰€ä»¥éœ€è¦é€‰æ‹©çš„æ˜¯ å­èŠ‚ç‚¹ä¸­ çš„è¾ƒå¤§å€¼ // å°é¡¶å †çš„æ—¶å€™ ç”±äºéœ€è¦æŠŠå¤§çš„ä¸œè¥¿å¾€ä¸‹æ²‰ æ‰€ä»¥éœ€è¦é€‰å–çš„æ˜¯è¾ƒå°å€¼ ï¼ˆå› ä¸ºæ¯”è¾ƒå°å€¼å° è¿™ä¸ªèŠ‚ç‚¹ä¸€å®šæ¯”ä¸¤ä¸ªèŠ‚ç‚¹éƒ½å°ï¼‰ if j+1 &lt;= n &amp;&amp; h.compare(h.nums[j],h.nums[j+1]) { j++ } if h.compare(h.nums[j], h.nums[k]) { break } swap(h.nums, k, j) k = j }}// popUp æœ€ä¸‹é¢çš„æµ®åŠ¨åˆ°æœ€ä¸Šé¢func (h *Heap) popUp(k int) { for k &gt;= 0 { var father int if k%2 == 1 { father = k / 2 } else { father = k/2 - 1 } if h.compare(h.nums[k], h.nums[father]) { break } swap(h.nums, father, k) k = father }}func NewHeap(nums []int) *Heap { return &amp;Heap{nums: nums, compare: defaultCompare}}func NewHeapWithCompare(nums []int, compare func(a, b int) bool) *Heap { return &amp;Heap{nums: nums, compare: compare}}func (h *Heap) Sort() { n := len(h.nums) - 1 // é¦–å…ˆå°†è¾“å…¥æ„é€ æˆå † for i := n / 2; i &gt;= 0; i-- { h.shiftDown(i, n) } // è¿™æ ·æ’åºæ˜¯å§æœ€å°çš„æ’åœ¨åé¢ for n &gt;= 0 { swap(h.nums, 0, n) n-- h.shiftDown(0, n) }}func swap(nums []int, i, j int) { if nums[i] == nums[j] { return } nums[i] = nums[i] ^ nums[j] nums[j] = nums[i] ^ nums[j] nums[i] = nums[i] ^ nums[j]} åŸºæ•°æ’åºåŸºæ•°æ’åºçš„æ€ç»´å¾ˆç®€å•ï¼Œå°±æ˜¯æ ¹æ®æ•°å­—çš„æ¯ä¸€ä½æ¥æ’åº é¦–å…ˆæ’åºä¸ªä½ï¼Œæ ¹æ®ä¸ªä½æ•°å­— åˆ†åˆ«æ”¾åˆ° ç¼–å· 0-9 çš„æ¡¶é‡Œé¢ ç„¶åå†æ’åºåä½ï¼Œæœ€åç›´åˆ°æœ€å¤§çš„æ•°å­—ä¹Ÿä¸º 0 å³å¯åœæ­¢ 1234567891011121314151617181920212223242526272829303132333435363738394041424344func maximumGap(nums []int) int { if len(nums) &lt; 2 { return 0 } biggest := nums[0] for _, num := range nums { biggest = max(biggest, num) } // åŸºæ•°æ’åºçš„æ¡¶ åˆ†ä¸º 0 - 9 lists := make([][]int, 10) base := 1 for biggest &gt; 0 { // æ¯æ¬¡å¾ªç¯å‰éƒ½é‡ç½® for i := 0; i &lt; 10; i++ { lists[i] = make([]int, 0) } // æ’åºæ•°ç»„ for _, num := range nums { i := num / base % 10 lists[i] = append(lists[i], num) } // æ ¹æ®æ¯è½®çš„é¡ºåº é‡æ–°èµ‹å€¼ nums æ•°ç»„ for i, index := 0, 0; i &lt; 10; i++ { for j := 0; j &lt; len(lists[i]); j++ { nums[index] = lists[i][j] index++ } } biggest /= 10 base *= 10 } res := 0 for i := 0; i &lt; len(nums)-1; i++ { res = max(res, nums[i+1]-nums[i]) } return res} æ¡¶æ’åºæ¡¶æ’åºä¹Ÿå¾ˆç®€å• ç›´æ¥æ ¹æ®æœ€å¤§å°å€¼åˆ†æ¡¶ ç„¶åæ ¹æ®å…¶æ•°å€¼æ”¾åˆ°ä¸åŒçš„æ¡¶é‡Œé¢ æ’åº åªéœ€è¦éå†æ¡¶çš„ ä¸‹æ ‡å³å¯ 1234567891011121314151617181920212223242526272829303132333435363738func maximumGapWithBucket(nums []int) int { if len(nums) &lt; 2 { return 0 } smallest, biggest := math.MaxInt32, math.MinInt32 for _, num := range nums { smallest = min(smallest, num) biggest = max(biggest, num) } // æ¡¶æ’åº counts := make([]int, biggest - smallest + 1) for _, num := range nums { counts[num-smallest]++ } res := 0 var pre *int for i, num := range counts { // è¡¨ç¤ºæ²¡æœ‰æ•°å­— if num == 0 { continue } if pre == nil { tmp := i pre = &amp;tmp continue } // æ¯”è¾ƒ res = max(res, i - *pre) tmp := i pre = &amp;tmp } return res}","link":"/2021/02/24/sort/"},{"title":"ç®€å•å›¾ç®—æ³•","text":"å›¾ç®—æ³•ç®€å•å®ç°äº†æ— å‘å›¾ã€æ— å‘åŠ æƒå›¾ã€æœ‰å‘å›¾ã€æœ‰å‘åŠ æƒå›¾çš„å‡ ç§ç®—æ³•ï¼ŒåŒ…æ‹¬: éå† dfs bfs åº”ç”¨ ç¯å›¾ æ‹“æ‰‘æ’åº åŒè‰²é—®é¢˜ æœ€å°ç”Ÿæˆæ ‘ prim krusal æœ€çŸ­è·¯å¾„ Dijkstra æ‹“æ‰‘æ’åºéå† bellemanFord å›¾çš„æ•°æ®ç»“æ„ä»¥ä¸‹å‡ä½¿ç”¨é‚»æ¥è¡¨æ ‡è¯† æ— å‘å›¾ æ— å‘å›¾è®¾è®¡å¾—æœ‰ç‚¹å°´å°¬ å…¶å®æ²¡å¿…è¦ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class UndirectedGraph&lt;T&gt; implements Graph&lt;T&gt; { public HashMap&lt;T, UndirectedNode&lt;T&gt;&gt; map; public UndirectedGraph() { this.map = new HashMap&lt;&gt;(); } public Set&lt;T&gt; keys() { return map.keySet(); } // æ— å‘å›¾ ä¸¤ééƒ½è¦åŠ  public void addEdge(T from, T to) { if (!map.containsKey(from)) { map.put(from, new UndirectedNode&lt;&gt;(to)); } UndirectedNode&lt;T&gt; temp = map.get(from); // è¯´æ˜åŠ å…¥äº†é‡å¤è¾¹ if (!temp.addNode(to)) return; if (!map.containsKey(to)) { map.put(to, new UndirectedNode&lt;&gt;(from)); } UndirectedNode&lt;T&gt; tempTo = map.get(to); tempTo.addNode(from); } public Node&lt;T&gt; adjacent(T from) { return this.map.getOrDefault(from, null); }}public class UndirectedNode&lt;T&gt; implements Node&lt;T&gt; { public T to; public UndirectedNode&lt;T&gt; next; public UndirectedNode(T to) { this.to = to; this.next = null; } /** * * @param to * @return boolean è¡¨ç¤ºæ˜¯å¦åŠ å…¥æˆåŠŸ */ public boolean addNode(T to) { // åŠ å…¥ç¬¬ä¸€ä¸ªèŠ‚ç‚¹çš„æ—¶å€™çš„åˆ¤æ–­ if (this.to == to) return true; UndirectedNode&lt;T&gt; temp = this.next; // åŠ å…¥ç¬¬äºŒä¸ªèŠ‚ç‚¹æ—¶çš„åˆ¤æ–­ if (temp == null) { this.next = new UndirectedNode&lt;&gt;(to); return true; } while (temp.next != null) { if (temp.to == this.to) return false; temp = temp.next; } temp.next = new UndirectedNode&lt;&gt;(to); return true; }} æœ‰å‘å›¾ 12345678910111213141516171819202122232425262728293031323334353637public class DirectedGraph { public int getCapacity() { return capacity; } private int capacity; private List&lt;LinkedList&lt;Integer&gt;&gt; nodes; public DirectedGraph(int capacity) { this.capacity = capacity; this.nodes = new ArrayList&lt;&gt;(capacity); for (int i = 0; i &lt; capacity; i++) { nodes.add(new LinkedList&lt;&gt;()); } } public LinkedList&lt;Integer&gt; adj(int node) { return this.nodes.get(node); } public void addEdge(int from, int to) { this.nodes.get(from).add(to); } public DirectedGraph reverse() { DirectedGraph reversed = new DirectedGraph(this.capacity); for (int from = 0; from &lt; this.capacity; from++) { for (Integer to : adj(from)) { if (to != null) { reversed.addEdge(to, from); } } } return reversed; }} åŠ æƒæ— å‘å›¾ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class UndirectedWeightGraph { public int getCapacity() { return capacity; } private int capacity; // é‚»æ¥è¡¨ private List&lt;LinkedList&lt;Edge&gt;&gt; nodes; public UndirectedWeightGraph(int capacity) { this.capacity = capacity; this.nodes = new ArrayList&lt;&gt;(capacity); for (int i = 0; i &lt; capacity; i++) { this.nodes.add(new LinkedList&lt;&gt;()); } } public LinkedList&lt;Edge&gt; adj(int node) { return this.nodes.get(node); } public void addEdge(int from, int to, int weight) { Edge edge = new Edge(from, to, weight); this.nodes.get(from).add(edge); this.nodes.get(to).add(edge); }}public class Edge { public int from; public int to; public int weight; public Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } // æ ¹æ®ä¼ å…¥çš„å€¼ è¿”å›ä¸åŒçš„ from to public int other(int in) { // æ ¹æ®ä¼ å…¥çš„ç«¯ç‚¹ æ‰¾åˆ°é“¾æ¥çš„å¦å¤–ä¸€ä¸ªæ–­ç‚¹ if (in == from) { return to; } return from; } @Override public String toString() { return &quot;Edge{&quot; + &quot;from=&quot; + from + &quot;, to=&quot; + to + &quot;, weight=&quot; + weight + '}'; }} åŠ æƒæœ‰å‘å›¾ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class Edge { int from, to; int weight; public Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } public int getFrom() { return from; } public void setFrom(int from) { this.from = from; } public int getTo() { return to; } public void setTo(int to) { this.to = to; } public int getWeight() { return weight; } public void setWeight(int weight) { this.weight = weight; } @Override public String toString() { return &quot;Edge{&quot; + &quot;from=&quot; + from + &quot;, to=&quot; + to + &quot;, weight=&quot; + weight + '}'; }}public class DirectedWeightGraph { public int getCapacity() { return capacity; } int capacity; List&lt;List&lt;Edge&gt;&gt; nodes; public DirectedWeightGraph(int capacity) { this.capacity = capacity; this.nodes = new ArrayList&lt;&gt;(this.capacity); for (int i = 0; i &lt; capacity; i++) { this.nodes.add(new LinkedList&lt;&gt;()); } } // æœ‰å‘å›¾åªç”¨åŠ å…¥ä¸€é public void addEdge(int from, int to, int weight) { this.nodes.get(from).add(new Edge(from, to, weight)); } public void addEdge(Edge edge) { this.nodes.get(edge.from).add(new Edge(edge.from, edge.to, edge.weight)); } public List&lt;Edge&gt; adj(int node) { return this.nodes.get(node); } // è¿”å›æ‰€æœ‰çš„è¾¹ public List&lt;Edge&gt; edges() { List&lt;Edge&gt; res = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; capacity; i++) { res.addAll(this.nodes.get(i)); } return res; }} å›¾çš„éå†æ–¹æ³•ä»¥æ— çº¿å›¾ä¸ºä¾‹ï¼Œæœ‰å‘å›¾å’Œæ— å‘å›¾çš„éå†åŸºæœ¬ä¸€æ · DFS DFS å³ä½¿ç”¨æ ˆçš„æ€æƒ³ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class DFS { public static &lt;T&gt; void DFSWithRecursion(Graph&lt;T&gt; graph) { Set&lt;T&gt; memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!memo.contains(start)) DFSWithRecursion(graph, start, memo); } } public static &lt;T&gt; void DFSWithoutRecursion(Graph&lt;T&gt; graph) { Set&lt;T&gt; memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!memo.contains(start)) DFSWithOutRecursion(graph, start, memo); } } public static &lt;T&gt; void DFSWithRecursion(Graph&lt;T&gt; graph, T start, Set&lt;T&gt; memo) { System.out.println(start); UndirectedNode&lt;T&gt; node = (UndirectedNode&lt;T&gt;) graph.adjacent(start); memo.add(start); while (node != null) { if (!memo.contains(node.to)) DFS.DFSWithRecursion(graph, node.to, memo); node = node.next; } } public static &lt;T&gt; void DFSWithOutRecursion(Graph&lt;T&gt; graph, T start, Set&lt;T&gt; memo) { LinkedList&lt;T&gt; stack = new LinkedList&lt;&gt;(); stack.add(start); memo.add(start); while (stack.size() != 0) { T top = stack.removeLast(); System.out.println(top); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) graph.adjacent(top); while (temp != null) { if (!memo.contains(temp.to)) { stack.add(temp.to); memo.add(temp.to); } temp = temp.next; } } }} BFS bfs ä½¿ç”¨é˜Ÿåˆ—çš„æ€æƒ³ 12345678910111213141516171819202122232425262728public class BFS { public static &lt;T&gt; void BFS(Graph&lt;T&gt; graph) { Set&lt;T&gt; memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!memo.contains(start)) BFS(graph, start, memo); } } public static &lt;T&gt; void BFS(Graph&lt;T&gt; graph, T start, Set&lt;T&gt; memo) { LinkedList&lt;T&gt; queue = new LinkedList&lt;&gt;(); queue.add(start); memo.add(start); while (!queue.isEmpty()) { T first = queue.removeFirst(); System.out.println(first); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) graph.adjacent(first); while (temp != null) { if (!memo.contains(temp.to)) { queue.add(temp.to); memo.add(temp.to); } temp = temp.next; } } }} å›¾éå†æ–¹æ³•çš„åº”ç”¨æ— å‘å›¾è¿é€šåˆ†é‡12345678910111213141516171819202122232425262728293031323334353637// è¿é€šåˆ†é‡public class Connected&lt;T&gt; { // å¦‚æœè¿ä¸ªç«¯ç‚¹å±äºä¸€ä¸ªè¿é€šåˆ†é‡ // ä»–ä»¬çš„idåº”è¯¥æ˜¯ä¸€æ ·çš„ public HashMap&lt;T, Integer&gt; ids; public int count = 0; public Graph&lt;T&gt; graph; public Set&lt;T&gt; memo; public Connected(Graph&lt;T&gt; graph) { this.ids = new HashMap&lt;&gt;(); this.graph = graph; this.memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!this.memo.contains(start)) { dfs(start); count++; } } } public void dfs(T start) { this.memo.add(start); ids.put(start, this.count); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) this.graph.adjacent(start); while (temp != null) { if (!memo.contains(temp.to)) dfs(temp.to); temp = temp.next; } } public boolean connected(T from, T to) { return ids.get(from).equals(ids.get(to)); }} æˆç¯æ£€æµ‹1234567891011121314151617181920212223242526272829303132public class CheckCycle&lt;T&gt; { // memo è®°å½•åœ¨dfsçš„è¿‡ç¨‹ä¸­çš„èŠ‚ç‚¹ public Set&lt;T&gt; memo; public Graph&lt;T&gt; graph; public boolean hasCycle = false; public CheckCycle(Graph&lt;T&gt; graph) { this.graph = graph; this.memo = new HashSet&lt;&gt;(); for (T start : graph.keys()) { if (!this.memo.contains(start)) { dfs(start, start); } } } public void dfs(T start, T parent) { memo.add(start); UndirectedNode&lt;T&gt; temp = (UndirectedNode&lt;T&gt;) graph.adjacent(start); while (temp != null) { if (!memo.contains(temp.to)) dfs(temp.to, start); // å› ä¸ºæ˜¯æ— å‘å›¾ å› æ­¤åœ¨è®¿é—®çš„æ—¶å€™ ä¼šåœ¨å­èŠ‚ç‚¹ä¸Š é‡æ–°è®¿é—®çˆ¶èŠ‚ç‚¹è¿‡æ¥çš„é‚£æ¡è¾¹ å› æ­¤è¿™æ ·è®°å½•çˆ¶èŠ‚ç‚¹å³å¯ else if(temp.to != parent) hasCycle = true; temp = temp.next; } }} æ‹“æ‰‘æ’åºæ‹“æ‰‘æ’åºå¯¹äºæ’é˜Ÿã€è¯¾ç¨‹å®‰æ’ä¹‹ç±»çš„æœ‰å¸®åŠ©ï¼Œå…¶åŸºäºæœ‰å‘å›¾å®ç° é¦–å…ˆè¦åšçš„å°±æ˜¯æœ‰å‘å›¾æˆç¯æ£€æµ‹ï¼Œå› æ­¤æˆç¯æ˜¯æ²¡æœ‰ æ‹“æ‰‘æ’åº çš„ æœ‰å‘å›¾æˆç¯æ£€æµ‹ 1234567891011121314151617181920212223public void DFS(DirectedGraph g) { boolean[] memo = new boolean[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { if (!memo[i]) { DFSRecursion(g, i, memo, new boolean[g.getCapacity()]); } } }private void DFSRecursion(DirectedGraph g, int start, boolean[] memo, boolean[] marked) { memo[start] = true; System.out.printf(&quot;%s &quot;, start); marked[start] = true; for (int i : g.adj(start)) { if (!marked[i]) { DFSRecursion(g, i, memo, marked); } else { // å·²ç»æˆç¯ this.cycle = true; } } marked[start] = false;} æ‹“æ‰‘æ’åº æœ‰ä¸¤ç§æ–¹æ³• é€†åç»­æ’åˆ—ã€‚å› ä¸ºè¦æ‰¾åˆ° v-&gt;w è¿™ç§æ‹“æ‰‘ç»“æœï¼Œé‚£ä¹ˆåœ¨è®¿é—®å®Œ V ä¹‹å è®¿é—® W å³å…¶è¿æ¥èŠ‚ç‚¹ï¼Œç”¨ stack æ¥ä¿å­˜è®¿é—®é¡ºåºï¼Œå†å¼¹å‡ºæ ˆ å°±å¯ä»¥å¾—åˆ° v -&gt; w çš„é¡ºåº 12345678910111213141516171819202122232425262728public static List&lt;Integer&gt; topologySortWithRecursion(DirectedGraph g) { // ä½œä¸ºä¸€ä¸ªæ ˆ List&lt;Integer&gt; stack = new ArrayList&lt;&gt;(); boolean[] memo = new boolean[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { if (!memo[i]) { // æ ¹æ®ä¸€ä¸ªå‡ºå‘ç‚¹ æ‰¾åˆ°å…¶ æ‹“æ‰‘æ’åº topologySortRecursion(g, stack, i, memo); } } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); // è¾“å‡º stack for (int i = stack.size() - 1; i &gt;= 0; i--) { res.add(stack.get(i)); } return res;}private static void topologySortRecursion(DirectedGraph g, List&lt;Integer&gt; res, int start, boolean[] memo) { memo[start] = true; for (int adj : g.adj(start)) { if (!memo[adj]) { topologySortRecursion(g, res, adj, memo); } } res.add(start);} éå†å…¥åº¦ä¸º 0 çš„ç‚¹ï¼Œå› ä¸ºèƒ½å¤Ÿä½œä¸ºå¼€å§‹èŠ‚ç‚¹çš„ç‚¹ï¼Œä¸€å®šå…¥åº¦ä¸º 0ï¼Œé‚£ä¹ˆä¸åœçš„éå†ï¼Œåˆ é™¤è¾¹ï¼Œç»´æŠ¤ä¸€ä¸ªå…¥åº¦ä¸º 0 çš„ç‚¹çš„ collection æ—¢å¯æ‰¾åˆ°è®¿é—®é¡ºåº 123456789101112131415161718192021222324252627282930313233343536// 2. ä¸åœåœ°éå†å…¥åº¦ä¸º 0 çš„ç‚¹ ç„¶ååˆ é™¤public static List&lt;Integer&gt; topologySortIteration(DirectedGraph g) { int[] inDegree = new int[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { for (int adj : g.adj(i)) { inDegree[adj] += 1; } } Deque&lt;Integer&gt; inDegreeEqualsZero = new LinkedList&lt;&gt;(); // æ‰¾åˆ°ä¸º 0 çš„ç‚¹ for (int i = 0; i &lt; g.getCapacity(); i++) { if (inDegree[i] == 0) { inDegreeEqualsZero.offer(i); } } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while (!inDegreeEqualsZero.isEmpty()) { int top = inDegreeEqualsZero.poll(); res.add(top); for (int adj : g.adj(top)) { inDegree[adj] -= 1; if (inDegree[adj] == 0) { inDegreeEqualsZero.offer(adj); } } } return res;} æœ‰å‘å›¾çš„å¼ºè¿é€šåˆ†é‡12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class DirectedGraphStrongConnected { public static List&lt;Integer&gt; KosarajuConnected(DirectedGraph g) { // ä¿å­˜çš„å¼ºè¿é€šåˆ†é‡çš„ id // ids[i] è¡¨ç¤º i èŠ‚ç‚¹å±äºå“ªä¸ª å¼ºè¿é€šåˆ†é‡ id List&lt;Integer&gt; ids = new ArrayList&lt;&gt;(g.getCapacity()); for (int i = 0; i &lt; g.getCapacity(); i++) { ids.add(-1); } // éå†çš„æ—¶å€™çš„å¼ºè¿é€šåˆ†é‡ id int count = 0; // å…ˆå¾—åˆ° åå›¾ çš„æ‹“æ‰‘æ’åº List&lt;Integer&gt; order = TopologySort.topologySortWithRecursion(g.reverse()); boolean[] memo = new boolean[g.getCapacity()]; for (int node : order) { if (!memo[node]) { recursionDFS(g, node, count, memo, ids); count++; } } // æ ¹æ®æ‹“æ‰‘æ’åº DFS return ids; } private static void recursionDFS(DirectedGraph g, int start, int count, boolean[] memo, List&lt;Integer&gt; ids) { memo[start] = true; ids.set(start, count); for (int adj : g.adj(start)) { if (!memo[adj]) { recursionDFS(g, adj, count, memo, ids); } } } public static void main(String[] args) { DirectedGraph g = new DirectedGraph(13); g.addEdge(1, 2); g.addEdge(3, 1); g.addEdge(6, 3); g.addEdge(4, 7); g.addEdge(2, 0); g.addEdge(11, 8); g.addEdge(10, 1); g.addEdge(0, 7); g.addEdge(0, 6); System.out.println(KosarajuConnected(g)); }} æœ€å°ç”Ÿæˆæ ‘æœ€å°ç”Ÿæˆæ ‘éƒ½æ˜¯åŸºäºè´ªå¿ƒçš„æ€è·¯å’Œæƒ³æ³•ã€‚ç”±äºéœ€è¦ç”Ÿæˆçš„æ— å‘åŠ æƒå›¾çš„æ ‘ï¼ˆv-1 æ¡è¾¹ï¼‰çš„è·¯å¾„å’Œæœ€çŸ­ï¼Œæ‰€ä»¥å®é™…ä¸Šæ˜¯ä¸€ä¸ªä¸æ–­éå†æœ€çŸ­è·¯å¾„è¾¹çš„è´ªå¿ƒç­–ç•¥ã€‚ prim ç®—æ³• lazy ç‰ˆæœ¬ åœ¨éå†æ‰€æœ‰çš„è¾¹çš„æ—¶å€™ï¼Œä¸ä¸»åŠ¨åˆ é™¤é˜Ÿåˆ—ä¸­çš„æ— æ•ˆè¾¹ï¼Œæ‰€ä»¥ä¸º lazy å®ç° 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class MinTree { // æœ€å°ç”Ÿæˆæ ‘ æŒ‡çš„æ˜¯æ— å‘å›¾ä¸­ï¼Œèƒ½å¤Ÿç”Ÿæˆçš„è¾¹çš„æƒé‡æ€»å’Œæœ€å°çš„æ ‘ // prime çš„æœ€å°ç”Ÿæˆæ ‘å®é™…ä¸Šæ˜¯ä¸€ä¸ªè´ªå¿ƒç®—æ³• // é€šè¿‡ PriorityQueue ä¸åœåœ°ç”Ÿæˆæƒé‡æœ€å°çš„è¾¹ // lazyPrim æŒ‡çš„æ˜¯åœ¨éå†çš„è¿‡ç¨‹ä¸­ pq ä¸­çš„è¾¹ æ˜¯è®¿é—®æ—¶æ‰å¤±æ•ˆ public static Deque&lt;Edge&gt; lazyPrim(UndirectedWeightGraph g) { // å­˜å‚¨æ‰€æœ‰çš„è¾¹ PriorityQueue&lt;Edge&gt; minQueue = new PriorityQueue&lt;&gt;(Comparator.comparingInt(a -&gt; a.weight)); // ä¿å­˜è¢«è®¿é—®è¿‡çš„èŠ‚ç‚¹ boolean[] marked = new boolean[g.getCapacity()]; // ä¿å­˜è¿”å›çš„ç»“æœ Deque&lt;Edge&gt; res = new LinkedList&lt;&gt;(); // ä¿è¯ g æ•´ä½“æ˜¯è¿é€šçš„ // éšæ„é€‰å–ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºå¼€å§‹èŠ‚ç‚¹ addEdgeToPQ(marked, minQueue, 0, g); while (!minQueue.isEmpty()) { // æŠ“åˆ°çš„ä¸€å®šæ˜¯æœ€çŸ­çš„è·¯å¾„ Edge top = minQueue.poll(); int from = top.from, to = top.to; // from to ä¸¤ä¸ªæ–­ç‚¹éƒ½å·²ç»è®¿é—®è¿‡ è¯´æ˜åœ¨ä¸¤ä¸ªç«¯ç‚¹ä¹‹é—´å·²ç»æ‰¾åˆ°æœ€çŸ­çš„äº† if (marked[from] &amp;&amp; marked[to]) continue; // å¦åˆ™å°±æ‰¾åˆ°æœ€çŸ­çš„ res.add(top); // å°†ä¸¤ä¸ªç«¯ç‚¹çš„ edge åŠ å…¥åˆ° queue ä¸­ if (!marked[from]) addEdgeToPQ(marked, minQueue, from, g); if (!marked[to]) addEdgeToPQ(marked, minQueue, to, g); } return res; } public static void addEdgeToPQ(boolean[] marked, PriorityQueue&lt;Edge&gt; minQueue, int start, UndirectedWeightGraph g) { marked[start] = true; for (Edge e : g.adj(start)) { if (!marked[e.other(start)]) { // å¦å¤–ä¸€ä¸ªæ–­ç‚¹æ²¡æœ‰è®¿é—®è¿‡ minQueue.add(e); } } }} åŠæ—¶ç‰ˆæœ¬ åœ¨éå†çš„æ—¶å€™ï¼Œä¸å†ä»¥è¾¹ä½œä¸º ä¼˜å…ˆé˜Ÿåˆ— çš„éå†å¯¹è±¡ï¼Œè€Œæ˜¯é‡‡ç”¨å¯¹ç‚¹è¿›è¡Œéå†ï¼Œåœ¨éå†çš„å›¾ä¸­ï¼Œä¸åœçš„æ›´æ–° ä¼˜å…ˆé˜Ÿåˆ— ä¸­ç‚¹å¯¹åº”çš„æœ€çŸ­è¾¹ï¼Œä»¥æ­¤å‡å°‘è°ƒæ•´å †çš„æ—¶é—´ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private static class Pair { int node; int weight; public Pair(int node, int weight) { this.node = node; this.weight = weight; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Pair pair = (Pair) o; return node == pair.node; } @Override public int hashCode() { return Objects.hash(node); }}// å®æ—¶çš„ prim ç®—æ³• ä¸ lazy ä¸åŒçš„æ˜¯// åœ¨ v è¿™ä¸ªèŠ‚ç‚¹ åŠ å…¥ pq çš„æ—¶å€™ å…¶ä½™çš„éæ ‘é˜¶æ®µ åº”è¯¥åªåŠ å…¥ åˆ° æ ‘ä¸­æœ€çŸ­çš„è¾¹// ç›¸å¯¹æ¥è¯´ å¯ä»¥å‡å°‘æ—¶é—´ å› ä¸º ä¸€ä¸ªå›¾çš„è¯ ä¸€èˆ¬æ˜¯ è¾¹æ¯”ç‚¹å¤š// è¿™ä¸ªç®—æ³•åªç”¨åœ¨ ä¼˜å…ˆé˜Ÿåˆ—ä¸­ä¿å­˜ç‚¹public static Edge[] prim(UndirectedWeightGraph g) { // ä»ç„¶ä½¿ç”¨ä¸€ä¸ª pq ä¿å­˜æœ€çŸ­çš„ç‚¹ ï¼ˆåˆ°è¿™ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»ï¼‰ PriorityQueue&lt;Pair&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt(e -&gt; e.weight)); // edge[i] ä¿å­˜ i åˆ° edge.to çš„æœ€çŸ­è¾¹é•¿ Edge[] edgeTo = new Edge[g.getCapacity()]; boolean[] marked = new boolean[g.getCapacity()]; pq.add(new Pair(0, 0)); while (!pq.isEmpty()) { Pair top = pq.poll(); inTimeAddEdgeToPQ(g, top.node, marked, edgeTo, pq); } return edgeTo;}private static void inTimeAddEdgeToPQ(UndirectedWeightGraph g, int node, boolean[] marked, Edge[] edgeTo, PriorityQueue&lt;Pair&gt; pq) { marked[node] = true; for (Edge adj : g.adj(node)) { int otherNode = adj.other(node); // å·²ç»æ‰¾åˆ°äº† if (marked[otherNode]) continue; // è¯´æ˜è¿˜æ²¡æœ‰æ‰¾åˆ°åˆ°è¿™ä¸ªç‚¹çš„æœ€çŸ­è·ç¦» æˆ–è€… // ç°åœ¨çš„ edge çš„ weight æ›´çŸ­ æ›´æ–° if (edgeTo[otherNode] == null || adj.weight &lt; edgeTo[otherNode].weight) { edgeTo[otherNode] = adj; Pair p = new Pair(otherNode, adj.weight); for (Pair tmp : pq) { // remove æ‰å·²ç»å¤±æ•ˆçš„è¾¹ if (tmp.node == otherNode) { pq.remove(tmp); } break; } pq.add(p); } }} krusal ç®—æ³• ä¸ lazy prim ç®—æ³•ç±»ä¼¼ï¼Œå…¶ä¹Ÿæ˜¯éå†æ‰€æœ‰çš„è¾¹å¹¶åŠ å…¥åˆ° ä¼˜å…ˆé˜Ÿåˆ— ä¸­ï¼Œä½†æ˜¯éå†çš„æ—¶å€™é‡‡ç”¨çš„æ–¹æ³•æ˜¯é€šè¿‡ å¹¶æŸ¥é›† åˆ¤æ–­ç‚¹æ˜¯å¦å·²ç»æ‰¾åˆ°äº†æœ€çŸ­çš„è·ç¦»ï¼Œåœ¨æ‰¾åˆ°æœ€çŸ­è·ç¦»åï¼Œä¼šåˆ¤æ–­ä¸¤ä¸ªç‚¹ç›¸è¿ï¼ŒçŸ¥é“ç»“æœè¾¹é›†åˆå¤§å°æ‰©å±•åˆ° v-1ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MinTreeKruskal { // ä½¿ç”¨ å¹¶æŸ¥é›† æ¥åˆ¤æ–­åŠ å…¥çš„è¾¹æ˜¯å¦æˆç¯ public static List&lt;Edge&gt; kruskalUseUnion(UndirectedWeightGraph g) { List&lt;Edge&gt; res = new ArrayList&lt;&gt;(); Union uf = new Union(g.getCapacity()); PriorityQueue&lt;Edge&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt((e) -&gt; e.weight)); pq.addAll(g.getEdges()); // æœ€å°ç”Ÿæˆæ ‘ åªèƒ½æœ‰ V - 1 ä¸ª ï¼ˆV ä¸º node æ•°ï¼‰ while (!pq.isEmpty() &amp;&amp; (res.size() &lt; g.getCapacity() - 1)) { Edge e = pq.poll(); assert e != null; int from = e.from, to = e.to; // ä¹‹å‰å·²ç»è¿æ¥äº†æœ€çŸ­çš„è¾¹ æ‰€ä»¥ä¸ç”¨å†è¿æ¥äº† if (uf.connected(from, to)) continue; // è¿æ¥ä¸¤æ¡è¾¹ uf.union(from, to); res.add(e); } return res; }}public class Union { // å¹¶æŸ¥é›† int[] parents; public Union(int capacity) { this.parents = new int[capacity]; for (int i = 0; i &lt; capacity; i++) { // åˆå§‹åŒ– this.parents[i] = i; } } public void union(int n1, int n2) { int rootOfN1 = find(n1); int rootOfN2 = find(n2); if (rootOfN1 == rootOfN2) return; // n1 root è¿æ¥åˆ° n2 root ä¸Š this.parents[rootOfN1] = rootOfN2; } // æ‰¾åˆ°è·ŸèŠ‚ç‚¹ private int find(int node) { if (this.parents[node] == node) { return node; } return find(this.parents[node]); } public boolean connected(int i, int j) { // åˆ¤æ–­ä¸¤ä¸ª root æ˜¯å¦ç›¸ç­‰ int rootOfI = find(i); int rootOfJ = find(j); return rootOfI == rootOfJ; }} æœ€çŸ­è·¯å¾„æœ€çŸ­è·¯å¾„å…¶å®è·Ÿä¸Šè¿°çš„ç®—æ³•ç±»ä¼¼ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªç±»ä¼¼è´ªå¿ƒçš„ç­–ç•¥ï¼Œä½†æ˜¯åœ¨éå†æœ€çŸ­è¾¹çš„æ—¶å€™ï¼Œæˆ–åŒæ—¶ä½¿ç”¨ relax çš„æ“ä½œï¼Œä¿éšœä¸€ä¸ªç‚¹ç»è¿‡ä¸€ä¸ªä¸­é—´ç‚¹å¯èƒ½æ¯”ç›´æ¥åˆ°ç›®æ ‡ç‚¹çš„è·ç¦»çŸ­è¿™ä¸ªé—®é¢˜ã€‚ Dijkstra ç®—æ³• åŸºæœ¬ä¸ prim ç®—æ³•ä¸€æ ·ï¼Œåªæ˜¯åŠ å…¥äº† relax çš„æ“ä½œ å…¶åªèƒ½å¤„ç†éè´Ÿçš„æœ‰å‘å›¾ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static class Pair { int node; int weight; public Pair(int node, int weight) { this.node = node; this.weight = weight; }}// dijkstra ä¸ in time çš„ prim ç®—æ³•ç±»ä¼¼// è¿™äº›æ˜¯æ‰¾åˆ°å•æºæœ€çŸ­è·¯çš„public static Edge[] dijkstraMinPath(DirectedWeightGraph g, int start) { // ä¿å­˜æœ€çŸ­è·¯å¾„çš„è¾¹ Edge[] edgeTo = new Edge[g.getCapacity()]; // ä¿å­˜æœ€çŸ­è·¯å¾„çš„é•¿åº¦ int[] distTo = new int[g.getCapacity()]; for (int i = 0; i &lt; g.getCapacity(); i++) { distTo[i] = Integer.MAX_VALUE; } distTo[start] = 0; PriorityQueue&lt;Pair&gt; pq = new PriorityQueue&lt;&gt;(Comparator.comparingInt((e) -&gt; e.weight)); pq.add(new Pair(start, 0)); // æ¯æ¬¡éƒ½æ‰¾ç°åœ¨æœ€çŸ­çš„è·¯å¾„ ç„¶å relax è·¯å¾„ while (!pq.isEmpty()) { Pair min = pq.poll(); relax(g, min.node, pq, edgeTo, distTo); } return edgeTo;}// relax èŠ‚ç‚¹private static void relax(DirectedWeightGraph g, int node, PriorityQueue&lt;Pair&gt; pq, Edge[] edgeTo, int[] distTo) { for (Edge adj : g.adj(node)) { // å› ä¸º edgeTo ä¿å­˜çš„æ˜¯ä¹‹å‰éå†çš„æœ€çŸ­çš„è·¯å¾„ // æ‰€ä»¥ å¦‚æœé€šè¿‡ç°åœ¨è¿™ä¸ªç‚¹ + adj.weight çš„è·ç¦» æ¯” edgeTo çš„çŸ­ å°±éœ€è¦æ›´æ–° if (distTo[adj.to] &gt; distTo[node] + adj.weight) { edgeTo[adj.to] = adj; distTo[adj.to] = distTo[node] + adj.weight; // æ·»åŠ æ–°çš„ æˆ–è€… æ›´æ–°åŸæ¥çš„èŠ‚ç‚¹çš„æœ€å°å€¼ Pair p = new Pair(adj.to, distTo[adj.to]); // æ›´æ–° pq for (Pair tmp : pq) { if (tmp.node == adj.to) { pq.remove(tmp); } break; } pq.add(p); } }} æ‹“æ‰‘æ’åºå¤„ç†æ— ç¯å›¾ ç”±äºæ‹“æ‰‘æ’åºçš„æ€§è´¨ï¼Œæ˜¯ä»å…¥åº¦ä¸º 0 çš„ç‚¹ä¸æ–­å‘å¤–å»¶ä¼¸ï¼Œæ‰€ä»¥ï¼Œå¦‚æœæ ¹æ® æ‹“æ‰‘æ’åº çš„é¡ºåºè®¿é—®å›¾ä¸­çš„ç‚¹ï¼Œé‚£ä¹ˆåé¢çš„ç‚¹æ˜¯ä¸€å®šä¸ä¼šå†è®¿é—®å·²ç»è®¿é—®è¿‡çš„ç‚¹ï¼Œæ‰€ä»¥ä¸ä¼šå‡ºç° relaxã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// é‡‡ç”¨ dfs åšçš„ topologySort// ä¿è¯æ— ç¯public static int[] topologySort(DirectedWeightGraph g) { boolean[] marked = new boolean[g.getCapacity()]; Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; g.getCapacity(); i++) { // marked æ ‡è¯†æ ‡è®°è¿‡çš„ç‚¹ if (!marked[i]) { dfs(g, marked, i, stack); } } int[] res = new int[stack.size()]; int i = 0; while (!stack.isEmpty()) { res[i++] = stack.removeLast(); } return res;}public static void dfs(DirectedWeightGraph g, boolean[] marked, int start, Deque&lt;Integer&gt; stack) { marked[start] = true; for (Edge adj : g.adj(start)) { if (!marked[adj.to]) { dfs(g, marked, adj.to, stack); } } stack.addLast(start);}// ä½¿ç”¨æ‹“æ‰‘æ’åºçš„å•æºæœ€çŸ­è·¯ç»// åªèƒ½å¤„ç†æ— ç¯çš„æƒ…å†µ// æ‹“æ‰‘æ’åºåªèƒ½é’ˆå¯¹æ— ç¯å›¾// ç”±äº æ‹“æ‰‘æ’åºæ˜¯ä» æ— å…¥åº¦çš„ç‚¹å¼€å§‹// å¦‚æœæ‰¾æœ€çŸ­è·¯å¾„ä»è¿™å„¿å¼€å§‹çš„è¯ è¿™ä¸ªç‚¹ ä¸€å®šä¸ä¼šå†æ¬¡è¢«è®¿é—®åˆ° æ‰€ä»¥åªæ”¾æ¾ä¸€æ¬¡// åŒç† è§£å†³å•ç‚¹æ— ç¯å›¾çš„æœ€é•¿è·¯å¾„ å¯ä»¥æŠŠ weight å–è´Ÿ å†æ¥æœ€çŸ­è·¯å¾„å³å¯public static Edge[] topologyMinPath(DirectedWeightGraph g, int start) { int[] topologyPath = TopologySort.topologySort(g); Edge[] res = new Edge[g.getCapacity()]; // åˆå§‹åŒ–è·ç¦» int[] dst = new int[g.getCapacity()]; Arrays.fill(dst, Integer.MAX_VALUE); dst[start] = 0; for (int node : topologyPath) { relax(g, res, dst, node); } return res;}private static void relax(DirectedWeightGraph g, Edge[] res, int[] dst, int node) { for (Edge adj : g.adj(node)) { // å¦‚æœä¹‹å‰éå†çš„ åˆ° adj.to çš„è·ç¦» æ¯”ä» node ç»è¿‡ adj åˆ°è¾¾ adj.to çš„è·ç¦»é•¿ è¯´æ˜è¯¥æ›´æ–°äº† if (dst[adj.to] &gt; dst[node] + adj.weight) { res[adj.to] = adj; dst[adj.to] = dst[node] + adj.weight; } }} BellmanFord ç®—æ³• èƒ½è¿‡å¤„ç†è´Ÿæ•°çš„å›¾ï¼Œä½†æ˜¯ä¸èƒ½å¤„ç†è´Ÿæ•°ç¯ï¼ˆå› ä¸ºè´Ÿæ•°ç¯èƒ½å¤Ÿè¾¾åˆ°ä»»æ„çŸ­çš„è´Ÿæ•°ï¼‰ã€‚ å…¶æ ¸å¿ƒæ€æƒ³æ˜¯éå† V æ¬¡ å›¾ï¼Œè¿™æ ·ä¿éšœæ¯ä¸ªç‚¹éƒ½è¢«éå† V æ¬¡ï¼Œæ‰¾åˆ°æœ€çŸ­çš„è·¯å¾„ã€‚ ä½†æ˜¯å¯ä»¥ä¼˜åŒ–çš„ç‚¹æ˜¯ï¼Œåªæœ‰åœ¨ä¸Šæ¬¡è¢«æ›´æ”¹äº†é•¿åº¦çš„ç‚¹æ‰èƒ½åŠ å…¥é˜Ÿåˆ—ä¸­ã€‚ // è¿™ä¸ªç®—æ³•åªèƒ½å¤„ç†æ²¡æœ‰è´Ÿæƒé‡ç¯çš„æœ‰å‘å›¾123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// å› ä¸ºå¸¦æœ‰è´Ÿæƒé‡ç¯çš„å›¾å¯ä»¥å¾—åˆ°ä»»æ„çŸ­çš„æƒé‡ æ˜¯æ— æ•ˆçš„public static Edge[] bellmanFordMinPath(DirectedWeightGraph g, int start) { // æ‰€ä»¥ å¦‚æœéå†æ‰€æœ‰çš„ç‚¹ åŒæ—¶ relax æ‰€æœ‰çš„ è¾¹ å°±å¯ä»¥å¾—åˆ°ä¸€ä¸ªç»“æœ // å…¶æ•ˆç‡ä¸º o(v + e) // ä½†æ˜¯ å¯ä»¥è€ƒè™‘ä¸€ä¸ªé—®é¢˜ å°±æ˜¯åªæœ‰åœ¨ä¸Šè½®å¾ªç¯ä¸­æ›´æ–°è¿‡çš„ç‚¹ æ‰æœ‰å¯èƒ½ä½¿ è·ç¦»æ›´çŸ­ï¼Œæ‰€ä»¥ ç”¨ä¸€ä¸ª queue æ¥ä¿å­˜è¿™æ ·çš„ç‚¹ // è½¬ä¸Šè½®å¯¹ dst æ•°ç»„æœ‰è´¡çŒ®çš„ç‚¹ Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // ç»“æœ Edge[] edgeTo = new Edge[g.getCapacity()]; // è·ç¦»åˆå§‹åŒ– int[] dst = new int[g.getCapacity()]; Arrays.fill(dst, Integer.MAX_VALUE); dst[start] = 0; // å› ä¸º queue é‡Œé¢ä¸èƒ½æœ‰é‡å¤èŠ‚ç‚¹ æ‰€ä»¥ç”¨è¿™ä¸ªæ¥åˆ¤æ–­ boolean[] inQueue = new boolean[g.getCapacity()]; // æ‰§è¡Œ relax çš„æ¬¡æ•° int cost = 0; // æœ€å¼€å§‹çš„èŠ‚ç‚¹ queue.add(start); // TODO è¿™ä¸ªæ—¶å€™è¿˜è¦æ£€æŸ¥è´Ÿæƒé‡ç¯ // è¿™ä¸ªåœ°æ–¹åªéœ€è¦æ£€æŸ¥æ˜¯å¦æ˜¯æˆç¯å³å¯ while (!queue.isEmpty()) { relax(g, queue.remove(), dst, edgeTo, queue, inQueue); } return edgeTo;}// åœ¨æ”¾æ¾çš„æ—¶å€™åŒæ—¶æ›´æ–° queueprivate static void relax(DirectedWeightGraph g, int node, int[] dst, Edge[] edgeTo, Queue&lt;Integer&gt; queue, boolean[] inQueue) { for (Edge adj : g.adj(node)) { int to = adj.to; // æ›´æ–° if (dst[to] &gt; dst[node] + adj.weight) { edgeTo[to] = adj; dst[to] = dst[node] + adj.weight; if (!inQueue[node]) { inQueue[node] = true; // è¿™æœ‰è¿™è½®å·²ç»æ›´æ–°è¿‡çš„ åˆ° to çš„æ›´çŸ­è·ç¦» å…¶ä»–æ‰å¯èƒ½æ›´çŸ­ queue.add(to); } } // TODO æ£€æŸ¥è´Ÿæƒé‡ç¯ }}","link":"/2021/03/07/graph/"},{"title":"design-pattern","text":"å¸¸è§çš„è®¾è®¡æ¨¡å¼çš„ç®€å•æ€»ç»“å’Œç®€å•å®ç°ï¼Œä¸ºä»¥ååšä¸ªå‚è€ƒ è§‚å¯Ÿè€…æ¨¡å¼è§‚å¯Ÿè€…æ¨¡å¼ç®€å•å®ç°åªéœ€è¦è®© subject åœ¨æ›´æ–°çš„æ—¶å€™ é€šçŸ¥ è§‚å¯Ÿè€…ï¼ŒåŸºæœ¬ç»“æ„å¦‚ä¸‹ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970// è§‚å¯Ÿè€…public interface Observer { // è§‚å¯Ÿè€…çš„æ›´æ–°æ–¹æ³• void update();}// éœ€è¦è¢«è§‚å¯Ÿçš„ä¸»é¢˜public interface Subject { void registerObserver(Observer ob); void unregisterObserver(Observer ob); void notifyAllObserver();}public class SubjectImpl implements Subject { List&lt;Observer&gt; obs; public SubjectImpl() { this.obs = new ArrayList&lt;&gt;(); } @Override public void registerObserver(Observer ob) { for (Observer registered : obs) { if (ob == registered) return; } this.obs.add(ob); } @Override public void unregisterObserver(Observer ob) { this.obs.remove(ob); } // åœ¨æ›´æ”¹æŸä¸ªæ•°å€¼ æˆ–è€…éœ€è¦é€šçŸ¥çš„æ—¶å€™ å¯ä»¥å°†ç»“æœé€šçŸ¥ç»™æ³¨å†Œçš„ observer public void setXXX() { this.notifyAllObserver(); } @Override public void notifyAllObserver() { for (Observer registered : obs) { registered.update(); } }}public class ObserverImpl implements Observer { @Override public void update() { System.out.println(&quot;update&quot;); }}public class Main { public static void main(String[] args) { Subject s = new SubjectImpl(); for (int i = 0; i &lt; 10; i++) { s.registerObserver(new ObserverImpl()); } s.notifyAllObserver(); }} java å†…ç½®çš„è§‚å¯Ÿè€…æ¨¡å¼Observable (Subject) ç±»ä¸ Observor æ¥å£ This class and the Observer interface have been deprecated. The event model supported by Observer and Observable is quite limited, the order of notifications delivered by Observable is unspecified, and state changes are not in one-for-one correspondence with notifications. For a richer event model, consider using the java.beans package. For reliable and ordered messaging among threads, consider using one of the concurrent data structures in the java.util.concurrent package. For reactive streams style programming, see the java.util.concurrent.Flow API.ä¸Šè¿°ä¸¤ä¸ªç±» å·²ç»åœ¨ JDK9 ä¸­è¢«åºŸå¼ƒã€‚æ„¿æ„æ˜¯å› ä¸ºå…¶æ— æ³•æ§åˆ¶é€šçŸ¥çš„é¡ºåº(å› ä¸ºè°ƒç”¨çš„çˆ¶ç±»æ˜¯ notify æ–¹æ³•ï¼Œè€Œä¸”æ˜¯ä»åå‘å‰éå† observer çš„)ï¼Œè€Œä¸”ç”±äº Observable æ˜¯ä¸€ä¸ªç±»å½¢å¼æä¾›ï¼Œéš¾ä»¥æ‰©å±•ã€‚ 12345678910111213141516171819202122232425262728293031public class ObserverImpl implements Observer { @Override public void update() { System.out.println(&quot;update&quot;); }}public class SubjectImplUseJDK extends Observable { public Object msg; public void setMsg(Object msg) { this.msg = msg; // 1. è¦å…ˆè®¾ç½®æ›´æ”¹ setChanged(); // 2. è¢«åŠ¨çš„ä¼ é€’æ¶ˆæ¯ notifyObservers(msg); }}public class Main { public static void main(String[] args) { SubjectImplUseJDK b = new SubjectImplUseJDK(); for (int i = 0; i &lt; 10; i++) { b.addObserver(new ObserverImplUseJDK()); } b.setMsg(&quot;test&quot;); }} è£…é¥°å™¨è£…é¥°å™¨å¯ä»¥æ–¹ä¾¿çš„æ‰©å±•åŸæ¥çš„ç±»ä¸å…·å¤‡çš„æ–¹æ³•ã€‚ ç¬¦åˆ å¼€é—­åŸåˆ™ ï¼ˆå¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­ï¼‰ ç®€å•ä¾‹å­é€šè¿‡å­ç±»æŒæœ‰åŸºç±»çš„å¼•ç”¨ï¼Œé€šè¿‡æ„é€ å™¨å¯¹åŸå§‹çš„å¯¹è±¡è¿›è¡Œè¿è¡Œæ—¶å¢å¼ºã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public abstract class Base { // åŸºç±»æä¾›æŠ½è±¡æ–¹æ³• public abstract void base();}public class OneImpl extends Base { // æŒæœ‰ Base ç±»å‹çš„å±æ€§ private Base base; public OneImpl(Base base) { this.base = base; } @Override public void base() { // å¯¹åŸå§‹çš„ base åšä¸€ä¸ªå¢å¼º base.base(); System.out.println(&quot;one&quot;); }}// è¿˜å¯ä»¥ç”¨ abstract è¿›ä¸€æ­¥åŠ å¼ºpublic abstract class TwoAbstract extends Base { public abstract void anotherAbstract();}public class TwoImpl extends TwoAbstract { private Base base; public TwoImpl(Base base) { this.base = base; } @Override public void base() { base.base(); System.out.println(&quot;Two&quot;); } @Override public void anotherAbstract() { System.out.println(&quot;another&quot;); }} java ä¸­çš„ä¾‹å­java i/o ç±» InputStream åŠå…¶å­ç±»ï¼Œå¯ä»¥ä½¿ç”¨è£…é¥°å™¨å¢å¼ºæ–¹æ³• ä¸€ä¸ª new BufferedInputStream(new FileInputStream(file));çš„è°ƒç”¨æµç¨‹åˆ†æå¦‚ä¸‹ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// inputStream çš„åŸºç±»public abstract class InputStream implements Closeable { // å­ç±»å®ç°å…¶æ–¹æ³• // è¿”å›ä¸‹ä¸€ä¸ªå­—ç¬¦ public abstract int read() throws IOException; // åŸºç±»æä¾›çš„å…±æœ‰æ–¹æ³• è¯»å– off + len çš„ byte åˆ° byteä¸­ public int read(byte b[], int off, int len) throws IOException { Objects.checkFromIndexSize(off, len, b.length); if (len == 0) { return 0; } int c = read(); if (c == -1) { return -1; } b[off] = (byte)c; int i = 1; try { for (; i &lt; len ; i++) { // å…³é”®åœ¨è¿™å„¿è¿›è¡Œäº†åŠ¨æ€ç»‘å®š å®ç°äº†å¢å¼º c = read(); if (c == -1) { break; } b[off + i] = (byte)c; } } catch (IOException ee) { } return i; }}public class BufferedInputStream extends FilterInputStream { // ç»§æ‰¿çš„ FilterInputStream ä¸­åŒ…å«äº†ä¸€ä¸ª inputStream çš„å®ä¾‹å¼•ç”¨ public BufferedInputStream(InputStream in) { this(in, DEFAULT_BUFFER_SIZE); } // å®ç°çš„ read æ–¹æ³• public synchronized int read() throws IOException { // è¯»å–çš„ä½ç½®ä¸Šçš„æ•°å­—è¶…è¿‡äº† buffer ä¸­å·²ç»ä¿å­˜çš„ if (pos &gt;= count) { // è°ƒç”¨ read æ–¹æ³•è¿›è¡Œè¯»å– fill(); if (pos &gt;= count) return -1; } return getBufIfOpen()[pos++] &amp; 0xff; } private void fill() throws IOException { /** * â€¦â€¦ è¯»å–å·²ç»è®¾ç½®æ¸¸æ ‡ç­‰æ–¹æ³• **/ // è¯»å– buffer å®Œæ¯• count = pos; // è°ƒç”¨æŒæœ‰çš„ inputStream çš„å¼•ç”¨è¿›è¡Œ read // å…³é”®åœ¨è¿™å„¿è¿›è¡Œäº†å¢å¼º ä¼šåœ¨è¯»å–å èµ‹å€¼ åˆ° buffer ä¸­ int n = getInIfOpen().read(buffer, pos, buffer.length - pos); if (n &gt; 0) count = n + pos; }}public class FileInputStream extends InputStream { public int read() throws IOException { return read0(); } private native int read0() throws IOException;} å·¥å‚æ¨¡å¼æŠ½è±¡å¯¹è±¡çš„æ–°å»ºè¿‡ç¨‹ ç®€å•å·¥å‚ ç®€å•å·¥å‚å¯ä»¥çœ‹åšæ˜¯å¯¹ new Object() çš„ç®€å•æŠ½è±¡ å·¥å‚æ–¹æ³• ä¸Šé¢æ˜¯ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œå­ç±»å°†ä¼šå®ç° abstract çš„æŠ½è±¡å·¥å‚æ–¹æ³•ï¼Œå°†åˆ›å»ºç»†èŠ‚åœ¨å­ç±»ä¸­å®ç°ï¼Œæä¾›ä¸€ä¸ªæŠ½è±¡çš„å·¥å‚æ–¹æ³•ã€‚ è¿›ä¸€æ­¥ï¼Œå¯ä»¥å°†å…¶åˆ†ä¸ºä¸¤ç±» Object ï¼ˆäº§å“å¯¹åº”çš„æ¥å£ï¼‰ concreateObject(å¯¹åº”çš„å…·ä½“äº§å“å®ç°ç±») abstract creator(æŠ½è±¡çš„å·¥å‚æ–¹æ³•) creatorImpl(å®ç°å¯¹ concreateObject çš„åˆå§‹åŒ–) æŠ½è±¡å·¥å‚ä¾èµ–å€’ç½®åŸåˆ™ä¾èµ–æŠ½è±¡ï¼Œä¸èƒ½ä¾èµ–å…·ä½“ç±»ã€‚ å› æ­¤ï¼ŒæŠ½è±¡å·¥å‚é’ˆå¯¹äº§å“ï¼Œä¹Ÿæ˜¯å¯¹äº§å“çš„æŠ½è±¡è¿›è¡Œç»´æŠ¤å’Œç®¡ç†ï¼Œä¸èƒ½å¯¹å…·ä½“äº§å“è¿›è¡Œç®¡ç†ï¼Œæ‰€ä»¥éœ€è¦æŠ½è±¡ä¸€ä¸‹ä¸¤ä¸ªéƒ¨åˆ† æŠ½è±¡å·¥å‚ æŠ½è±¡äº§å“ï¼ˆå…·ä½“çš„äº§å“ä¾èµ–è¿™ä¸ª base çš„æŠ½è±¡äº§å“ï¼‰ å®ç° é’ˆå¯¹äº§å“å’Œå·¥å‚è¿›è¡ŒæŠ½è±¡ ç”šè‡³å¯ä»¥åµŒå¥—æŠ½è±¡å·¥å‚ è¿›ä¸€æ­¥æŠ½è±¡ product çš„åˆå§‹åŒ–æµç¨‹ã€‚ è¿™æ · client åªéœ€è¦é’ˆå¯¹å‚æ•°ç­‰æƒ…å†µ åˆ†å‘åˆ°ä¸åŒçš„ factory å³å¯ å•ä¾‹æ¨¡å¼å…¨å±€å…±äº«ä¸€ä¸ªå˜é‡ java çš„å•ä¾‹æ¨¡å¼ æ‡’æ±‰å¼ ç”±äº ç±»åŠ è½½ æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼Œæ‰€çŸ¥ç›´æ¥æ”¾åˆ° ä¸­åˆå§‹åŒ– 12345678910public class LazySingleton { private static final Object singleton = new Object(); // ä¿è¯ä¸è¢«åˆå§‹åŒ– private LazySingleton(){} public static Object getSingleton() { return singleton; }} é¥¿æ±‰å¼ éœ€è¦çš„æ—¶å€™å†åˆ›å»ºï¼Œä¸ºäº†ä¿éšœå¤šçº¿ç¨‹å®‰å…¨ï¼Œåˆ›å»ºçš„æ—¶å€™åŠ é” 1234567891011121314public class HungrySingleton { private static final Object singleton; // ä¿è¯ä¸è¢«åˆå§‹åŒ– private HungrySingleton(){} public static Object getSingleton() { synchronized (HungrySingleton.class) { if (singleton == null) { singleton = new NeedSingletonClass(); } return singleton; } }} åŒé‡æ ¡éªŒé” åŒé‡æ ¡éªŒé”ï¼Œåˆå§‹åŒ–çš„æ—¶å€™ä½¿ç”¨ synchronized ä¿éšœçº¿ç¨‹å®‰å…¨ï¼ŒåŒæ—¶ä½¿ç”¨ volatile ä¿éšœæŒ‡ä»¤ä¸è¢«é‡æ’åºã€‚ 123456789101112131415161718192021public class DoubleCheckSingleton { // é˜²æ­¢æŒ‡ä»¤é‡æ’åº å› ä¸º Object å¯¹è±¡ç”Ÿæˆæœ‰å¤šä¸ªæ­¥éª¤ï¼Œä¸ºäº†ä¿éšœ // å…¶ä»–çº¿ç¨‹èƒ½å¤Ÿä½¿ç”¨è¯¥å®Œæ•´å¯¹è±¡ private static volatile Object singleton; public static Object getSingleton() { // é˜²æ­¢å¤šä¸ªçº¿ç¨‹å µå¡ æé«˜å¤šçº¿ç¨‹æ€§èƒ½ if (singleton == null) { synchronized(DoubleCheckSingleton.class) { // åœ¨å¤šä¸ªçº¿ç¨‹å µå¡åœ¨æ—¶ï¼Œé˜²æ­¢ singleton è¢«é‡å¤åˆå§‹åŒ– if (singleton == null) { singleton = new Object(); } } } return singleton; }} é™æ€å†…éƒ¨ç±» 1234567891011121314151617// ä½¿ç”¨é™æ€å†…éƒ¨ç±»æ¥ä¿éšœå®‰å…¨// åŸç†æ˜¯å› ä¸º é™æ€å†…éƒ¨ç±»æ˜¯æ‡’åŠ è½½çš„public class StaticClassSingleton { private StaticClassSingleton() {}; private static class InnerStaticClass { public static NeedSingletonClass singletonClass = new NeedSingletonClass(); } // è¿™å„¿æ˜¯æ‡’åŠ è½½ï¼Œåœ¨ innerStaticClass é‡Œé¢çš„é™æ€å†…éƒ¨ç±»è¢«åŠ è½½çš„æ—¶å€™ // æ‰§è¡Œå†…éƒ¨ç±»çš„ &lt;clinit&gt; æ–¹æ³•è¿›è¡Œåˆå§‹åŒ– // final æ˜¯ä¸ºäº†ä¿è¯è¿™ä¸ªæ–¹æ³•ä¸ä¼šè¢«é‡å†™æˆ–è€…é‡è½½ public static final NeedSingletonClass getInstance() { return InnerStaticClass.singletonClass; }} å‘½ä»¤æ¨¡å¼å‘½ä»¤æ¨¡å¼æ˜¯ä¸ºäº†å°è£…ä¸åŒçš„æ“ä½œçš„ä¸åŒ api åšçš„ å¦‚çº¿ç¨‹æ± ç­‰çš„å®ç°ã€å·¥ä½œé˜Ÿåˆ—ç­‰ä¹Ÿæ˜¯è·Ÿå‘½ä»¤æ¨¡å¼ç›¸å…³ 123456789101112131415161718192021222324252627282930313233343536373839404142public class Client { private CommandManager manager; public Client(CommandManager manager) { this.manager = manager; } public void execute(int id, Object args) { this.manager.execute(id, args); }}// å¯¹ä¸åŒ API çš„è°ƒç”¨å°è£…æˆåŒä¸€ä¸ª APIpublic interface Command { // å°è£…å‘½ä»¤çš„ç»†èŠ‚ void execute(Object args);}public class CommandExecutor { void up() { System.out.println(&quot;executor up !&quot;); }}// ç®¡ç†å¹¶åˆå§‹åŒ–æ‰€æœ‰çš„ command å¯¹è±¡public class CommandManager { private Command[] commands; public CommandManager() { this.commands = new Command[1]; this.commands[0] = new CommandImpl(new CommandExecutor()); } // æ ¹æ®ä¼ å…¥çš„ command id ä¸ args å…·ä½“æ‰§è¡Œ public void execute(int commandID, Object args) { this.commands[commandID].execute(args); }} é€‚é…å™¨æ¨¡å¼ä¸ºäº†é€‚é…ä¸¤ç§ä¸åŒçš„æ–¹æ³•çš„å¯¹è±¡ï¼Œè®©ä¸€ç§èƒ½å¤Ÿé€‚åº”å¦ä¸€ç§æ·»åŠ çš„ç±» æ¥å£é€‚é…ï¼šå®ç°å¯¹åº”çš„æ¥å£ï¼Œé€šè¿‡ç»„åˆçš„æ–¹å¼å®ç°é€‚é…ã€‚ ç±»é€‚é…ï¼šé€šè¿‡ç»„åˆç»§æ‰¿ï¼ˆjava ä¸å¯èƒ½ï¼‰ 12345678910111213141516171819202122232425262728// å®¢æˆ·ç«¯è°ƒç”¨çš„æ¥å£public interface Duck { void spark();}public class Dog { public void bark() { System.out.println(&quot;!!!!!!!!&quot;); }}public class DuckAdapter implements Duck { private Dog dog; public DuckAdapter(Dog dog) { this.dog = dog; } @Override public void spark() { this.dog.bark(); }} å¤–è§‚æ¨¡å¼ å¤–è§‚æ¨¡å¼æ˜¯ä¸€ä¸ªå‘å¤–æš´éœ²ç®€å•æ¥å£ï¼Œå¯¹å†…è¿›è¡ŒåŒ…è£…çš„è®¾è®¡æ¨¡å¼ã€‚ç”¨äºå°è£…å¤æ‚çš„é€»è¾‘,ä»¥å‡å°‘å¯¹è±¡ä¹‹é—´çš„ä¾èµ–ã€‚ æœ€å°‘çŸ¥è¯†åŸåˆ™: å‡å°‘å¯¹è±¡é—´çš„äº¤äº’ï¼Œå› æ­¤åªåº”è¯¥è°ƒç”¨ä»¥ä¸‹èŒƒå›´çš„æ–¹æ³•ã€‚ å¯¹è±¡æœ¬èº« æ–¹æ³•å‚æ•°ä¼ é€’çš„å¯¹è±¡ æ­¤æ–¹æ³•åˆ›å»ºæˆ–å®ä¾‹åŒ–çš„å¯¹è±¡ å¯¹è±¡çš„ä»»ä½•ç»„ä»¶ æ¨¡æ¿æ–¹æ³•æ¨¡æ¿æ–¹æ³•ç”¨äºå°è£…ç»Ÿä¸€çš„æŠ½è±¡æ­¥éª¤ã€‚é€šè¿‡åœ¨çˆ¶ç±»ä¸­å®šä¹‰ç®—æ³•çš„è¿è¡Œæµç¨‹ï¼Œæä¾›ç®—æ³•çš„é»˜è®¤å®ç°å¹¶äº¤ç»™ä¸åŒçš„å­ç±»è¿›è¡Œé‡è½½å®Œæˆã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public interface Action { // å®šä¹‰ä¸‹é¢å°†è¦ä½¿ç”¨çš„æ¥å£ void act();}// å®šä¹‰æŠ½è±¡çš„æµç¨‹public abstract class AbstractProcess implements Action { // ä¿éšœå­ç±»çš„è¡Œä¸ºæœ‰ä¸€å®šçš„å…±åŒæ€§ // æä¾› action çš„é»˜è®¤å®ç° public void actionOne() { System.out.println(&quot;One&quot;); } // æä¾› action çš„é»˜è®¤å®ç° public void actionTwo() { System.out.println(&quot;Two&quot;); } // å¯ä»¥å†æ¬¡æä¾› abstract çš„é»˜è®¤å®ç° public abstract void actionThree(); // å¯ä»¥åœ¨å­ç±»ä¸­å®ç° hook æ–¹æ³• hook ä½ act æ‰§è¡Œçš„è¿‡ç¨‹ public abstract void hook(); @Override public void act() { // å°è£…æ•´ä½“çš„ç®—æ³•è°ƒç”¨é€»è¾‘ // æ ¹æ®è¿è¡Œæ—¶ åŠ¨æ€çš„é€‰æ‹©æ–¹æ³•è¡¨é‡Œé¢çš„æ–¹æ³• actionOne(); actionTwo(); actionThree(); hook(); }}// è¿™æ ·å¯ä»¥ä¿è¯åº•å±‚ç»„ä»¶ åªéœ€è¦å…³æ³¨å®ç°æ–¹æ³•ç»†èŠ‚ ä¸éœ€è¦å…³æ³¨å…¶ä»–public class ProcessImpl extends AbstractProcess { @Override public void actionThree() { System.out.println(&quot;process&quot;); } @Override public void hook() { System.out.println(&quot;hook&quot;); }} è¿­ä»£å™¨æ¨¡å¼è¿­ä»£å™¨æ¨¡å¼ç”¨æ¥æä¾›ç»Ÿä¸€çš„è®¿é—®å…ƒç´ çš„æ¥å£ï¼Œå¯ä»¥ä¸ç”¨çŸ¥é“å…ƒç´ å­˜å‚¨çš„å…·ä½“ç»†èŠ‚è®¿é—®ã€‚ é€šè¿‡ iterator æš´éœ²ç»Ÿä¸€çš„ éå† æ¥å£ã€‚å®¢æˆ·ç«¯é€šè¿‡ä¿å­˜æ‰€æœ‰æ•°æ®çš„ Items å®ç°ç±»åˆ›å»ºå¯¹åº”çš„ iterator å®Œæˆæ•°æ®çš„éå†æ“ä½œã€‚ å•ä¸€è´£ä»»ï¼šä¸€ä¸ªç±»åº”è¯¥åªæœ‰ä¸€ä¸ªå¼•èµ·å˜åŒ–çš„åŸå› ï¼Œæ‰€ä»¥éœ€è¦æŠŠ Items ä¸ Iterator åˆ†å¼€å®ç°ã€‚ ç®€å•çš„ iterator å®ç° ä½¿ç”¨ä¸€ä¸ªæ•°å€¼æ¥è¡¨æ˜ç°åœ¨è®¿é—®åˆ°çš„ä½ç½® 12345678910111213141516171819202122232425262728293031323334package iterator;// ä½œä¸º iterator çš„åŸºç±»public interface BaseIterator { boolean hasNext(); Object next();}package iterator;public class ArrayIterator implements BaseIterator { // ä¿å­˜éå†çš„ä¸‹æ ‡ private int index; // éå†çš„æ•°ç»„ private int[] nums; public ArrayIterator(int[] nums) { this.nums = nums; this.index = 0; } @Override public boolean hasNext() { return this.index &lt; nums.length; } @Override public Object next() { return this.nums[this.index++]; }} åœ¨æ ‘çŠ¶ç»“æ„ä¸­è¿›è¡Œè¿­ä»£çš„æ–¹å¼ç›¸å½“äºç»„åˆè¿­ä»£å™¨ï¼Œé—®å¦‚æœåœ¨ [1,[2,3,[2,34],3]] è¿™ç§ä¸­é—´å®ç° iterator è¯¥å¦‚ä½•å¤„ç†ã€‚ ä¾‹é¢˜- æ‰å¹³åŒ–åµŒå¥—åˆ—è¡¨è¿­ä»£å™¨ ç©ºæ•°ç»„å³ [[]] è¿”å› null çš„è§£æ³•ä½¿ç”¨é€’å½’çš„æ€æƒ³ï¼Œåœ¨ iterator ä¸­ä¿å­˜æ¯æ¬¡éå†çš„ iterator è¿™æ ·åœ¨é‡åˆ°æ·±å±‚æ¬¡çš„åµŒå¥—çš„æ—¶å€™ï¼Œä¼šåœ¨æ¯ä¸€ä¸ª iterator ä¸­ä¿å­˜ ä¸‹ä¸€å±‚æ¬¡çš„å¼•ç”¨ï¼Œæœ€åå¾—åˆ°ç»“æœ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117import java.util.*;public class NestedIteratorNew implements Iterator&lt;Integer&gt; { // ç»™å®šä¸€ä¸ª nexted çš„æ•°ç»„ // é—®å¦‚ä½•å»éå†å®ƒ // è¿™å„¿ä½¿ç”¨ç»„åˆçš„æ–¹å¼å»ç”Ÿæˆ nextedList ç„¶åå†ç”¨ stack å­˜å‚¨éå†çš„ iterator private static interface NestedInteger { // @return true if this NestedInteger holds a single integer, rather than a nested list. public boolean isInteger(); // @return the single integer that this NestedInteger holds, if it holds a single integer // Return null if this NestedInteger holds a nested list public Integer getInteger(); // @return the nested list that this NestedInteger holds, if it holds a nested list // Return null if this NestedInteger holds a single integer public List&lt;NestedInteger&gt; getList(); } // æä¾›çš„é»˜è®¤å®ç°ç±» private static class NestedIntegerImpl implements NestedInteger { private int num; private List&lt;NestedInteger&gt; list; private boolean isNum; public NestedIntegerImpl(int num) { this.num = num; this.isNum = true; } public NestedIntegerImpl(List&lt;NestedInteger&gt; list) { this.list = list; this.isNum = false; } @Override public boolean isInteger() { return this.isNum; } @Override public Integer getInteger() { return this.num; } @Override public List&lt;NestedInteger&gt; getList() { return this.list; } } // stack æ¥ä¿å­˜æ¯æ¬¡è½¬æ¢çš„å‡ºæ¥çš„ iterator ç›¸å½“äº next è°ƒç”¨çš„æ—¶å€™å»æ‰¾åˆ°çš„æ˜¯ stack top é‡Œçš„ iterator Deque&lt;Iterator&lt;NestedInteger&gt;&gt; stack; public NestedIteratorNew(List&lt;NestedInteger&gt; nestedList) { this.stack = new LinkedList&lt;&gt;(); // åˆå§‹åŒ–åŠ å…¥çš„èŠ‚ç‚¹ this.stack.addLast(nestedList.iterator()); } @Override public Integer next() { if (hasNext()) { Iterator&lt;NestedInteger&gt; iterator = this.stack.peekLast(); NestedInteger i = iterator.next(); if (!i.isInteger()) { stack.addLast(i.getList().iterator()); return next(); } return i.getInteger(); } return null; } @Override public boolean hasNext() { if (this.stack.size() &gt; 0) { Iterator&lt;NestedInteger&gt; top = this.stack.peekLast(); if (top.hasNext()) return true; // è¿™ä¸ªæ—¶å€™ top çš„ iterator è®¿é—®å®Œæ¯•äº† å»è®¿é—®ä¸‹é¢çš„ iterator this.stack.removeLast(); // åªéœ€è¦é€’å½’çš„è°ƒç”¨ è®¿é—® æ ˆå³å¯ return hasNext(); } return false; } public static void main(String[] args) { List&lt;NestedInteger&gt; test = new ArrayList&lt;&gt;();// List&lt;NestedInteger&gt; one = new ArrayList&lt;&gt;();// one.add(new NestedIntegerImpl(1));// one.add(new NestedIntegerImpl(1));// test.add(new NestedIntegerImpl(one));// test.add(new NestedIntegerImpl(2));// List&lt;NestedInteger&gt; three = new ArrayList&lt;&gt;(); test.add(new NestedIntegerImpl(new ArrayList&lt;&gt;()));//// three.add(new NestedIntegerImpl(1));// three.add(new NestedIntegerImpl(1));// test.add(new NestedIntegerImpl(three));// test.add(new NestedIteratorNew.NestedIntegerImpl(new ArrayList&lt;&gt;()));// test.add(new NestedIteratorNew.NestedIntegerImpl(2));// test.add(new NestedIteratorNew.NestedIntegerImpl(new ArrayList&lt;&gt;() {{// List&lt;NestedInteger&gt; two = new ArrayList&lt;&gt;();// two.add(new NestedIteratorNew.NestedIntegerImpl(new ArrayList&lt;&gt;()));// add(new NestedIteratorNew.NestedIntegerImpl(two));// add(new NestedIteratorNew.NestedIntegerImpl(3));// }})); NestedIteratorNew it = new NestedIteratorNew(test); while (it.hasNext()) { System.out.println(it.next()); } }} ç©ºæ•°ç»„ä¸è¿”å›çš„ç»“æœç”±äºä¸Šä¸€ä¸ªæ–¹æ³•ä¸èƒ½ä¿è¯è¿”å›çš„æ—¶å€™ï¼ŒåµŒå¥—ç©ºæ•°ç»„è¿”å› nullã€‚ æ‰€ä»¥ï¼Œå®é™…ä¸Šåªèƒ½åœ¨ hasNext() è°ƒç”¨çš„è¿‡ç¨‹ä¸­å»å¤„ç†è¿™ç§äº‹æƒ…ï¼Œä¿è¯æ¯æ¬¡ä» stack æ ˆä¸­è·å–çš„éƒ½æ˜¯æ•°å­—ï¼Œä¸ä¼šå­˜åœ¨ null è¿™ç§æƒ…å†µã€‚ æ‰€ä»¥éœ€è¦åœ¨ hasNext() è°ƒç”¨çš„è¿‡ç¨‹ä¸­è¿›è¡Œé“ºå¹³æ“ä½œï¼Œé€’å½’çš„è°ƒç”¨ï¼Œç›´åˆ°æ ˆé¡¶æ˜¯ä¸€ä¸ªå¸¦æœ‰æ•°å­—çš„ iterator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788import java.util.*;public class NestedIteratorNotReturnNull implements Iterator&lt;Integer&gt; { // ä¸ºäº†ä¸è¿”å› null æ‰€ä»¥è¦åœ¨ hasNext ä¸­å°±å°†æ‰€æœ‰æ•°æ®å‡†å¤‡å¥½ private Deque&lt;Iterator&lt;NestedInteger&gt;&gt; stack; public NestedIteratorNotReturnNull(List&lt;NestedInteger&gt; nestedList) { this.stack = new LinkedList&lt;&gt;(); this.stack.addLast(nestedList.iterator()); } @Override public boolean hasNext() { // æ‹‰å¹³æ‰€æœ‰çš„ iterator while (!this.stack.isEmpty()) { // å·²ç»æ‹‰å¹³äº†ä¸€ä¸ªçŠ¶æ€äº† Iterator&lt;NestedInteger&gt; top = this.stack.peekLast(); if (!top.hasNext()) { this.stack.removeLast(); continue; } // æ¯æ¬¡å¤„ç†ä¸€ä¸ª NestedInteger next = top.next(); if (next.isInteger()) { // å·²ç»æ‰¾åˆ°äº†ä¸€ä¸ªæ•°å­— ç›´æ¥è¿”å› this.stack.addLast(Collections.singletonList(next).iterator()); return true; } this.stack.addLast(next.getList().iterator()); } return false; } @Override public Integer next() { // hasNext ä¸­å·²ç»å°†æ•°æ®å’Œç»“æœå‡†å¤‡å¥½ return stack.peekLast().next().getInteger(); } private static interface NestedInteger { // @return true if this NestedInteger holds a single integer, rather than a nested list. public boolean isInteger(); // @return the single integer that this NestedInteger holds, if it holds a single integer // Return null if this NestedInteger holds a nested list public Integer getInteger(); // @return the nested list that this NestedInteger holds, if it holds a nested list // Return null if this NestedInteger holds a single integer public List&lt;NestedInteger&gt; getList(); } // æä¾›çš„é»˜è®¤å®ç°ç±» private static class NestedIntegerImpl implements NestedInteger { private int num; private List&lt;NestedInteger&gt; list; private boolean isNum; public NestedIntegerImpl(int num) { this.num = num; this.isNum = true; } public NestedIntegerImpl(List&lt;NestedInteger&gt; list) { this.list = list; this.isNum = false; } @Override public boolean isInteger() { return this.isNum; } @Override public Integer getInteger() { return this.num; } @Override public List&lt;NestedInteger&gt; getList() { return this.list; } }} çŠ¶æ€æ¨¡å¼ï¼ˆçŠ¶æ€æœºï¼‰çŠ¶æ€æ¨¡å¼æŠ½è±¡çŠ¶æ€æ“ä½œï¼Œè¿›è¡Œç»Ÿä¸€çš„è°ƒé…ï¼Œè¿™æ ·å¯ä»¥æ–¹ä¾¿ä¿®æ”¹æ·»åŠ åŠŸèƒ½ã€‚å› ä¸ºè¿™æ ·æ‰èƒ½æ»¡è¶³å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­çš„æ•ˆæœã€‚ ä»¥ä¹¦ä¸Šçš„ä¾‹å­ä¸ºä¾‹ï¼Œè¿™ä¸ªæœ‰ä»¥ä¸‹å‡ ä¸ªçŠ¶æ€åŠå…¶è½¬æ¢å…³ç³» æŠ½è±¡ state çŠ¶æ€ 123456789101112package status;public interface State { void insertQuarter() throws Exception; void turnCrank() throws Exception; void ejectQuarter() throws Exception; void dispense() throws Exception;} å®ç°å„ç§çŠ¶æ€ 123456789101112131415161718192021222324252627282930313233package status;public class HasQuarterState implements State { // æš´éœ² context æ˜¯ä¸ºäº†èƒ½å¤Ÿåœ¨ state ä¸­æ“ä½œ context è¿›è¡ŒçŠ¶æ€è½¬ç§» private Context context; public HasQuarterState(Context context) { this.context = context; } @Override public void insertQuarter() throws Exception { throw new RuntimeException(&quot;æ— æ³•é‡å¤æŠ•å¸&quot;); } @Override public void turnCrank() throws Exception { this.context.setCurrentState(context.getSoldState()); } @Override public void ejectQuarter() throws Exception { // æ“ä½œ context è¿›è¡ŒçŠ¶æ€è½¬ç§» this.context.setCurrentState(context.getNoQuarterState()); } @Override public void dispense() throws Exception { throw new RuntimeException(&quot;è¿˜æœª turn crank æ— æ³•è·å–&quot;); }} context å®ç°å¯¹äº state çš„ç®¡ç† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package status;public class Context implements State { private final State noQuarterState; private final State hasQuarterState; private final State soldOutState; private final State soldState; private State currentState; private int count; public Context(int count) { this.count = count; this.hasQuarterState = new HasQuarterState(this); this.noQuarterState = new NoQuarterState(this); this.soldOutState = new SoldOutState(this); this.soldState = new SoldState(this); this.currentState = this.noQuarterState; } // è¡¨ç¤ºå‰©ä½™èµ„æºçš„æ•°é‡ è¿›è¡Œå‡ä¸€æ“ä½œ public void releaseCount() { this.count--; } public int getCount() { return count; } public void setCurrentState(State currentState) { this.currentState = currentState; } public State getNoQuarterState() { return noQuarterState; } public State getHasQuarterState() { return hasQuarterState; } public State getSoldOutState() { return soldOutState; } public State getSoldState() { return soldState; } // æš´éœ² state çš„æ“ä½œ @Override public void insertQuarter() throws Exception { this.currentState.insertQuarter(); } @Override public void turnCrank() throws Exception { this.currentState.turnCrank(); } @Override public void ejectQuarter() throws Exception { this.currentState.ejectQuarter(); } @Override public void dispense() throws Exception { this.currentState.dispense(); } @Override public String toString() { return &quot;Context{&quot; + &quot;currentState=&quot; + currentState + &quot;, count=&quot; + count + '}'; } public static void main(String[] args) { State c = new Context(5); try { c.insertQuarter(); c.turnCrank(); c.dispense(); System.out.println(c); c.insertQuarter(); c.ejectQuarter();// c.turnCrank(); } catch (Exception e) { System.out.println(e.getMessage()); } }} ä»£ç†æ¨¡å¼ä»£ç†æ¨¡å¼ä¹Ÿæ˜¯å¯¹ä¸€ä¸ªå¯¹è±¡è¿›è¡Œå¢å¼ºçš„æ¨¡å¼ï¼Œæˆ‘ç†è§£çš„è¯ã€‚ é€šè¿‡æŒæœ‰çœŸå®çš„å¯¹è±¡ï¼Œå‘å¤–æš´éœ²ç›¸åŒçš„æ–¹æ³•ï¼Œå¯¹æ•°æ®è¿›è¡ŒåŠ¨æ€å¢å¼ºã€‚ java åŠ¨æ€ä»£ç†java ä¼šåœ¨è¿è¡Œæ—¶åˆ›å»ºä»£ç†ç±»(è¿”å›ç”Ÿæˆç±»çš„ byte[] å¹¶ä½¿ç”¨ç±»åŠ è½½å™¨åŠ è½½)ï¼Œé€šè¿‡ç»§æ‰¿ Proxy ç±»å®ç° Subject æ¥å£çš„æ–¹å¼å®ç°ã€‚å…·ä½“å¯ä»¥å‚è€ƒä¸‹é¢çš„æ–‡ç«  è´£ä»»é“¾æ¨¡å¼è´£ä»»é“¾è®¾è®¡æ¨¡å¼æ˜¯ä¸€ç§å¯¹é“¾å¼è°ƒç”¨æ›´é«˜çº§çš„æŠ½è±¡ï¼Œèƒ½å¤ŸæŠŠé“¾å¼å‡½æ•°æ‰§è¡Œçš„æ§åˆ¶æƒä¸‹æ”¾åˆ°é“¾ä¸­é—´ï¼Œåœ¨æ‰§è¡Œé“¾çš„è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥åœ¨è°ƒç”¨ä¸‹ä¸€ä¸ªé“¾å¼è¿‡ç¨‹å‰å’Œåå¤„ç†è¿›è¡Œé¢å¤–çš„å¤„ç†ã€‚java ä¸­å®ç°çš„ä¸»ä½“é€»è¾‘ä¹Ÿé‡‡ç”¨ä¸‹é¢çš„æ–¹æ³•å®ç°ã€‚ ä¸»è¦åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ† å¤„ç†å‡½æ•°ï¼Œå³æ‰¿æ‹…é“¾å¼å‡½æ•°é€»è¾‘çš„å®ç° ç®¡ç†éƒ¨åˆ†ï¼Œå³ç®¡ç†é“¾è°ƒç”¨è¿‡ç¨‹çš„éƒ¨åˆ† 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package chain;@FunctionalInterfacepublic interface Process { void process(Chain c);}import java.util.ArrayList;import java.util.List;public class Chain { List&lt;Process&gt; handlers; int index; public Chain() { this.index = -1; this.handlers = new ArrayList&lt;&gt;(); } public void register(Process ...processes) { this.handlers.addAll(Arrays.asList(processes)); } public void next() { this.index++; // ä¸ºäº†ä¿è¯é“¾å¼å‡½æ•°ä¸­æ²¡æœ‰è¢«æ˜¾å¼è°ƒç”¨ .next() çš„åœ°æ–¹ä¹Ÿèƒ½å¤Ÿè¢«æ‰§è¡Œ while (this.index &lt; this.handlers.size()) { this.handlers.get(this.index).process(this); this.index++; } } public static void main(String[] args) { Process p1 = (c) -&gt; { System.out.println(&quot;first start&quot;); c.next(); System.out.println(&quot;first end&quot;); }; Process p2 = (c) -&gt; { System.out.println(&quot;second start&quot;); c.next(); System.out.println(&quot;second end&quot;); }; Chain c = new Chain(); c.register(p1); c.register(p2); c.next(); }} golang gin ä¸­çš„é“¾å®ç°gin gin ä¹Ÿæ˜¯ä½¿ç”¨è´£ä»»é“¾çš„æ–¹å¼æ¥å¤„ç†å¯¹æŸä¸€ä¸ªè¯·æ±‚çš„é“¾å¼è°ƒç”¨çš„ã€‚å¯ä»¥é€šè¿‡å¦‚ä¸‹çš„æ–¹æ³•å®ç°ä¸€ä¸ªé“¾å¼è°ƒç”¨çš„è¿‡ç¨‹ã€‚ 12345router.GET(&quot;/example&quot;, func(c *Context) {}, func(context *Context) { }) å…¶ä¸­ Context æ˜¯ä¸€ä¸ªè¢«å¤ç”¨çš„ä¸Šä¸‹æ–‡ï¼Œä¿å­˜ http è¯·æ±‚çš„ headerã€writerã€body ç­‰ä¿¡æ¯ã€‚åœ¨è¿è¡Œæ—¶è¢«åŠ¨æ€çš„æ·»åŠ å¯¹åº”çš„ handlerChain åˆ° context ä¸­è¿›è¡Œé“¾å¼è°ƒç”¨æ‰§è¡Œã€‚ TODOï¼šå­—ç¬¦åŒ¹é…çš„å‰ç¼€æ ‘ã€‚goland ä½¿ç”¨ä¸€ä¸ª radix æ ‘æ¥å­˜å‚¨è¯·æ±‚è·¯å¾„ï¼Œæ¯ä¸ª request method ä¼šåŒ…å«ä¸€ä¸ªå¯¹åº”çš„ treeã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// serveHttp çš„å…¥å£func (engine *Engine) handleHTTPRequest(c *Context) { httpMethod := c.Request.Method rPath := c.Request.URL.Path unescape := false if engine.UseRawPath &amp;&amp; len(c.Request.URL.RawPath) &gt; 0 { rPath = c.Request.URL.RawPath unescape = engine.UnescapePathValues } if engine.RemoveExtraSlash { rPath = cleanPath(rPath) } // Find root of the tree for the given HTTP method // 1. æ‰¾åˆ°å¯¹åº”çš„ tree ä¸Šçš„èŠ‚ç‚¹ t := engine.trees for i, tl := 0, len(t); i &lt; tl; i++ { if t[i].method != httpMethod { continue } root := t[i].root // Find route in tree value := root.getValue(rPath, c.params, unescape) if value.params != nil { c.Params = *value.params } if value.handlers != nil { // 2. å°†å½“å‰çš„ tree ä¸Šæ³¨å†Œçš„ handler å¡«å……åˆ° context ä¸­ c.handlers = value.handlers c.fullPath = value.fullPath // 3. æ‰§è¡Œ handler chain c.Next() c.writermem.WriteHeaderNow() return } if httpMethod != &quot;CONNECT&quot; &amp;&amp; rPath != &quot;/&quot; { if value.tsr &amp;&amp; engine.RedirectTrailingSlash { redirectTrailingSlash(c) return } if engine.RedirectFixedPath &amp;&amp; redirectFixedPath(c, root, engine.RedirectFixedPath) { return } } break } if engine.HandleMethodNotAllowed { for _, tree := range engine.trees { if tree.method == httpMethod { continue } if value := tree.root.getValue(rPath, nil, unescape); value.handlers != nil { c.handlers = engine.allNoMethod serveError(c, http.StatusMethodNotAllowed, default405Body) return } } } c.handlers = engine.allNoRoute serveError(c, http.StatusNotFound, default404Body)} æ‰€ä»¥å…¶å®ï¼Œgin ä¸­å°†è¡¨ç¤ºå’Œå®é™…æ‰§è¡Œåˆ†ä¸ºäº†ä¸¤ä¸ªéƒ¨åˆ† æ‰§è¡Œ é“¾çš„æ‰§è¡ŒåŒ…å«åœ¨ context ä¸­ï¼Œé€šè¿‡ context.next() è°ƒç”¨é“¾çš„ä¸‹ä¸€ä¸ªæ–¹æ³• 12345678910func (c *Context) Next() { // ä½¿ç”¨ index æ ‡è¯†ç°åœ¨è®¿é—®åˆ°çš„èŠ‚ç‚¹ä¸‹æ ‡ c.index++ // ä½¿ç”¨ for å¾ªç¯ï¼Œè¿™æ ·å¯ä»¥ä¿è¯åœ¨ handler ä¸­ä¸æ˜¾ç¤ºè°ƒç”¨ next æ–¹æ³• // ä¹Ÿèƒ½æ‰§è¡Œå®Œè°ƒç”¨é“¾ for c.index &lt; int8(len(c.handlers)) { c.handlers[c.index](c) c.index++ }} è¡¨ç¤º é“¾è‡ªèº«çš„æ ‡è¯†ï¼Œç”±äºé“¾éœ€è¦åœ¨è°ƒç”¨çš„æ—¶å€™è°ƒç”¨ä¸‹ä¸€ä¸ªæ–¹æ³•ï¼Œæ‰€ä»¥éœ€è¦ä¸€ä¸ª context çš„å¼•ç”¨è¿›è¡Œè°ƒç”¨ï¼Œgolang ä½¿ç”¨ type ç»™äº†å¯¹åº”çš„ chain aliasï¼Œå®é™…å…¶å°±æ˜¯ä¸€ä¸ª handlerFunc çš„åˆ‡ç‰‡ 12345// HandlersChain defines a HandlerFunc array.type HandlersChain []HandlerFunc// HandlerFunc defines the handler used by gin middleware as return value.type HandlerFunc func(*Context) é“¾çš„æ³¨å†Œï¼Œæ˜¯é€šè¿‡ routerGroup ç®¡ç†ï¼Œæ¯ä¸ª routerGroup å¯¹åº”ä¸€ä¸ªå¤§é“¾æ¥ä¸‹çš„å°é“¾æ¥ 1234567891011121314151617181920212223242526272829303132333435// POST is a shortcut for router.Handle(&quot;POST&quot;, path, handle).// 1. é¦–å…ˆå°†å½“å‰é’ˆå¯¹ä¸€ä¸ª request method çš„æ–¹æ³•çš„é“¾å¼è°ƒç”¨æ³¨å†Œfunc (group *RouterGroup) POST(relativePath string, handlers ...HandlerFunc) IRoutes { return group.handle(http.MethodPost, relativePath, handlers)}// 2. ä¸ä¹‹å‰æ³¨å†Œåˆ° group ä¸Šçš„ handler è¿›è¡Œåˆå¹¶func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes { absolutePath := group.calculateAbsolutePath(relativePath) handlers = group.combineHandlers(handlers) group.engine.addRoute(httpMethod, absolutePath, handlers) return group.returnObj()}// 3. æ·»åŠ  handler çš„ç»å¯¹è·¯å¾„ ä¸ å¯¹åº”çš„ handlerChain åˆ° radix tree ç»“æ„ä¸­func (engine *Engine) addRoute(method, path string, handlers HandlersChain) { assert1(path[0] == '/', &quot;path must begin with '/'&quot;) assert1(method != &quot;&quot;, &quot;HTTP method can not be empty&quot;) assert1(len(handlers) &gt; 0, &quot;there must be at least one handler&quot;) debugPrintRoute(method, path, handlers) root := engine.trees.get(method) if root == nil { root = new(node) root.fullPath = &quot;/&quot; engine.trees = append(engine.trees, methodTree{method: method, root: root}) } root.addRoute(path, handlers) // Update maxParams if paramsCount := countParams(path); paramsCount &gt; engine.maxParams { engine.maxParams = paramsCount }} js koa ä¸­çš„æ´‹è‘±æ¨¡å‹å®ç°js çš„å®ç°å°±ç®€å•å¾ˆå¤šäº†ï¼Œkoa çš„å®ç°å¯ä»¥å‚è€ƒ koa-compose å…¶æœ¬è´¨æ€æƒ³ä¸ä¸Šé¢ä¸€ä¸ªå·®ä¸å¤šï¼Œä½†æ˜¯ç”±äº js æ”¯æŒé—­åŒ…ï¼Œä¹Ÿæ”¯æŒå°† func bind ä¸€ä¸ªè¿è¡Œæ—¶ï¼Œå› æ­¤å…¶åœ¨è°ƒç”¨çš„æ—¶å€™ï¼Œä¼ é€’çš„æ˜¯æ³¨å†Œåˆ° chain ä¸­çš„ä¸‹ä¸€ä¸ª functionï¼Œæ‰€ä»¥ç›´æ¥æ‰§è¡Œå³å¯ã€‚ä½†æ˜¯ä¹Ÿå› æ­¤ï¼Œå…¶å¿…é¡»è¦è°ƒç”¨æ˜¾ç¤ºçš„ next() æ–¹æ³•ã€‚ 12345678910111213141516171819202122232425262728293031323334function compose (middleware) { if (!Array.isArray(middleware)) throw new TypeError('Middleware stack must be an array!') for (const fn of middleware) { if (typeof fn !== 'function') throw new TypeError('Middleware must be composed of functions!') } /** * @param {Object} context * @return {Promise} * @api public */ // compose æ‰§è¡Œå®Œæ¯•åï¼Œç›¸å½“äºæŠŠè¿™ä¸ªé—­åŒ…ç»“æ„å£°æ˜å®Œæ¯• return function (context, next) { // last called middleware # // ç”¨é—­åŒ…æ¥ä¿å­˜å½“å‰è°ƒç”¨çš„åˆ° middleware ä¸­çš„å“ªä¸€ä¸ª let index = -1 // è¿”å› middleware çš„å…¥å£ return dispatch(0) // åªéœ€è¦ compose ç»“æŸå æ‰§è¡Œè¯¥æ–¹æ³•å³å¯ function dispatch (i) { if (i &lt;= index) return Promise.reject(new Error('next() called multiple times')) index = i let fn = middleware[i] if (i === middleware.length) fn = next if (!fn) return Promise.resolve() try { // fn ä¼šæ‰§è¡Œå½“å‰çš„ middleware åŒæ—¶å°† ä¸‹ä¸€ä¸ª dispatch ä¼ é€’ç»™æ–°çš„ fn æ–¹æ³•ä½œä¸ºç¬¬äºŒä¸ªå‚æ•°è°ƒç”¨ return Promise.resolve(fn(context, dispatch.bind(null, i + 1))); } catch (err) { return Promise.reject(err) } } }}","link":"/2021/03/09/design-pattern/"},{"title":"leetcode","text":"leetcode ä¾‹é¢˜è®°å½•ä¸‹ leetcode å€¼å¾—è®°å½•çš„ä¾‹é¢˜ kmp ç®—æ³•kmp ç®—æ³•çš„åŸå§‹å®ç°æ–¹æ³•åœ¨å¦ä¸€ç¯‡é‡Œé¢å·²ç»å†™è¿‡ï¼Œå®é™…ä¸Šå°±æ˜¯é€šè¿‡è®°å½•æ¨¡å¼ä¸²çš„ç›¸åŒçš„å‰åç¼€é•¿åº¦æ¥è·³è¿‡æ¨¡å¼ä¸²é‡æ–°åŒ¹é…çš„è·ç¦»ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839public int[] getNext(String pattern) { int[] next = new int[pattern.length()]; next[0] = -1; // æ¨¡å¼ä¸²ç›¸å·®ä¸€è¿›è¡ŒåŒ¹é… int k = -1, j = 0; while (j &lt; pattern.length() - 1) { // åŒ¹é…ç›¸åŒçš„å­—ç¬¦ if (k == -1 || pattern.charAt(k) == pattern.charAt(j)) { k++; j++; next[j] = k; } else { k = next[k]; } } return next;}public int match(String s, String pattern) { int[] next = getNext(pattern); int i = 0, j = 0; while (i &lt; s.length() &amp;&amp; j &lt; pattern.length()) { if (s.charAt(i) == pattern.charAt(j)) { i++; j++; } else { // å¤±é… é‡æ–°å®šä½ j = next[j]; } } if (j == pattern.length()) { return i - j; } else { return -1;// æ²¡æœ‰æ‰¾åˆ° }} æœ€çŸ­å›æ–‡ä¸²ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œé—®åœ¨å­—ç¬¦ä¸²å·¦è¾¹æ·»åŠ ä¸€äº›å­—æ¯åï¼Œå½¢æˆä¸€ä¸ªå›æ–‡ä¸²ï¼Œé—®å½¢æˆçš„å›æ–‡ä¸²ä¸­ï¼Œæœ€çŸ­çš„å›æ–‡ä¸²ä»€ä¹ˆã€‚ è¶…æ—¶è§£æ³• æœ€å¼€å§‹çš„æš´åŠ›æ€ç»´ï¼Œæƒ³å¾—å°±æ˜¯éå†è¿™ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰¾åˆ°ä¸­é—´å¯ä»¥ä½œä¸ºåˆ†éš”çº¿çš„åœ°æ–¹ï¼ˆå› ä¸ºå›æ–‡ä¸²å…¶å®å¯ä»¥çœ‹æˆåœ¨ä¸€ä¸ªåˆ†éš”ç‚¹çš„å·¦å³é•œåƒï¼‰ï¼Œç„¶åéå†æ‰€æœ‰çš„åˆ†å‰²çº¿ï¼Œæ¯”è¾ƒç”Ÿæˆçš„æœ€çŸ­å›æ–‡ä¸²ã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class Solution { // åªèƒ½åœ¨å­—ç¬¦ä¸²å‰é¢æ·»åŠ  public String shortestPalindrome(String s) { if (s.equals(&quot;&quot;)) return &quot;&quot;; String min = null; // ä½œä¸º palindrome çš„ä¸­å¿ƒç‚¹ è¿›è¡Œéå† for (int i = 0; i &lt;= s.length() / 2; i++) { String odd = odd(i, s); String even = even(i, s); String tmp = &quot;&quot;; if (odd.equals(&quot;&quot;) &amp;&amp; even.equals(&quot;&quot;)) { continue; } if (odd.equals(&quot;&quot;)) tmp = even; if (even.equals(&quot;&quot;)) tmp = odd; if (!odd.equals(&quot;&quot;) &amp;&amp; !even.equals(&quot;&quot;)) { tmp = even.length() &gt; odd.length() ? odd: even; } if (min == null) min = tmp; else if (min.length() &gt; tmp.length()) { min = tmp; } } return min; } private String odd(int i, String s) { int left = i - 1, right = i + 1; // è€ƒè™‘æœ€åçš„ palindrome æ˜¯å¥‡æ•°é•¿åº¦æƒ…å†µ boolean canPalindrome = true; while (left &gt;= 0 &amp;&amp; right &lt; s.length()) { if (s.charAt(left) != s.charAt(right)) { // ä¸èƒ½å½¢æˆ canPalindrome = false; break; } left--; right++; } String tmp = &quot;&quot;; if (!canPalindrome) return tmp; // å·¦è¾¹ä¸º -1 è¯´æ˜å³è¾¹é•¿è¦æŠŠå³è¾¹çš„åŠ è½½å·¦è¾¹ if (left == -1) { StringBuilder builder = new StringBuilder(s.substring(right)); tmp = builder.reverse().toString() + s; } return tmp; } private String even(int i, String s) { int left = i - 1, right = i; // è€ƒè™‘æœ€åçš„ palindrome æ˜¯å¥‡æ•°é•¿åº¦æƒ…å†µ boolean canPalindrome = true; while (left &gt;= 0 &amp;&amp; right &lt; s.length()) { if (s.charAt(left) != s.charAt(right)) { // ä¸èƒ½å½¢æˆ canPalindrome = false; break; } left--; right++; } String tmp = &quot;&quot;; if (!canPalindrome) return tmp; // å·¦è¾¹ä¸º -1 è¯´æ˜å³è¾¹é•¿è¦æŠŠå³è¾¹çš„åŠ è½½å·¦è¾¹ if (left == -1) { StringBuilder builder = new StringBuilder(s.substring(right)); tmp = builder.reverse().toString() + s; } return tmp; }} å‰åç¼€æ€ç»´ å…¶å®è€ƒè™‘ä¸€ä¸ªæœ€é•¿çš„å›æ–‡ä¸²çš„ï¼Œè‚¯å®šæ˜¯æŠŠè¾“å…¥ä¸²çš„é€†å‘è¾“å…¥ä¸²æ‹¼æ¥åˆ°åŸå§‹å­—ç¬¦ä¸²çš„å·¦è¾¹ã€‚ é‚£ä¹ˆï¼Œå¦‚æœè¿™ä¸ªé€†å‘çš„å­—ç¬¦ä¸²æœ‰ä¸€éƒ¨åˆ†è·Ÿè¾“å…¥ä¸²çš„å‰ä¸€éƒ¨åˆ†æ˜¯é‡åˆçš„å°±å¯ä»¥ç¼©çŸ­æ•´ä¸ªé•¿åº¦ã€‚ æ¯”å¦‚ abaaa ä¸å…¶é€† aaaba åœ¨çº¢è‰²çš„åœ°æ–¹é‡åˆ å³ abaaa çš„å‰ç¼€ a ä¸ aaaba çš„åç¼€ a é‡åˆ æ‰€ä»¥ åªéœ€è¦éå†å¾—åˆ°è¿™ä¸ªç›¸åŒçš„å‰åç¼€å³å¯ã€‚ ä¸‹è¿°ç®—æ³•ï¼Œç”±äºéœ€è¦åˆ¤æ–­ equals å› æ­¤å…¶æ‰§è¡Œæ•ˆç‡è¶‹è¿‘ o(n^2) 12345678910111213public String shortestPalindrome(String s) { String reverse = new StringBuilder(s).reverse().toString(); // å› ä¸ºä»åå‘å‰ å¯ä»¥ç›´æ¥è¿”å› æ‰¾åˆ°çš„ç¬¬ä¸€ä¸ª ä¸€å®šæ˜¯æœ€é•¿çš„ç›¸åŒå‰åç¼€ for (int i = s.length(); i &gt;= 0; i--) { // å‰ç¼€ç­‰äºåç¼€ if (s.subString(0, i).equals(reverse.subString(s.length() - i))) { // è¿™ä¸ªæ—¶å€™åªéœ€è¦åŠ ä¸Š reverse å»é™¤åç¼€çš„éƒ¨åˆ† return reverse.subString(0, s.length() - i) + s; } } return &quot;&quot;;} kmp æ€ç»´ ä¸Šé¢é‡‡ç”¨å‰åç¼€çš„æ–¹å¼å…¶å®å·²ç»æ¥è¿‘äº† kmp çš„æ€ç»´æ–¹å¼ï¼Œä¸è¿‡æ˜¯æ¯”è¾ƒæœ´ç´ çš„è§£æ³•ï¼Œå› ä¸ºè¿™ä¸ªæ—¶å€™è¿˜å¯ä»¥è¿›ä¸€æ­¥å¾—åˆ°ï¼Œå®é™…ä¸Šå°±æ˜¯æ±‚åŸä¸²çš„æœ€é•¿å›æ–‡å‰ç¼€ï¼Œå› ä¸ºè¿™æ ·é€†ä¸²ï¼Œåè½¬è¿‡æ¥åï¼Œä¸å…¶å›æ–‡å‰ç¼€ç›¸ç­‰çš„éƒ¨åˆ†ï¼Œå¯ä»¥ç›´æ¥æ¶ˆå»ã€‚ é‚£ä¹ˆå¯ä»¥ç›´æ¥æ‹¼æ¥æˆä¸€ä¸ªæœ€é•¿çš„å­—ç¬¦ä¸²ï¼Œå³ s + &quot;#&quot; + reverse é‚£ä¹ˆåªéœ€è¦æ‰¾åˆ°è¿™ä¸ªå­—ç¬¦ä¸²ç»“å°¾çš„éƒ¨åˆ†ç›¸ç­‰çš„å‰åç¼€é•¿åº¦ï¼Œå³å¯ä»¥åœ¨è¿”å›ç»“æœçš„æ—¶å€™åˆ é™¤é‡å¤çš„éƒ¨åˆ†ã€‚æ‰€ä»¥å¯ç”¨ kmp çš„ next æ•°ç»„æ±‚æ³•æ‰¾åˆ°æœ€é•¿çš„å‰åç¼€ï¼Œæ—¢å¯ä»¥å°†æ—¶é—´å¤æ‚åº¦è¿›ä¸€æ­¥é™ä½ã€‚ 12345678910111213141516171819202122232425262728293031public class ShortestPalindromeNew_214 { // keep æ˜¥æ‹›å°±è€ƒçš„è¿™ä¸ª public String shortestPalindrome(String s) { String reverse = new StringBuilder(s).reverse().toString(); String addedStr = s + &quot;#&quot; + reverse; int len = getMaxMatchLen(addedStr); return reverse.substring(0, reverse.length() - len) + s; } // æ‰¾åˆ°ä»æœ«å°¾å¼€å§‹çš„å‰åç¼€çš„æœ€é•¿åŒ¹é…é•¿åº¦ public int getMaxMatchLen(String s) { int[] next = new int[s.length() + 1]; next[0] = -1; int k = -1, j = 0; while (j &lt; s.length()) { if (k == -1 || s.charAt(k) == s.charAt(j)) { k++; j++; next[j] = k; } else { k = next[k]; } } return next[s.length()]; }} å•è°ƒæ ˆæ‰¾å‡ºæœ€å…·ç«äº‰åŠ›çš„å­åºåˆ—æ‰¾åˆ°å…¶ä¸­çš„ä¸€ä¸ªå­åºåˆ—ï¼Œæ»¡è¶³å…¶å­—ç¬¦ä¸²æ¯”è¾ƒæ˜¯æœ€å°çš„ç»“æœã€‚ brute-force å…¶å®æŸ¥çœ‹é¢˜æ„çš„è¯ï¼Œæœ€ä¸»è¦çš„å°±æ˜¯ä¸åœçš„æ‰¾åˆ°æœ€å°çš„æ•°å­— å¦‚æœæœ€å°çš„æ•°å­— å³ä¾§çš„æ•°å­—æ•°é‡å¤§äºç­‰äºå‰©ä¸‹è¦æ‰¾çš„æ•°é‡ï¼Œè¯´æ˜ç»§ç»­å‘å³ä¾§å¯»æ‰¾æœ€å°æ•° å¦‚æœå°äºè¦æ‰¾çš„æ•°é‡ï¼Œè¯´æ˜ç°åœ¨æœ€å°çš„æ•°åŠå…¶å³ä¾§æ‰€æœ‰çš„æ•°å­—å·²ç»ç»„æˆç­”æ¡ˆçš„ä¸€éƒ¨åˆ†ï¼Œå› ä¸ºè¿™ä¸ªæœ€å°æ•°å­—å½¢æˆçš„è¿™ä¸ªå­åºåˆ—ä¸€å®šæ˜¯å½“å‰è¿™ä¸ªæœ€å°çš„ é‡å¤å¯»æ‰¾ä¸Šè¿°è¿‡ç¨‹ï¼Œç›´åˆ°æ‰€æœ‰çš„æ•°å­—è¢«å¡«å…… å› æ­¤ä¸Šè¿°è¿‡ç¨‹æ˜¯ä¸€ä¸ªé€’å½’çš„è¿‡ç¨‹ï¼ˆé€’å½’è¶…æ—¶ï¼Œå®é™…ä¸Šå¦‚æœèƒ½å¤Ÿä¿å­˜ i -&gt; j çš„æœ€å°å€¼çš„ä½ç½®çš„è¯ï¼Œå°±ä¸ç”¨åœ¨é€’å½’ä¸­æ¯æ¬¡å¯»æ‰¾äº†ï¼Œåº”è¯¥èƒ½èŠ‚çº¦å¾ˆå¤šæ—¶é—´ï¼‰ 1234567891011121314151617181920212223242526272829303132// åŒä¸€ä¸ªä½ç½®ä¸Šçš„æ•°å­—æ›´å°çš„ int[] æ›´å…·ç«äº‰åŠ›// é—®é•¿åº¦ä¸º k çš„ int[] çš„æœ€æœ‰ç«äº‰åŠ›çš„ç»“æœæ˜¯ä»€ä¹ˆ// æ‰¾åˆ°æœ€å°çš„ çœ‹åé¢çš„æ•° æ˜¯å¦æ»¡è¶³å‰©ä¸‹çš„å¤§å° ä¸ç„¶å°±å¾€å‰æ‰¾ æ‰¾åˆ°å‰©ä¸‹çš„æœ€å°çš„public int[] mostCompetitiveBruteForce(int[] nums, int k) { if (k &gt; nums.length) return new int[k]; if (k == nums.length) return nums; int[] res = new int[k]; recursion(nums, res, 0, nums.length - 1, 0, res.length - 1); return res;}// ç›´æ¥ä½¿ç”¨é€’å½’ æ¯æ¬¡æ‰¾åˆ° i-&gt;j çš„æœ€å°å€¼ ç„¶ååˆ¤æ–­å»ä»€ä¹ˆå…¶ä»–åœ°æ–¹å¡«å……å³å¯public void recursion(int[] nums, int[] res, int i, int j, int n, int m) { if (n &gt; m) return; int min = i; for (int k = i; k &lt;= j; k++) { if (nums[k] &lt; nums[min]) min = k; } // å‰©ä¸‹çš„æ•°å­—ä¸è¶³ä»¥å¡«æ»¡ m if (j - min + 1 &lt;= m - n + 1) { for (int k = j; k &gt;= min; k--) { res[m--] = nums[k]; } recursion(nums, res, i, min - 1, n, m); return; } // è¿˜è¶³å¤Ÿå¡«æ»¡ ä»å‰©ä¸‹çš„é‡Œé¢å–è¾ƒå°çš„æ•°å­— ç„¶åå¡«æ»¡ res[n++] = nums[min]; recursion(nums, res, min + 1, j, n, m);} å•è°ƒæ ˆ å®é™…ä¸Šé¢˜ç›®å¯»æ‰¾çš„æ˜¯æœ€å°çš„æ•°å­—å½¢æˆçš„ç»“æœï¼Œé‚£ä¹ˆå¯ä»¥ç”¨ä¸€ä¸ªå•è°ƒæ ˆæ¥ä¿å­˜å‰é¢çš„è®¿é—®çš„æ•°ç»„ï¼Œå¦‚æœå½“å‰è®¿é—®çš„æ•°å­—æ¯”ä¹‹å‰çš„æ•°å­—å°çš„è¯ï¼Œè¯´æ˜åº”è¯¥ä»è¿™ä¸ªæ•°å­—ä¹‹åå¼€å§‹å¯»æ‰¾ï¼Œå…¶ç»“æœä¹Ÿå°±æ˜¯æŠŠä¹‹å‰çš„æ•°ç»„å¼¹å‡ºæ ˆ 12345678910111213141516171819202122232425262728public int[] mostCompetitive(int[] nums, int k) { if (k &gt; nums.length) return new int[k]; if (k == nums.length) return nums; int[] res = new int[k]; // å•è°ƒæ ˆ Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) { int num = nums[i]; // å¦‚æœå½“å‰æ•°å­—æ¯” stack é‡Œé¢çš„è¦å° è¯´æ˜æ¦‚è¦å¼¹å‡º // æˆ–è€…num åå‰©ä¸‹çš„é•¿åº¦ä¸å¤Ÿäº†å°±ä¸èƒ½å¼¹å‡ºäº† while (!stack.isEmpty() &amp;&amp; stack.peekLast() &gt; num &amp;&amp; k - stack.size() &lt; nums.length - i) { stack.removeLast(); } if (stack.size() &lt; k) { stack.addLast(num); } } k--; while (k &gt;= 0) { res[k] = stack.removeLast(); k--; } return res;} ä¸‹ä¸€ä¸ªæ›´å¤§å…ƒç´  II ç¤ºä¾‹ è¾“å…¥: [1,2,1] è¾“å‡º: [2,-1,2] è§£é‡Š: ç¬¬ä¸€ä¸ª 1 çš„ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°æ˜¯ 2ï¼› æ•°å­— 2 æ‰¾ä¸åˆ°ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°ï¼› ç¬¬äºŒä¸ª 1 çš„ä¸‹ä¸€ä¸ªæœ€å¤§çš„æ•°éœ€è¦å¾ªç¯æœç´¢ï¼Œç»“æœä¹Ÿæ˜¯ 2ã€‚ ç”¨å•è°ƒæ ˆæ¥ä¿å­˜ä¹‹å‰éå†è¿‡çš„è·¯å¾„ï¼Œä¹‹åè®¿é—®çš„æ•°å­—å¦‚æœæ¯”è·¯å¾„ä¸Šçš„æ•°å­—å¤§çš„è¯ï¼Œè¯´æ˜å¯¹äºæ ˆä¸­ä¿å­˜çš„è·¯å¾„ä¸Šçš„æ•°å­—ä¸‹ä¸€ä¸ªæ›´å¤§çš„æ•°æ˜¯å½“å‰è®¿é—®çš„æ•°ã€‚ 12345678910111213141516171819public int[] nextGreaterElements(int[] nums) { // ä¼˜åŒ–å¾ªç¯ int n = nums.length; int[] res = new int[n]; // æ·»åŠ çš„é»˜è®¤å€¼ Arrays.fill(res, -1); // å•è°ƒæ ˆä¿å­˜ nums ä¸­çš„ä¸‹æ ‡ Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); // å› ä¸ºæ˜¯å¾ªç¯æ•°ç»„ æ‰€ä»¥éå†åˆ°æœ€åä¸€ä¸ªçš„æ—¶å€™ è¿˜è¦çœ‹å…¶å·¦ä¾§çš„ // æ‰€ä»¥ç›¸å½“äºæ˜¯ä¸¤å€é•¿åº¦ for (int i = 0; i &lt; 2 * n - 1; i++) { // stack é‡Œé¢æ”¾ç½®çš„éƒ½æ˜¯æ¯” nums[i % n] å°çš„æ•° åœ¨å…¶è¢«å¼¹å‡ºçš„æ—¶å€™ è¯´æ˜ä¹‹åç¬¬ä¸€ä¸ªæ¯”ä»–å¤§çš„æ•° å°±æ˜¯è®¿é—®çš„ nums[i % n] while (!stack.isEmpty() &amp;&amp; nums[i % n] &gt; nums[stack.peek()]) { res[stack.pop()] = nums[i % n]; } stack.push(i % n); } return res;} ç§»è°ƒ k ä½æ•°å­— é—®å¦‚æœåœ¨åŸå§‹å­—ç¬¦ä¸²ä¸­ï¼Œç§»æ‰ k ä½æ•°å­—ï¼Œæœ€åå½¢æˆçš„æœ€å°å­—ç¬¦ä¸²æ˜¯ä»€ä¹ˆ å¦‚æœ k å¤§äºç­‰äºåŸæ¥å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œé‚£ä¹ˆå°±ç›¸å½“äºåˆ é™¤äº†æ‰€æœ‰çš„æ•°å­—ï¼Œç›´æ¥è¿”å› â€œ0â€ å³å¯ è€ƒè™‘ k å°äºçš„æƒ…å†µ æ—¢ç„¶è¦åˆ é™¤æ•°å­—ï¼Œå…ˆè€ƒè™‘åˆ é™¤ä¸€ä¸ªæ•°å­—çš„æƒ…å†µï¼Œå¦‚ 45 ä¸­åˆ é™¤ä¸€ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆç»“æœå°±æ˜¯åˆ é™¤5 ä¿ç•™4ï¼Œè€ƒè™‘ 54 ä¹Ÿæ˜¯åˆ é™¤5 ä¿ç•™4 é‚£æ—¢ç„¶å¦‚æ­¤ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä»å­—ç¬¦ä¸²ä¸­åˆ é™¤ä¸€ä¸ªæ•°å­—çš„è¯ç›¸å½“äºåˆ é™¤çš„æ•°å­—ä¹‹å‰çš„ä¸€ä¸ªæ•°æ›¿ä»£å½“å‰è¿™ä½æ•°ï¼Œé‚£ä¹ˆè¦ä½¿ç»“æœæ›´å°ï¼Œæ›¿ä»£çš„è¿™ä¸ªæ•°ä¸€å®šè¦å°äºä¹‹å‰çš„åˆ é™¤çš„é‚£ä¸ªæ•°ï¼Œå³ Dk &lt; D(k-1) åˆ é™¤ Dk æ¯æ¬¡éå†åˆ é™¤ä¸€ä¸ªæ•°å­— 12345678910111213141516171819202122232425262728public String removeKdigitsDeleteOne(String num, int k) { // ç§»é™¤æ‰€æœ‰çš„æ•°å­— if (k &gt;= num.length()) return &quot;0&quot;; while (k &gt; 0) { num = deleteOne(num); k--; } // å»é™¤å‰å¯¼ 0 StringBuilder builder = new StringBuilder(); int i = 0; while (i &lt; num.length()) { if (num.charAt(i) != '0') break; i++; } while (i &lt; num.length()) { builder.append(num.charAt(i++)); } return builder.length() == 0 ? &quot;0&quot; : builder.toString();}private String deleteOne(String num) { for (int i = 1; i &lt; num.length(); i++) { // ç°åœ¨å¯ä»¥åˆ é™¤ i - 1 è¿™ä¸ªä½ç½®çš„æ•°äº† if (num.charAt(i) &lt; num.charAt(i - 1)) return num.substring(0, i - 1) + num.substring(i); } // åˆ é™¤æœ€åä¸€ä¸ªæ•°å­— return num.substring(0, num.length() - 1);} å•è°ƒæ ˆ æ¯æ¬¡å»åˆ é™¤çš„ä¸€ä¸ªæ•°å­—çš„æ—¶é—´æ•ˆç‡å¤ªä½ï¼Œå› æ­¤å¯ä»¥è€ƒè™‘ç”¨ä¸€ä¸ªå•è°ƒæ ˆæ¥ä¿å­˜å°äºå½“å‰æ•°çš„æ•°å­—ï¼Œå½“éå†åˆ°çš„ä¸‹æ ‡å¤§äºå•è°ƒæ ˆçš„å°¾æ—¶ï¼Œè¯´æ˜å‰é¢çš„æ•°å­—è¯¥åˆ é™¤äº† 123456789101112131415161718192021222324252627282930313233public String removeKdigits(String num, int k) { // ç§»é™¤æ‰€æœ‰çš„æ•°å­— if (k &gt;= num.length()) return &quot;0&quot;; // åˆ é™¤æ•°å­—çš„è¯ ä¸€å®šè¦åˆ é™¤çš„æ˜¯ å‰é¢ä¸€ä¸ªæ•°å­— å¤§äº åé¢ä¸€ä¸ªæ•°å­—çš„åœ°æ–¹ // å› ä¸ºè¿™æ ·æ‰èƒ½åœ¨åˆ é™¤åä¿è¯å‰©ä¸‹çš„å½¢æˆæ›´å°çš„ç»“æœ Deque&lt;Character&gt; queue = new LinkedList&lt;&gt;(); for (char c : num.toCharArray()) { // å•è°ƒæ ˆä¸­ä¿å­˜ä¹‹å‰çš„ç»“æœ while (!queue.isEmpty() &amp;&amp; queue.peekLast() &gt; c &amp;&amp; k &gt; 0) { queue.removeLast(); k--; } queue.add(c); } // å‰©ä¸‹çš„ ä¸€å®šæ˜¯ä¸€ä¸ªä»å°åˆ°å¤§çš„åºåˆ— while (k &gt; 0) { k--; queue.removeLast(); } StringBuilder builder = new StringBuilder(); while (!queue.isEmpty()) { if (queue.peekFirst() == '0') queue.removeFirst(); else break; } while (!queue.isEmpty()) { builder.append(queue.removeFirst()); } return builder.length() == 0 ? &quot;0&quot; : builder.toString();} æ»‘åŠ¨çª—å£æœ€å°è¦†ç›–å­ä¸²æ»‘åŠ¨çª—å£ å½“å‰éå†çš„å­—ç¬¦ä¸²æ²¡æœ‰åŒ…å«æ‰€æœ‰å­—ç¬¦çš„æ—¶å€™ï¼Œå³ç§»å³æ¸¸æ ‡ ç„¶åå·¦ç§»å·¦æ¸¸æ ‡ï¼Œç›´åˆ°ä¸å†åŒ…å«è¯¥å­—ç¬¦ä¸² åœ¨ç§»åŠ¨çª—å£çš„æ—¶å€™ä¸å¬æ¯”è¾ƒå³å¯ 123456789101112131415161718192021222324252627282930313233func checkEqualMap(mapForT, window map[int32]int) bool { for k, v := range mapForT { if count, ok := window[k]; !ok || count &lt; v { return false } } return true}func minWindow(s string, t string) string { i, j := 0, 0 res := &quot;&quot; mapForT := make(map[int32]int) for _, char := range t { mapForT[char]++ } window := make(map[int32]int) for j &lt; len(s) || i &lt; j { for j &lt; len(s) &amp;&amp; !checkEqualMap(mapForT, window) { window[int32(s[j])]++ j++ } if checkEqualMap(mapForT, window) &amp;&amp; (res == &quot;&quot; || len(res) &gt; j-i) { res = s[i:j] } window[int32(s[i])]-- i++ } return res} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { // è¿”å›true è¯´æ˜é‡Œé¢å·²ç»åŒ…å«äº†ä¸€ä¸ªå®Œæ•´çš„ t å­—ç¬¦ä¸² public boolean checkMap(HashMap&lt;Character, Integer&gt; mapForT, HashMap&lt;Character, Integer&gt; mapForS) { for (Character key : mapForT.keySet()) { if (!mapForS.containsKey(key) || mapForS.get(key) &lt; mapForT.get(key)) return false; } return true; } public String minWindow(String s, String t) { // è¿™éƒ½æ˜¯ä¸å­˜åœ¨çš„ if (s == null || t == null || s.length() &lt; t.length()) return &quot;&quot;; String minStr = null; HashMap&lt;Character, Integer&gt; mapForT = new HashMap&lt;&gt;(); for (char character : t.toCharArray()) { if (!mapForT.containsKey(character)) { mapForT.put(character, 1); } else { mapForT.put(character, mapForT.get(character) + 1); } } HashMap&lt;Character, Integer&gt; mapForS = new HashMap&lt;&gt;(); for (int i = 0; i &lt; t.length(); i++) { Character character = s.charAt(i); if (!mapForS.containsKey(character)) { mapForS.put(character, 1); } else { mapForS.put(character, mapForS.get(character) + 1); } } // æ»‘åŠ¨çª—å£å¤§å° int left = 0, right = t.length() - 1; do { while (checkMap(mapForT, mapForS) &amp;&amp; right - left + 1 &gt;= t.length()) { if (minStr == null || minStr.length() &gt; right - left + 1) { minStr = s.substring(left, right + 1); } mapForS.put(s.charAt(left), mapForS.get(s.charAt(left)) - 1); left++; } right++; if (right &gt;= s.length()) continue; if (!mapForS.containsKey(s.charAt(right))) { mapForS.put(s.charAt(right), 1); } else { mapForS.put(s.charAt(right), mapForS.get(s.charAt(right)) + 1); } } while (right &lt;= s.length() - 1 &amp;&amp; right - left + 1 &gt; t.length()); return minStr == null ? &quot;&quot; : minStr; }} K ä¸ªä¸åŒæ•´æ•°çš„å­æ•°ç»„æ‰¾åˆ° A é‡Œé¢çš„è¿ç»­å­æ•°ç»„ï¼Œå…¶ä¸­å­æ•°ç»„é‡Œé¢çš„æ•°æ®çš„ distinct åªæœ‰ K ä¸ª è¿™ä¸ªé¢˜ç›®ä¸€æƒ³å°±æ˜¯æ»‘åŠ¨çª—å£ ä½†æ˜¯ å¾ˆä¸å¥½è®¡ç®— ç­‰äº K çš„æ—¶å€™ æ•°ç»„æœ‰å¤šå°‘ä¸ª ä½†æ˜¯è®¡ç®— å°äºç­‰äº K çš„æ¯”è¾ƒå¥½è®¡ç®—ï¼Œå¯ä»¥ä¾æ®ä»¥ä¸‹è§„åˆ™ ä»¥ [1,2,1,2,3] ä¸ºä¾‹ï¼Œå·¦è¾¹ç•Œå›ºå®šçš„æ—¶å€™ï¼Œæ°å¥½å­˜åœ¨ 2 ä¸ªä¸åŒæ•´æ•°çš„å­åŒºé—´ä¸º [1,2],[1,2,1],[1,2,1,2]ï¼Œæ€»æ•°ä¸º 3ã€‚å…¶å€¼ä¸ºä¸‹æ ‡ 3 - 1 + 1ï¼Œå³åŒºé—´ [1..3] çš„é•¿åº¦ã€‚ å› ä¸ºï¼Œleft, right åŒæ—¶åœˆå®šäº†ä¸€ç»„æ»¡è¶³ &lt;= k çš„é¢˜æ„çš„é•¿åº¦èŒƒå›´ é‚£ä¹ˆï¼ŒåŒ…å« left çš„å­æ•°ç»„æ•°é‡è‚¯å®šæ˜¯ right - left + 1ï¼Œå› ä¸ºç›¸å½“äºæ¯æ¬¡ç»™æ•°ç»„é‡Œé¢æ·»åŠ ä¸€ä¸ªæ•°([1,2] [1,2,1] [1,2,1,2]) æ‰€ä»¥ right æ¯” left å¤šå‡ ä¸ªæ•° å°±èƒ½å½¢æˆå‡ ä¸ªå­æ•°ç»„ 12345678910111213141516171819202122232425262728func subarraysWithKDistinct(A []int, K int) int { return atMostK(A, K) - atMostK(A, K-1)}// å› ä¸ºæ±‚è§£ æ°å¥½K ä¸å¥½å¼„ æ±‚è§£ æœ€å¤§K æ¯”è¾ƒå¥½å¼„func atMostK(A []int, K int) int { i, j := 0, 0 // ä½œä¸ºä¸€ä¸ª set ä¿å­˜çª—å£å†…çš„æ‰€æœ‰ distinct æ•°æ® window := make(map[int]int) res := 0 for j &lt; len(A) { window[A[j]]++ j++ for len(window) &gt; K { window[A[i]]-- if window[A[i]] == 0 { delete(window, A[i]) } i++ } res += j - i + 1 } return res} 1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.HashMap;import java.util.HashSet;import java.util.Map;import java.util.Set;public class SubarraysWithKDistinct_992 { // å¦‚æœ A é‡Œé¢ public int subarraysWithKDistinct(int[] A, int K) { return subArraysDistinctAtMostK(A, K) - subArraysDistinctAtMostK(A, K - 1); } // è®¡ç®—æœ€å¤šçš„æœ‰å¤šå°‘ä¸ªçš„è¯ å¯ä»¥å›ºå®šå·¦è¾¹ç•Œ ç„¶åè®¡ç®— private int subArraysDistinctAtMostK(int[] array, int k) { Map&lt;Integer, Integer&gt; window = new HashMap&lt;&gt;(); int res = 0; int left = 0, right = 0; while (right &lt; array.length) { // å›ºå®šå·¦è¾¹ç•Œ ç§»åŠ¨å³è¾¹ç•Œ window.put(array[right], window.getOrDefault(array[right], 0) + 1); // è¿™è¾¹å·²ç»éœ€è¦å‡é™¤äº† while (left &lt;= right &amp;&amp; window.size() &gt; k) { window.put(array[left], window.get(array[left]) - 1); if (window.get(array[left]) == 0) window.remove(array[left]); left++; } // è¿™ä¸ªåœ°æ–¹æ˜¯å› ä¸ºå³è¾¹ç•Œåˆ°å·¦è¾¹ä¹‹é—´çš„æ•°å­— ä¸€å®šæ˜¯å°äºç­‰äº K ä¸ªä¸åŒçš„æ•°å­—çš„ // é‚£ä¹ˆèƒ½å¤Ÿä»¥å·¦è¾¹ç•Œå½¢æˆçš„ ä¸€å®šæ˜¯ä¸­çš„ä¸€ä¸ªå­æ•°ç»„ å¦‚ // ä»¥ [1,2,1,2,3] ä¸ºä¾‹ï¼Œå·¦è¾¹ç•Œå›ºå®šçš„æ—¶å€™ï¼Œæ°å¥½å­˜åœ¨ 2 ä¸ªä¸åŒæ•´æ•°çš„å­åŒºé—´ä¸º [1,2],[1,2,1],[1,2,1,2]ï¼Œæ€»æ•°ä¸º 3ã€‚å…¶å€¼ä¸ºä¸‹æ ‡ 3 - 1 + 1ï¼Œå³åŒºé—´ [1..3] çš„é•¿åº¦ã€‚ res += right - left; right++; } return res; } public static void main(String[] args) { System.out.println(new SubarraysWithKDistinct_992().subarraysWithKDistinct(new int[]{1,2,1,2,3}, 2)); System.out.println(new SubarraysWithKDistinct_992().subarraysWithKDistinct(new int[]{1,2,1,3,4}, 3)); }} æœ€å¤§è¿ç»­ 1 çš„ä¸ªæ•° IIIæœ€å¤§è¿ç»­ 1 çš„ä¸ªæ•°ï¼ŒA ä¸­åªæœ‰ 0 å’Œ 1ï¼Œå…¶ä¸­å¯ä»¥å˜æ¢æœ€å¤š K ä¸ª 0 æˆä¸º 1ï¼Œé—®æœ€é•¿çš„è¿ç»­ 1 çš„é•¿åº¦ä¸ºå¤šå°‘ æ»‘åŠ¨çª—å£ï¼Œçª—å£ä¸­æœ€å¤šå«æœ‰ K ä¸ª 0 å³å¯ 123456789101112131415161718192021222324252627282930func longestOnes(A []int, K int) int { // è¿”å›å€¼ res := 0 left, right := 0, 0 zeros := 0 for right &lt; len(A) { // ç”¨å¤–å±‚å¾ªç¯å¸¦åŠ¨ right ç§»åŠ¨ if A[right] == 0 { zeros++ } // è¿™ä¸ªæ—¶å€™è¦ç§»åŠ¨å·¦ä¾§çš„ left ä¿éšœ zeros å° for zeros &gt; K { if A[left] == 0 { zeros-- } left++ } // æ¯è½®éƒ½å»æ¯”è¾ƒå³å¯ res = max(res, right - left + 1) right++ } return res}func max(a, b int) int { if a &gt; b { return a } return b} ç»å¯¹å·®ä¸è¶…è¿‡é™åˆ¶çš„æœ€é•¿è¿ç»­å­æ•°ç»„ ç»™å®šä¸€ä¸ªæ•°ç»„ nums å’Œ limitï¼Œæ‰¾åˆ°æœ€é•¿çš„è¿ç»­æ•°ç»„ï¼Œå…¶ä¸­ä»»æ„ä¸¤ä¸ªæ•°çš„å·®å€¼ä¸è¶…è¿‡ limit ä¸Šé¢è¿™å¥è¯æ¢ä¸ªè¯´æ³•è¯´çš„å°±æ˜¯ æœ€å¤§å€¼å’Œæœ€å°å€¼ ä¹‹å·®ä¸è¶…è¿‡ limitï¼Œå› æ­¤å¦‚æœèƒ½å¤Ÿ o(1) çš„æ‹¿åˆ°çª—å£çš„ æœ€å¤§æœ€å°å€¼ï¼Œé‚£ä¹ˆå°±æ¯”è¾ƒæ–¹ä¾¿ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104package classictype MaxMinQueue struct { stack1 MaxMinStack stack2 MaxMinStack}func (queue *MaxMinQueue) Push(val int) { queue.stack1.Push(val)}func (queue *MaxMinQueue) Shift() int { if queue.stack2.Len() == 0 { for queue.stack1.Len() &gt; 0 { queue.stack2.Push(queue.stack1.Pop()) } } return queue.stack2.Pop()}func (queue *MaxMinQueue) Max() int { if queue.stack1.Len() == 0 { return queue.stack2.Max() } else if queue.stack2.Len() == 0 { return queue.stack1.Max() } return max(queue.stack2.Max(), queue.stack1.Max())}func (queue *MaxMinQueue) Min() int { if queue.stack1.Len() == 0 { return queue.stack2.Min() } else if queue.stack2.Len() == 0 { return queue.stack1.Min() } return min(queue.stack2.Min(), queue.stack1.Min())}func (queue *MaxMinQueue) Len() int { return queue.stack1.Len() + queue.stack2.Len()}type MaxMinStack struct { // è¿™ä¸¤ä¸ªä¸ç”¨ slice ç”¨ list ä¹‹ç±»çš„é“¾è¡¨ å¯èƒ½ä¼šå¿«ä¸€ç‚¹å„¿ data []int maxes []int mins []int}func (ms *MaxMinStack) Push(val int) { ms.data = append(ms.data, val) if len(ms.maxes) &gt; 0 { ms.maxes = append(ms.maxes, max(ms.maxes[len(ms.maxes)-1], val)) } else { ms.maxes = append(ms.maxes, val) } if len(ms.mins) &gt; 0 { ms.mins = append(ms.mins, min(ms.mins[len(ms.mins)-1], val)) } else { ms.mins = append(ms.mins, val) }}func (ms *MaxMinStack) Pop() int { res := ms.data[len(ms.data)-1] ms.data = ms.data[:len(ms.data)-1] ms.maxes = ms.maxes[:len(ms.maxes)-1] ms.mins = ms.mins[:len(ms.mins)-1] return res}func (ms *MaxMinStack) Max() int { return ms.maxes[len(ms.maxes)-1]}func (ms *MaxMinStack) Min() int { return ms.mins[len(ms.mins)-1]}func (ms *MaxMinStack) Len() int { return len(ms.data)}// æ‰¾åˆ°ä¸€ä¸ªæœ€é•¿çš„è¿ç»­å­æ•°ç»„ å…¶ä»»æ„ä¸¤ä¸ªå…ƒç´ ä¹‹é—´çš„å·®å€¼ å°äºç­‰äº limitfunc longestSubarray(nums []int, limit int) int { // å°±æ˜¯ç»´æŠ¤ä¸€ä¸ª queue ä¸ºäº†æ–¹ä¾¿ åº”è¯¥åœ¨ o(1) çš„æ—¶é—´å†…è·å¾—å…¶ æœ€å¤§æœ€å°å€¼ left, right := 0, 0 window := &amp;MaxMinQueue{stack1: MaxMinStack{}, stack2: MaxMinStack{}} res := 0 for right &lt; len(nums) { window.Push(nums[right]) if window.Len() &gt; 0 &amp;&amp; window.Max() - window.Min() &lt;= limit { res = max(res, right - left + 1) } for window.Len() &gt; 0 &amp;&amp; window.Max() - window.Min() &gt; limit { window.Shift() left++ } right++ } return res} çˆ±ç”Ÿæ°”çš„ä¹¦åº—è€æ¿ç»™å®šä¸€ä¸ª grumpy ä»¥åŠ custormers åœ¨ grumpy == 0 çš„æ—¶å€™ å¯ä»¥åŠ ä¸Š custormers çš„å¯¹åº”å€¼ï¼Œé—®å¦‚æœæœ‰è¿ç»­çš„ X ä¸ª gurmpy å¯ä»¥ä¸º 0 æœ€å¤§ customers çš„å’Œä¸ºå¤šå°‘ è‡ªå·±çš„åšæ³• ç»´æŠ¤ä¸€ä¸ªå‰ç¼€å’Œæ•°ç»„ sumï¼Œè¡¨ç¤ºå‰ i ä¸ªçš„å’Œä¸ºå¤šå°‘ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç”¨æ»‘åŠ¨çª—å£å°†æ•°ç»„åˆ†ä¸ºä¸‰æ®µ [0-&gt;l](å¯ä»¥ç”¨ sum æ•°ç»„æ±‚å¾—) [l-&gt;r](å…¨éƒ¨å˜ä¸º 0 æ‰€ä»¥æ˜¯ç›´æ¥æ±‚å’Œçš„) [r-&gt;len](å¯ä»¥ç”¨ sum æ•°ç»„æ±‚å¾—) 123456789101112131415161718192021222324public int maxSatisfiedWithSumArray(int[] customers, int[] grumpy, int X) { // sum[i] ä¿å­˜ customers[i] ä¹‹å‰çš„æ‰€æœ‰æ»¡è¶³è¦æ±‚çš„å’Œ int[] sum = new int[customers.length + 1]; for (int i = 1; i &lt;= customers.length; i++) { sum[i] = sum[i - 1]; if (grumpy[i - 1] == 0) { sum[i] += customers[i - 1]; } } // ç»“æœ int res = 0; // ç»´æŠ¤ä¸€ä¸ªçª—å£ è¿™ä¸ªçª—å£é•¿åº¦ä¸º X å…¨éƒ¨è®¤ä¸ºæ˜¯å¯ä»¥åŠ çš„ int windowSum = 0; for (int i = 0; i &lt; X; i++) { windowSum += customers[i]; } for (int i = X; i &lt; customers.length; i++) { res = Math.max(res, sum[i-X] + windowSum + sum[customers.length] - sum[i]); windowSum = windowSum - customers[i - X] + customers[i]; } res = Math.max(res, sum[customers.length-X] + windowSum); return res;} é¢˜è§£ é¢˜è§£æ›´è¿›ä¸€æ­¥ï¼Œå°† customers æ•°ç»„æ ¹æ® grumpy çš„å–å€¼åˆ†ä¸ºä¸¤ç±»ï¼Œä¸€ç±»æ˜¯ grumpy ç­‰äº 1 é‚£ä¹ˆæ˜¯å¯ä»¥ç›´æ¥åŠ ä¸Šçš„ï¼Œä¸€ç±»æ˜¯ grumpy == 0ï¼Œå¯ä»¥åœ¨é•¿åº¦ä¸º X çš„æ»‘åŠ¨çª—å£ä¸­ increase åˆ° ç¬¬ä¸€ç±»çš„ 123456789101112131415161718192021public int maxSatisfied(int[] customers, int[] grumpy, int X) { // åˆ†ä¸¤æ­¥è®¡ç®— ä¸€ä¸ªè®¡ç®—æ»¡è¶³è¦æ±‚çš„æ‰€æœ‰å’Œ total å¦ä¸€ä¸ªçª—å£å¯ä»¥é¢å¤–å¢åŠ çš„å€¼ int total = 0; for (int i = 0; i &lt; customers.length; i++) { // grumpy[i] == 0 çš„æ—¶å€™ æ‰åŠ ä¸Š total += (1 - grumpy[i]) * customers[i]; } // éå†å¯ä»¥å¢åŠ çš„å€¼ æ‰¾åˆ°æœ€å¤§çš„ int window = 0; // çª—å£éå†å¯ä»¥å¢åŠ çš„å€¼ for (int i = 0; i &lt; X; i++) { // çª—å£å¯ä»¥å¢åŠ çš„å€¼ æ˜¯ grumpy[i] == 1 window += grumpy[i] * customers[i]; } int res = window; for (int i = X; i &lt; customers.length; i++) { window = window - grumpy[i-X] * customers[i-X] + grumpy[i] * customers[i]; res = Math.max(res, window); } return total + res;} äºŒè¿›åˆ¶é¢˜ç›®è¿æ¥è¿ç»­äºŒè¿›åˆ¶æ•°å­—é¢˜ç›®è¦æ±‚çš„æ˜¯å°† 1 -&gt; n çš„äºŒè¿›åˆ¶çš„å­—ç¬¦æ‹¼æ¥èµ·æ¥è¡¨ç¤ºä¸€ä¸ªè¶…å¤§çš„äºŒè¿›åˆ¶æ•°ï¼Œç„¶åå°† äºŒè¿›åˆ¶ æ•°è½¬æ¢æˆä¸º åè¿›åˆ¶ æ•°ï¼Œå¹¶æ¨¡ä¸Š 1000000007ã€‚ å¦‚æœç›´æ¥æŠŠæ¯ä¸ªæ•°å­—è½¬æ¢æˆä¸ºäºŒè¿›åˆ¶æ•°ï¼Œç„¶åæ‹¼æ¥è½¬æ¢ï¼Œå› ä¸ºä¼šè¶…æ—¶ï¼Œå› ä¸º n çš„è¿”å›è¾¾åˆ°äº† 10^5ã€‚ æ‰€ä»¥è€ƒè™‘åœ¨éå†çš„æ—¶å€™ç›´æ¥å¯¹æ¯ä¸€ä½æ•°è¿›è¡Œå¤„ç†ã€‚ è§‚å¯Ÿäº‹ä¾‹ï¼Œå¯ä»¥çœ‹åˆ°å…¶å®ç›¸å½“äº 1(1) &lt;&lt; 4 ä½æ•° 10(2) &lt;&lt; 2 11(3) ä¸å˜ï¼Œæ‰€ä»¥åªéœ€è¦åœ¨æ¯ä¸ªæ•°å­—éå†çš„æ—¶å€™ï¼Œå°†ä¸Šä¸€ä¸ªæ•°å­—å½¢æˆçš„ç»“æœå·¦ç§»å½“å‰æ•°å­—å¯¹åº”çš„äºŒè¿›åˆ¶çš„ä½æ•°çš„é•¿åº¦ï¼ŒåŠ ä¸Šè¯¥æ•°å³å¯ n = 3, res = 27 äºŒè¿›åˆ¶è¡¨ç¤ºä¸º 1 -> 1, 2 -> 10, 3 -> 11 27 äºŒè¿›åˆ¶è¡¨ç¤ºä¸º 11011 è®¡ç®—äºŒè¿›åˆ¶æ•°çš„é•¿åº¦çš„æ—¶å€™ï¼Œå¯ä»¥ç®€å•çš„é‡‡ç”¨éå†çš„æ–¹å¼è¿›è¡Œã€‚ [1] ä¸€ä½æ•°é•¿åº¦ [2,3] äºŒä½æ•°é•¿åº¦ [4,â€¦â€¦,7] ä¸‰ä½æ•°é•¿åº¦ [8,â€¦â€¦,15] å››ä½æ•°é•¿åº¦ ä¹Ÿå°±æ˜¯è¯´ï¼Œé•¿åº¦ä¹Ÿæ˜¯ä¸€ä¸ªå¯ä»¥ä»ä¸Šä¸€ä¸ªé•¿åº¦æ¨æ–­æ¥çš„ï¼Œæ¯æ¬¡éœ€è¦æ–°å¢é•¿åº¦çš„æ—¶å€™ï¼Œéƒ½æ˜¯å½¢æˆ 2 çš„å¹‚ çš„å½¢æˆï¼Œå¯ä»¥ç”¨ i &amp; (i - 1) æ¥å¿«é€Ÿçš„åˆ¤æ–­ 2 çš„å¹‚ã€‚ 12345678910111213141516171819202122private static int mod = 1000000007;// åªéœ€è¦çŸ¥é“éå†çš„ n çš„ä½æ•°çš„é•¿åº¦å³å¯public int concatenatedBinary(int n) { long res = 0; int shift = 0; // å› ä¸ºè¦è¿”å›çš„æ˜¯ 1 - n çš„æ•°å­—çš„äºŒè¿›åˆ¶çš„ç»„åˆå½¢æˆçš„å¤§æ•°å­—çš„åè¿›åˆ¶æ•° // æ¯”å¦‚ 1 2 3 ç»„æˆçš„ 1 10 11 è¿”å› 27 // ç›¸å½“äº é¦–å…ˆè®¿é—® 1 ç»“æœä¸º 1 // è®¿é—® 2 ç„¶å 1 å·¦ç§»ä¸¤ä½ å†åŠ ä¸Š 2 // è®¿é—® 3 ä¸Šä¸€æ­¥çš„ç»“æœ å†å·¦ç§»ä¸¤ä½ åŠ ä¸Š 3 // æ‰€ä»¥å¯¹äºæ¯ä¸€ä¸ªæ•°å­—æ¥è¯´ å®é™…ä¸Šåªéœ€è¦è®©ä¸Šä¸€æ¬¡çš„ç»“æœ ä¸åœçš„å·¦ç§»å®ƒçš„äºŒè¿›åˆ¶çš„ä½æ•°é•¿åº¦å³å¯ for (int i = 1; i &lt;= n; i++) { // å› ä¸ºäºŒçš„å¹‚æ¬¡æ–¹ä¸º 1000 çš„å½¢å¼ // æ‰€ä»¥ä¸€æ—¦çŸ¥é“ç°åœ¨çš„ i ä¸º 2 çš„å¹‚æ¬¡æ–¹ å°±éœ€è¦ shift++ if ((i &amp; (i - 1)) == 0) { shift++; } res = ((res &lt;&lt; shift) + i) % mod; } return (int) res;} æ¨¡æ‹Ÿé™¤æ³•ä¸èƒ½ä½¿ç”¨ä¹˜æ³•ã€é™¤æ³•å’Œ mod è¿ç®—ç¬¦ã€‚ é™¤æ³•çš„æœ¬è´¨ï¼Œä»¥ 10 / 3 ä¸ºä¾‹ 10 / 3 = 3 â€¦â€¦ 1 (å³ä¸º 3 ä¸ª 3 ç›¸ä¹˜ ä½™ 1) å³ä¸º 10 - (3 _ 2) - (3 _ 1) = 1 å…¶ç»“æœä¸º 2 + 1 ä¸º 3 ä¹Ÿå°±æ˜¯è¯´ä»»æ„ä¸€ç§é™¤æ³•å¯ä»¥ç”¨ä¸€ç»„é™¤æ•°çš„ 2 çš„æ¬¡æ–¹çš„ä¹˜ç§¯çš„ç»“æœæ¥è¡¨ç¤ºã€‚ å¦‚ 100 / 15 = 6 100 - (15 _ 4) - (15 _ 2) æ‰€ä»¥å¯ä»¥é‡‡ç”¨äºŒè¿›åˆ¶çš„æ–¹æ³•æ¥åšï¼Œæ¯æ¬¡ç”¨è¢«é™¤æ•°å‡å»æœ€å¤§çš„ä¸€ä¸ªé™¤æ•°çš„ 2 æ¬¡æ–¹çš„ä¹˜ç§¯ï¼Œå¾ªç¯ï¼Œç›´åˆ°å‰©ä¸‹ä½™æ•°æˆ–è€… 0 123456789101112131415161718192021222324252627func divide(dividend int, divisor int) int { if divisor == 0 { return 1 &lt;&lt; 31 - 1 } minus := -1 if (dividend &lt; 0 &amp;&amp; divisor &lt; 0) || (dividend &gt; 0 &amp;&amp; divisor &gt; 0) { minus = 1 } absDividend, absDivisor := int64(math.Abs(float64(dividend))), int64(math.Abs(float64(divisor))) res := 0 for absDividend &gt;= absDivisor { tmp, multi := absDivisor, 1 for (tmp &lt;&lt; 1) &lt; absDividend { tmp &lt;&lt;= 1 multi &lt;&lt;= 1 } absDividend -= tmp res += multi if minus &gt; 0 &amp;&amp; res &gt;= math.MaxInt32 { return math.MaxInt32 } else if minus &lt; 0 &amp;&amp; minus * res &lt;= math.MinInt32 { return math.MinInt32 } } return minus * res} 123456789101112131415161718192021222324252627class Solution { public int divide(int dividend, int divisor) { if(divisor == 0 || (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -1)) return Integer.MAX_VALUE; int sign; if ((dividend &gt; 0 &amp;&amp; divisor &gt; 0) || (dividend &lt; 0 &amp;&amp; divisor &lt; 0)) sign = 1; else sign = -1; int res = 0; long dvd=Math.abs((long)dividend); long dvs=Math.abs((long)divisor); while (dvd &gt;= dvs) { long temp = dvs, m = 1; while (temp &lt;&lt; 1 &lt; dvd) { temp &lt;&lt;= 1; m &lt;&lt;= 1; } res += m; dvd -= temp; } return sign * res; }} åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— IIæ•°ç»„ä¸­çš„æ•°ç»„åªæœ‰å‡ºç° 1 æ¬¡ï¼ˆä¸€ä¸ªæ•°å­—ï¼‰çš„å’Œ 3 æ¬¡çš„æ•°å­—ï¼Œæ‰¾åˆ°åªå‡ºç°ä¸€æ¬¡çš„é‚£ä¸ªæ•°å­— å…¶å®å°±æ˜¯è®¡ç®—æ¯ä¸€ä½æ•°å­—å‡ºç°çš„æ¬¡æ•° % 3 æ³¨æ„ goland é»˜è®¤çš„ int å¯èƒ½å€¼å¾—æ˜¯ int64 æ‰€ä»¥å¼ºåˆ¶æŒ‡å®šä¸º 32 ä¸ºé•¿åº¦çš„ int32 ä¸ç„¶æ²¡åŠæ³•å¤„ç†è´Ÿæ•°çš„æƒ…å†µ 123456789101112func singleNumber(nums []int) int { var res int32 for i := 0; i &lt; 32; i++ { var count int32 for _, num := range nums { count += (int32(num )&gt;&gt; i) &amp; 1 } res += (count % 3) &lt;&lt; i } return int(res)} åªå‡ºç°ä¸€æ¬¡çš„æ•°å­— IIIä¸€ç»„æ•°å­— å…¶ä¸­åªæœ‰ä¸¤ä¸ªæ•°å­— å‡ºç°ä¸€æ¬¡ å…¶ä½™å‡ºç°ä¸¤æ¬¡ 12345678910111213141516171819202122232425262728func singleNumberIII(nums []int) []int { // å¦‚æœä¸¤ä¸ªå‡ºç°ä¸€æ¬¡çš„æ•° ä¸åŒ è‚¯å®šä¸ä¸º 0 sum := 0 for _, num := range nums { sum ^= num } // é‚£ä¹ˆæ ¹æ® sum çš„æŸä¸€ä¸ªä¸ä¸º 0 çš„ä½æ•°æ¥åˆ†ç¦»ä¸¤ç±»æ•° counter := 1 for sum &amp; 1 == 0 { sum &gt;&gt;= 1 counter &lt;&lt;= 1 } // æ‰¾åˆ°äº†è¿™ä¸ªä½æ•° æ ¹æ® ä½æ•° åˆ†æˆä¸¤ç»„å³å¯ num1, num2 := 0, 0 for _, num := range nums { // æ ¹æ®ä½æ•°åˆ†ç¦»ä¸¤ç±»æ•° if num &amp; counter == 0 { num1 ^= num } else { num2 ^= num } } return []int{num1, num2}} æ•°å­—æŒ‰ä½ä¸è¦æ±‚æ±‚ m -&gt; n çš„èŒƒå›´å†…çš„æ‰€æœ‰æ•°å­—çš„ æŒ‰ä½ä¸ çš„ç»“æœï¼Œå› ä¸ºèŒƒå›´æ¯”è¾ƒå¤§ï¼Œç›´æ¥ &amp; ä¼šè¶…æ—¶ è€ƒè™‘ 3 -&gt; 11 è¿™ä¸ªèŒƒå›´çš„æ•°å­—ï¼Œçº¢è‰²çš„ å°±æ˜¯ç›¸åŒçš„äºŒè¿›åˆ¶å‰ç¼€éƒ¨åˆ† å®é™…ä¸Šå°±æ˜¯æ‰¾åˆ°è¿™éƒ¨åˆ†å‰ç¼€ 001011 11 001010 10 001001 09 001000 08 000111 07 000110 06 000101 05 000100 04 000011 03 123456789101112131415func rangeBitwiseAnd(m int, n int) int { if m == n { return m } // è€ƒè™‘ [5,6,7] ä¸‰ä¸ªæ•° &amp; èµ·æ¥çš„è¯ å®é™…ä¸Šæ˜¯ è€ƒè™‘ æœ€å¤§å€¼ å’Œ æœ€å°å€¼çš„ å·¦ä¾§ç›¸ç­‰çš„éƒ¨åˆ†æ˜¯å¤šå°‘ // mov è®°å½•ç§»ä½äº†å¤šå°‘æ¬¡ ç„¶åå†ç§»åŠ¨å›æ¥ mov := 0 for m != n { m &gt;&gt;= 1 n &gt;&gt;= 1 mov++ } return m &lt;&lt; mov} åŠ¨æ€è§„åˆ’æœ€åä¸€å—çŸ³å¤´çš„é‡é‡ IIå…¶å®å°±æ˜¯é—®æ˜¯å¦èƒ½å¤Ÿå½¢æˆç›¸ç­‰çš„ä¸¤éƒ¨åˆ†, ç”¨ä¸€ä¸ª dp[i][j] è¡¨ç¤ºå‰ i ä¸ªçš„èƒ½å¦å½¢æˆå’Œä¸º j çš„æ•°å€¼ï¼Œåœ¨éå†çš„æ—¶å€™å°±å¯ä»¥æ‰¾åˆ°æœ€å¤§çš„å’Œä¸ºå¤šå°‘ï¼Œä¹‹åå°±å‡å»æœ€å¤§çš„å’Œå³å¯ 1234567891011121314151617181920212223242526272829303132333435package classic// è¿™é“é¢˜é¢˜å¹² è¦æ±‚ stones ä¸¤ä¸¤ç›¸æ’ å‰©ä¸‹ä¸€å—å„¿ ä¸ºå‰©ä¸‹çš„çŸ³å¤´ æœ€å°èƒ½å½¢æˆçš„é‡é‡// å…¶å®å°±æ˜¯é—®æ˜¯å¦èƒ½å¤Ÿå½¢æˆç›¸ç­‰çš„ä¸¤éƒ¨åˆ† å› ä¸ºç›¸ç­‰çš„è¯ æœ€åå½¢æˆçš„çŸ³å¤´ ä¸º 0func lastStoneWeightII(stones []int) int { sum := getStonesSum(stones) // dp[i][j] è¡¨ç¤ºå‰ i ä¸ªèƒ½å¦å½¢æˆ ä½•ä¸º j dp := make([][]bool, len(stones)+1) for i := 0; i &lt; len(dp); i++ { dp[i] = make([]bool, sum/2+1) // åˆä¸º0ä¸€å®šå¯ä»¥ dp[i][0] = true } maxSum := 0 for i := 1; i &lt;= len(stones); i++ { for j := 1; j &lt;= sum/2; j++ { // å› ä¸ºè¡¨ç¤ºçš„å‰ i èƒ½ä¸èƒ½å½¢æˆ j æ‰€ä»¥ i-1 èƒ½å½¢æˆçš„è¯ ä¹Ÿæ˜¯å¯ä»¥çš„ dp[i][j] = dp[i][j] || dp[i-1][j] if j &gt;= stones[i-1] { dp[i][j] = dp[i][j] || dp[i-1][j-stones[i-1]] } if dp[i][j] { maxSum = max(maxSum, j) } } } return sum - 2 * maxSum}func getStonesSum(stones []int) (sum int) { for _, w := range stones { sum += w } return} æœ€é•¿å­åºåˆ—å¥—é¢˜æœ€é•¿ä¸Šå‡å­åºåˆ—æ‰¾åˆ°éè¿ç»­çš„é€’å¢å­åºåˆ—ï¼Œé‚£ä¹ˆæˆ‘å°±åªéœ€è¦çŸ¥é“ åœ¨æˆ‘ä¹‹å‰çš„å°äºæˆ‘çš„æ•°å­—çš„ä¸Šå‡å­åºåˆ—é•¿åº¦ä¸ºå¤šå°‘ å³å®é™…ä¸Šåªéœ€è¦åœ¨è®¿é—®æ•°ç»„çš„æ—¶å€™ 0 â‰¤ i &lt; j &lt; nums.lengthï¼Œåªéœ€è¦çŸ¥é“ i ä¸‹æ ‡å¯¹åº”çš„æœ€é•¿çš„å­åºåˆ—æ˜¯å¤šå°‘å³å¯ã€‚ è¿™æ ·å°±å˜æˆäº†ä¸€ä¸ª dp é—®é¢˜ï¼Œå°é—®é¢˜å°±æ˜¯è§£å†³çš„ä»¥ nums[i] ç»“å°¾çš„æœ€é•¿çš„ä¸Šå‡å­åºåˆ—çš„é•¿åº¦ 123456789101112131415161718func lengthOfLIS(nums []int) int { // dp[i] è¡¨ç¤º nums[i] ç»“å°¾çš„æœ€é•¿çš„é€’å¢å­åºåˆ—é•¿åº¦ä¸ºå¤šå°‘ dp := make([]int, len(nums)) // åˆå§‹åŒ– ä¸€ä¸ªæ•°å­—è‚¯å®šæ˜¯é€’å¢çš„ for i := 0; i &lt; len(nums); i++ { dp[i] = 1 } res := 0 for i, num := range nums { for j := 0; j &lt; i; j++ { if num &gt; nums[j] { dp[i] = max(dp[i], dp[j]+1) } } res = max(res, dp[i]) } return res} æœ€é•¿ä¸Šå‡å­åºåˆ—æ•°é‡ä¸ä¸Šé¢é‚£ä¸ªç±»ä¼¼ ä¹Ÿæ˜¯ä¸€ä¸ª dp é—®é¢˜ åªæ˜¯éœ€è¦åœ¨ dp éå†çš„æ—¶å€™ çŸ¥é“ å¯¹åº”æœ€é•¿é•¿åº¦ å¯¹åº”çš„ LIS æœ‰å¤šå°‘ä¸ª 1234567891011121314151617181920212223242526272829303132333435363738// æ‰¾åˆ° LIS å¯¹åº”çš„é•¿åº¦çš„å­åºåˆ—æœ‰å¤šå°‘ä¸ªfunc findNumberOfLIS(nums []int) int { // ä¿å­˜ nums[i] ç»“å°¾çš„ LIS çš„é•¿åº¦ dp := make([]int, len(nums)) // ä¿å­˜ nums[i] ç»“å°¾çš„ LIS çš„æœ€é•¿ LIS çš„é•¿åº¦ counts := make([]int, len(nums)) // åˆå§‹åŒ– for i := 0; i &lt; len(dp); i++ { dp[i] = 1 counts[i] = 1 } maxLen := 0 for i := 0; i &lt; len(nums); i++ { for j := 0; j &lt; i; j++ { // å½¢æˆ é€’å¢ if nums[j] &lt; nums[i] { if dp[i] &lt;= dp[j] { // è¯´æ˜ j çš„é•¿åº¦æ¯”è¿™ä¸ªé•¿ dp[i] = dp[j] + 1 counts[i] = counts[j] } else if dp[j]+1 == dp[i] { // é•¿åº¦ç›¸å·® 1 è¯´æ˜è¿™ä¸ªæ—¶å€™ counts è¦ + ä¸Š j çš„ counts[i] += counts[j] } } } maxLen = max(maxLen, dp[i]) } res := 0 for i, count := range counts { if maxLen == dp[i] { res += count } } return res} æ‘†åŠ¨åºåˆ—æ‰¾åˆ°æ‘†åŠ¨åºåˆ—ï¼ˆæ‘†åŠ¨åºåˆ—æ˜¯ä¸€å‡ä¸€é™çš„åºåˆ—ï¼Œå³å‰åç›¸å‡ä¸ºä¸€æ­£ä¸€è´Ÿï¼‰å‚è€ƒæ³¨é‡Šå³å¯ (è¿™ä¸ªé¢˜ç›®ä¸è¦æ±‚è¿ç»­ æ‰€ä»¥è¿˜éœ€è¦ä¸åœçš„ä¿å­˜å‰ä¸€ä¸ªçŠ¶æ€ ä¸ç”¨åˆå§‹åŒ–) 1234567891011121314151617181920212223242526272829// ä¸¤ä¸ªæ•°ç»„åˆ†åˆ«ä»£è¡¨ä¸Šå‡å’Œä¸‹é™åºåˆ—çš„æœ€å¤§é•¿åº¦// å› ä¸º wiggle çš„æ•°ç»„ æ˜¯ä¸€å‡ä¸€é™ çš„ up[i] è¡¨ç¤º æœ€åä¸€ä¸ª nums[i] æ˜¯ä¸Šå‡çš„è¶‹åŠ¿çš„æœ€å¤§å€¼func wiggleMaxLengthWithoutMemo(nums []int) int { if len(nums) == 0 { return 0 } // up[i] down[i] åˆ†åˆ«ä»£è¡¨ä¸Šå‡å’Œä¸‹é™åºåˆ—(æœ€åä¸€ä¸ªæ˜¯ä¸Šå‡æˆ–è€…ä¸‹é™)çš„ åœ¨ index = i æ—¶çš„æœ€é•¿é•¿åº¦ ups, downs := make([]int, len(nums)), make([]int, len(nums)) // åˆå§‹åŒ– ups[0] = 1 downs[0] = 1 for i := 1; i &lt; len(nums); i++ { if nums[i] &gt; nums[i-1] { // å¦‚æœ nums i æ˜¯ä¸Šå‡è¶‹åŠ¿ è¯´æ˜é‚£ä¹ˆ ä¹‹å‰å‰ä¸€ä¸ªæ˜¯ä¸‹é™çš„è¶‹åŠ¿çš„è¯ å¯ä»¥ åŠ ä¸€ // åŒæ—¶ ä¹Ÿå¯ä»¥ä¸è€ƒè™‘è¿™ä¸ª ä¸Šå‡è¶‹åŠ¿ è·Ÿå‰ä¸€ä¸ªæ¯”è¾ƒ ups[i] = max(downs[i-1]+1, ups[i-1]) // æ­¤æ—¶ç”±äºæ˜¯ä¸Šå‡çš„ æ‰€ä»¥æ²¡æœ‰ä¸‹é™çš„è¶‹åŠ¿ çŠ¶æ€ç›´æ¥è½¬ç§» downs[i] = downs[i-1] } else if nums[i] &lt; nums[i-1] { downs[i] = max(ups[i-1]+1, downs[i-1]) ups[i] = ups[i-1] } else { // ç›¸ç­‰çš„æƒ…å†µä¸‹æ˜¯ä¸å˜çš„ ups[i] = ups[i-1] downs[i] = downs[i-1] } } return max(ups[len(ups)-1], downs[len(downs)-1])} å› ä¸ºåªä¾èµ–å‰ä¸€ä¸ªçŠ¶æ€ å› æ­¤å¯ä»¥å‹ç¼©çŠ¶æ€ 1234567891011121314151617181920212223// ä¸¤ä¸ªæ•°ç»„åˆ†åˆ«ä»£è¡¨ä¸Šå‡å’Œä¸‹é™åºåˆ—çš„æœ€å¤§é•¿åº¦// å› ä¸º wiggle çš„æ•°ç»„ æ˜¯ä¸€å‡ä¸€é™ çš„ up[i] è¡¨ç¤º æœ€åä¸€ä¸ª nums[i] æ˜¯ä¸Šå‡çš„è¶‹åŠ¿çš„æœ€å¤§å€¼func wiggleMaxLength(nums []int) int { if len(nums) == 0 { return 0 } up, down := 1, 1 for i := 1; i &lt; len(nums); i++ { preDown, PreUp := down, up if nums[i] &gt; nums[i-1] { up = max(down+1, up) down = preDown } else if nums[i] &lt; nums[i-1] { down = max(up+1, down) up = PreUp } else { up = PreUp down = preDown } } return max(up, down)} ç±»ä¼¼æ‘†åŠ¨åºåˆ—çš„é¢˜ç›® 978. æœ€é•¿æ¹æµå­æ•°ç»„æ‰¾åˆ°ä¸€ä¸ªè¿ç»­çš„å­æ•°ç»„èƒ½å¤Ÿæ»¡è¶³ å½“ A çš„å­æ•°ç»„ A[i], A[i+1], â€¦, A[j] æ»¡è¶³ä¸‹åˆ—æ¡ä»¶æ—¶ï¼Œæˆ‘ä»¬ç§°å…¶ä¸ºæ¹æµå­æ•°ç»„ï¼š è‹¥ i &lt;= k &lt; jï¼Œå½“ k ä¸ºå¥‡æ•°æ—¶ï¼Œ A[k] &gt; A[k+1]ï¼Œä¸”å½“ k ä¸ºå¶æ•°æ—¶ï¼ŒA[k] &lt; A[k+1]ï¼›æˆ– è‹¥ i &lt;= k &lt; jï¼Œå½“ k ä¸ºå¶æ•°æ—¶ï¼ŒA[k] &gt; A[k+1] ï¼Œä¸”å½“ k ä¸ºå¥‡æ•°æ—¶ï¼Œ A[k] &lt; A[k+1]ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæ¯”è¾ƒç¬¦å·åœ¨å­æ•°ç»„ä¸­çš„æ¯ä¸ªç›¸é‚»å…ƒç´ å¯¹ä¹‹é—´ç¿»è½¬ï¼Œåˆ™è¯¥å­æ•°ç»„æ˜¯æ¹æµå­æ•°ç»„ã€‚ 123456789101112131415161718192021222324252627282930func maxTurbulenceSize(arr []int) int { // ä»ç„¶æ˜¯ä¸€å‡ä¸€é™ æ‰èƒ½ä½¿ç¬¦å·åå· up, down := 1, 1 res := 1 for i := 1; i &lt; len(arr); i++ { if arr[i] &gt; arr[i-1] { up = down+1 // å› ä¸ºæ˜¯è¦è¿ç»­çš„ ä¸€å‡ä¸€é™ æ‰€ä»¥è¿™ä¸ªåœ°æ–¹éœ€è¦é‡æ–°åˆå§‹åŒ–ä¸º 1 down = 1 } else if arr[i] &lt; arr[i-1] { down = up + 1 up = 1 } else { up, down = 1, 1 } // å› ä¸ºé‡æ–°åˆå§‹åŒ– æ‰€ä»¥éœ€è¦å¯¹æ¯ä¸€ä¸ªçŠ¶æ€è¿›è¡Œæ¯”è¾ƒä¿å­˜ res = max(res, max(up, down)) } return res}func max(a, b int) int { if a &gt; b { return a } return b} ä¿„ç½—æ–¯å¥—å¨ƒä¿¡å°é—®é¢˜æ ¹æ®ä¿¡å°çš„å®½åº¦å’Œé«˜åº¦ åˆ¤æ–­èƒ½å¤Ÿè£…ä¸‹çš„ä¿¡å°çš„æœ€å¤§é•¿åº¦æœ‰å¤šå°‘ é«˜åº¦å’Œå®½åº¦å‡å°äºå¦å¤–ä¸€ä¸ªä¿¡å°çš„ å¯ä»¥è£…è¿›å» å®é™…ä¸Šæ˜¯ä¸€ä¸ª æ‰¾åˆ°æœ€é•¿é€’å¢åºåˆ—çš„é—®é¢˜ æŒ‰ç…§å®½åº¦è¿›è¡Œæ’åºï¼Œè¿™æ ·ä»ä¸€ä¸ªç»´åº¦ä¸Šçœ‹ æ‰€æœ‰çš„ä¿¡å°éƒ½æ˜¯å®½åº¦æœ‰åºçš„ å†æ¬¡åŸºç¡€ä¸Š å¦‚æœè¦å‰ä¸€ä¸ªä¿¡å°èƒ½å¤Ÿè£…åœ¨åä¸€ä¸ªä¿¡å°é‡Œé¢ è¯´æ˜é•¿åº¦æ˜¯ä¸€ä¸ªé€†åºçš„ æœ€ååªéœ€è¦åœ¨è¿™ä¸ªæ’åºçš„æ•°ç»„é‡Œé¢ æ‰¾åˆ°é•¿åº¦çš„ä¸€ä¸ªæœ€é•¿é€’å¢åºåˆ—å³å¯ 123456789101112131415161718192021222324252627282930313233343536373839func maxEnvelopes(envelopes [][]int) int { // envelopes[0] ç›¸ç­‰ è¯´æ˜å®½åº¦ç›¸ç­‰ è¿™ä¸ªæ—¶å€™ åªéœ€è¦æ›´é•¿çš„æ’åœ¨åé¢å³å¯ // envelopes[0] ä¸ç­‰ è¯´æ˜å®½åº¦ä¸ç­‰ è¿™ä¸ªæ—¶å€™ åªéœ€è¦åªéœ€è¦æ ¹æ®é•¿åº¦å¤§å°ä»å¤§åˆ°å°æ’åºå³å¯ sort.Slice(envelopes, func(i, j int) bool { if envelopes[i][0] == envelopes[j][0] { return envelopes[i][1] &gt; envelopes[j][1] } else { return envelopes[i][0] &lt; envelopes[j][0] } }) // å› ä¸ºç°åœ¨è¿™æ ·æ’åºä¹‹å ä¿¡å°çš„å®½åº¦ ä¸€å®šæ˜¯æ»¡è¶³é¡ºåºçš„ é‚£ä¹ˆåªéœ€è¦åˆ¤æ–­é•¿åº¦ èƒ½å¤Ÿå½¢æˆçš„æœ€é•¿çš„é€’å¢å­åºåˆ—æ˜¯å¤šé•¿ dp := make([]int, len(envelopes)) // 1 ä¸ªæ•°å­—ä¹Ÿèƒ½æœ‰ä¸€ä¸ªé•¿åº¦ for i := 0; i &lt; len(dp); i++ { dp[i] = 1 } res := 0 for i := 0; i &lt; len(dp); i++ { tmp := 0 for j := 0; j &lt; i; j++ { if envelopes[i][1] &gt; envelopes[j][1] { tmp = max(tmp, dp[j]) } } dp[i] = tmp + 1 res = max(res, dp[i]) } return res}func max(a, b int) int { if a &gt; b { return a } return b} è§£ç æ–¹æ³•è¿™é“é¢˜æ˜¯å…¥é—¨çš„åŠ¨æ€è§„åˆ’ åªè¦çŸ¥é“ å‰ä¸€ä¸ªå’Œå‰å‰ä¸ªçš„çŠ¶æ€ï¼Œå°±å¯ä»¥è½¬ç§»åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€ 12345678910111213141516171819202122232425262728293031323334353637func numDecodings(s string) int { if len(s) == 0 { return 0 } // dp[i] è¡¨ç¤º s[0:i] ä¸åŒ…æ‹¬ièƒ½ç”Ÿæˆçš„æ•°é‡ // dp[i] = dp[i-1]+dp[i-2] // å› ä¸ºåªè¦å½“å‰çš„è¿™ä¸ª sting èƒ½å¤Ÿè¢« decoding è¯´æ˜åªè¦åŠ ä¸Šå‰é¢çš„æ•°é‡å³å¯ dp := make([]int, len(s) + 1) dp[0] = 1 // è¡¨ç¤ºçš„æ¯æ¬¡éå†çš„stringçš„å°¾éƒ¨ for i := 1; i &lt;= len(s); i++ { for j := max(i - 2, 0); j &lt; i; j++ { if canDecoding(s[j:i]) { dp[i] += dp[j] } } } return dp[len(s)]}func canDecoding(s string) bool { if len(s) &gt; 1 &amp;&amp; s[0] == '0' { return false } if num, err := strconv.Atoi(s); err != nil || num &gt; 26 || num &lt; 1 { return false } return true}func max(a, b int) int { if a &gt; b { return a } return b} å­åºåˆ—ä¸åŒçš„å­åºåˆ—1234567891011121314151617181920212223242526func numDistinct(s string, t string) int { // dp[i][j] è¡¨ç¤º s[i-1] å’Œ t[j-1] ä¹‹é—´æœ‰å¤šå°‘ç»„åˆ dp := make([][]int, len(s)+1) for i := 0; i &lt;= len(s); i++ { dp[i] = make([]int, len(t)+1) } // åˆå§‹åŒ– åªè¦ t æ˜¯ç©º é‚£ä¹ˆä¸€å®šå¯ä»¥ åœ¨ s ä¸­æ‰¾åˆ° for i := 0; i &lt;= len(s); i++ { dp[i][0] = 1 } for i := 1; i &lt;= len(s); i++ { for j := 1; j &lt;= len(t); j++ { if s[i-1] == t[j-1] { // åˆ†ä¸ºä¸¤ä¸ªéƒ¨åˆ† å› ä¸ºå¯ä»¥ä¸ç®—å½“å‰çš„ s ä¸²çš„æœ€åä¸€ä¸ª ä¹Ÿå¯ä»¥ç®—ä¸Š // å› ä¸º s ä¸²çš„å‰é¢éƒ¨åˆ† å¯èƒ½å·²ç»åŒ¹é…åˆ°äº† dp[i][j] = dp[i-1][j-1] + dp[i-1][j] } else { dp[i][j] = dp[i-1][j] } } } return dp[len(s)][len(t)]} æ‰“å®¶åŠ«èˆç³»åˆ—é¢˜æ‰“å®¶åŠ«èˆ Iè¿™é“é¢˜æ˜¯ç»å…¸çš„ dp é—®é¢˜ã€‚é¢˜ç›®è¦æ±‚çš„æ˜¯ä¸èƒ½æŠ¢åŠ«ç›¸é‚»çš„ä½ç½®ï¼Œé‚£ä¹ˆè¿™ç§æ¡ä»¶ä¸‹çš„æœ€å¤§å’Œæ˜¯å¤šå°‘ã€‚ ä¸€ä¸ªä½ç½®ä¼šæœ‰ä¸¤ä¸ªçŠ¶æ€ï¼Œæ‹¿å½“å‰è¿™ä¸ªåœ°æ–¹çš„å€¼ æˆ–è€… ä¸æ‹¿ ä¸‹ä¸ªä½ç½®çš„çŠ¶æ€å°±ä¼šç”±ä¸Šä¸€ä¸ªä½ç½®å†³å®š å¦‚æœå½“å‰ä½ç½®æ‹¿äº†å€¼çš„è¯ï¼Œä¸Šä¸€ä¸ªä½ç½®åªèƒ½ä¸æ‹¿ å¦‚æœå½“å‰ä½ç½®æ²¡æœ‰æ‹¿ï¼Œä¸Šä¸€ä¸ªä½ç½®åªéœ€è¦å–æ‹¿ or ä¸æ‹¿çš„ è¾ƒå¤§å€¼ ä¼˜åŒ–ä¸‹ dp æ•°ç»„ å…¶å®å¯ä»¥ç”¨ä¸€å¯¹å€¼è¡¨ç¤ºå‰é¢ä¸€ä¸ªå¾ªç¯ä¸­æ‹¿äº†çš„æœ€å¤§å€¼å³å¯ 12345678910111213141516func rob(nums []int) int { if len(nums) &lt;= 0 { return 0 } // ä¼˜åŒ–çš„ç›®çš„åœ¨äºå»æ‰æ•°ç»„ å› ä¸ºç°åœ¨ç›´æ¥æœ€å¤§çš„å°±æ˜¯ notRob, rob := 0, 0 res := 0 for _, num := range nums { rm := rob rob = notRob + num notRob = max(notRob, rm) res = max(notRob, rob) } return res} æ‰“å®¶åŠ«èˆ IIè¿™ä¸ªæ˜¯æ‰“åŠ«çš„å¾ªç¯æ•°ç»„ï¼Œå› ä¸º rob äº†ç¬¬ä¸€ä¸ª å°±ä¸èƒ½ rob æœ€åä¸€ä¸ª æ‰€ä»¥åˆ†åˆ«è®¿é—®ä» [1:len(nums)] å’Œ [0:len(nums)-1] ç„¶åæ¯”è¾ƒå¤§å°å³å¯ 1234567891011121314151617181920212223242526272829303132func rob(nums []int) int { if len(nums) &lt;= 0 { return 0 } if len(nums) == 1 { return nums[0] } // å› ä¸ºæ˜¯é¦–å°¾ç›¸è¿çš„ robFirst := getMaxRob(nums[:len(nums)-1]) notRobFirst := getMaxRob(nums[1:]) return max(robFirst, notRobFirst)}func getMaxRob(nums []int) int { notRob, rob := 0, 0 res := 0 for _, num := range nums { rem := rob rob = notRob + num notRob = max(rem, notRob) res = max(res, max(rob, notRob)) } return res}func max(a, b int) int { if a &gt; b { return a } return b} æ‰“å®¶åŠ«èˆ IIIè¿™æ¬¡æ˜¯æ ‘ï¼Œå®é™…ä¸Šè¿˜æ˜¯è¦çŸ¥é“å­èŠ‚ç‚¹ä¸Šçš„è¯ rob å’Œ notRob çš„çŠ¶æ€å³å¯ï¼Œç„¶åé€’æ¨åˆ°å½“å‰çš„çŠ¶æ€ 1234567891011121314151617181920212223242526272829303132333435363738394041func rob(root *TreeNode) int { var res int recursionRobTree(root, &amp;res) return res}// recursionRobTree è¿”å›å€¼æ˜¯ rob å½“å‰è¿™ä¸ª root è¿˜ä¸ ä¸ rob çš„å€¼func recursionRobTree(root *TreeNode, res *int) (int, int) { if root == nil { return 0, 0 } leftRob, leftNotRob := recursionRobTree(root.Left, res) rightRob, rightNotRob := recursionRobTree(root.Right, res) // å¦‚æœ rob å½“å‰è¿™ä¸ªroot èŠ‚ç‚¹çš„è¯ æ„å‘³ç€ ä¸¤ä¸ªèŠ‚ç‚¹éƒ½ä¸å¯ä»¥rob rob := leftNotRob + rightNotRob + root.Val // å¦‚æœ ä¸ rob è¿™ä¸ªèŠ‚ç‚¹çš„è¯ å­èŠ‚ç‚¹å¯ä»¥ rob ä¹Ÿå¯ä»¥ä¸ rob notRob := getArrayMax(leftRob + rightRob, rightRob + leftNotRob, rightNotRob + leftRob, rightNotRob + leftNotRob) *res = max(*res, rob) *res = max(*res, notRob) return rob, notRob}func getArrayMax(nums ...int) int { if len(nums) == 0 { return -1 } res := nums[0] for _, num := range nums { res = max(res, num) } return res}func max(a, b int) int { if a &gt; b { return a } return b} è´ªå¿ƒç®—æ³•è½¬æ¢ç½—é©¬å­—12345678910111213141516171819202122232425262728293031323334353637383940package classicimport ( &quot;strings&quot;)var ( memo = make(map[int]string) keys []int)func init() { memo[1] = &quot;I&quot; memo[4] = &quot;IV&quot; memo[5] = &quot;V&quot; memo[9] = &quot;IX&quot; memo[10] = &quot;X&quot; memo[40] = &quot;XL&quot; memo[50] = &quot;L&quot; memo[90] = &quot;XC&quot; memo[100] = &quot;C&quot; memo[400] = &quot;CD&quot; memo[500] = &quot;D&quot; memo[900] = &quot;CM&quot; memo[1000] = &quot;M&quot; keys = []int{1000,900,500,400,100,90,50,40,10,9,5,4,1}}func intToRoman(num int) string { res := strings.Builder{} for _, key := range keys { for num &gt;= key { res.WriteString(memo[key]) num -= key } } return res.String()} jumpGame12345678910111213141516func canJump(nums []int) bool { rightMost := 0 for i, num := range nums { // å¦‚æœå½“å‰çš„ä¸‹æ ‡å¤§äº rightMost è¯´æ˜è¿™ä¸ªç‚¹æ˜¯æ— æ³•åˆ°è¾¾çš„ ç›´æ¥è¿”å› false å³å¯ if i &gt; rightMost { return false } // ç»´æŠ¤ä¸€ä¸ªèƒ½å¤Ÿåˆ°è¾¾çš„æœ€è¿œè·ç¦» rightMost = max(rightMost, i + num) // æœ€è¿œè·ç¦»å¤§äºé•¿åº¦ å³å¯çŸ¥é“èƒ½å¤Ÿè¾¾åˆ° if rightMost &gt;= len(nums) - 1 { return true } } return false} é€’å½’æ‰§è¡Œä¹˜æ³•è¿ç®—çš„æœ€å¤§åˆ†æ•° ç»™ä½ ä¸¤ä¸ªé•¿åº¦åˆ†åˆ« n å’Œ m çš„æ•´æ•°æ•°ç»„ nums å’Œ multipliers ï¼Œå…¶ä¸­ n &gt;= m ï¼Œæ•°ç»„ä¸‹æ ‡ ä» 1 å¼€å§‹ è®¡æ•°ã€‚åˆå§‹æ—¶ï¼Œä½ çš„åˆ†æ•°ä¸º 0 ã€‚ä½ éœ€è¦æ‰§è¡Œæ°å¥½ m æ­¥æ“ä½œã€‚åœ¨ç¬¬ i æ­¥æ“ä½œï¼ˆä» 1 å¼€å§‹ è®¡æ•°ï¼‰ä¸­ï¼Œéœ€è¦ï¼šé€‰æ‹©æ•°ç»„ nums å¼€å¤´å¤„æˆ–è€…æœ«å°¾å¤„ çš„æ•´æ•° x ã€‚ä½ è·å¾— multipliers[i] * x åˆ†ï¼Œå¹¶ç´¯åŠ åˆ°ä½ çš„åˆ†æ•°ä¸­ã€‚å°† x ä»æ•°ç»„ nums ä¸­ç§»é™¤ã€‚åœ¨æ‰§è¡Œ m æ­¥æ“ä½œåï¼Œè¿”å› æœ€å¤§ åˆ†æ•°ã€‚ æš´åŠ›è§£æ³• æš´åŠ›è§£æ³•å°±æ˜¯ç›´æ¥æ ¹æ®æ¯æ¬¡å–çš„ä¸åŒå­—ç¬¦ç”Ÿæˆä¸€é¢—äºŒå‰æ ‘ï¼Œç„¶ååœ¨äºŒå‰æ ‘ä¸Šè¿›è¡Œéå†å¾—åˆ°ç»“æœ 12345678910111213141516class Solution { public int maximumScore(int[] nums, int[] multipliers) { Deque&lt;Integer&gt; num = new LinkedList&lt;&gt;(); for (int t : nums) { num.addLast(t); } return recursion(0, multipliers, num); } public int recursion(int index, int[] multipliers, Deque&lt;Integer&gt; nums) { if (index &gt;= multipliers.length) return 0; Deque&lt;Integer&gt; tmp = new LinkedList&lt;&gt;(nums); return Math.max(multipliers[index] * nums.removeFirst() + recursion(index + 1, multipliers, nums), multipliers[index] * tmp.removeLast() + recursion(index + 1, multipliers, tmp)); }} å¸¦ memo è§‚å¯Ÿä¸Šè¿°çš„ç»“æœçš„è¯ï¼Œå¯ä»¥é¦–å…ˆè¿›è¡Œçš„ä¼˜åŒ–æ˜¯å»é™¤ dequeue çš„ä½¿ç”¨ï¼Œç›´æ¥ä½¿ç”¨ä¸€ä¸ªèŒƒå›´æ¡†å®š nums çš„é€‰å– 12345678910public int maximumScore(int[] nums, int[] multipliers) { return recursion(0, multipliers, nums, 0, nums.length - 1);}public int recursion(int index, int[] multipliers, int[] nums, int left, int right) { if (index &gt;= multipliers.length) return 0; int l = nums[left] * multipliers[index] + recursion(index + 1, multipliers, nums, left + 1, right, memo); int r = nums[right] * multipliers[index] + recursion(index + 1, multipliers, nums, left, right - 1, memo); return Math.max(l, r);} ä½†æ˜¯ä¸Šè¿°çš„æ–¹æ³•ä»ç„¶è¶…æ—¶ï¼Œå› ä¸ºéå†è¿™é¢—å½¢æˆçš„äºŒå‰æ ‘çš„æ—¶å€™ï¼Œä¼šæœ‰é‡å¤çš„è®¿é—®æƒ…å†µï¼Œå¯ä»¥è§‚å¯Ÿåˆ°çš„æ˜¯ left + n - 1 - right == indexï¼Œå› ä¸ºä»å·¦è¾¹é€‰å–çš„æ•°å­—æ•°é‡å’Œå³è¾¹é€‰å–çš„æ•°å­—çš„æ•°é‡ï¼Œè‚¯å®šæ˜¯ multipliers é€‰å–çš„æ•°é‡ã€‚ 123456789101112131415161718192021public int maximumScore(int[] nums, int[] multipliers) { // ä¸Šé¢çš„ leftã€rightã€index å…¶å®å¯ä»¥ç”¨ä»»æ„ä¸¤ä¸ªæ¥è¡¨ç¤ºå³å¯ // å› ä¸ºå¯ä»¥æ ¹æ®å…¬å¼äº’æ¢ï¼Œæ‰€ä»¥è¿™æ ·é€‰æ‹©çš„ memo æ˜¯æœ€å°çš„ int[][] memo = new int[multipliers.length][multipliers.length]; for (int i = 0; i &lt; multipliers.length; i++) { Arrays.fill(memo[i], Integer.MAX_VALUE); } return recursion(0, multipliers, nums, 0, nums.length - 1, memo);}// å› ä¸º left + n - 1 - right == index// å› ä¸ºå…¶ç»“æœä»£è¡¨çš„æ˜¯ å·¦è¾¹é€‰å– left ä¸ª å³è¾¹é€‰å– n - 1 - right ä¸ª// è€Œå–å‡ºçš„ç»“æœpublic int recursion(int index, int[] multipliers, int[] nums, int left, int right, int[][] memo) { if (index &gt;= multipliers.length) return 0; if (memo[left][index] != Integer.MAX_VALUE) return memo[left][index]; int l = nums[left] * multipliers[index] + recursion(index + 1, multipliers, nums, left + 1, right, memo); int r = nums[right] * multipliers[index] + recursion(index + 1, multipliers, nums, left, right - 1, memo); memo[left][index] = Math.max(l, r); return memo[left][index];} æ‹¬å·ç”Ÿæˆ1234567891011121314151617181920212223// generateParenthesis å…¥å£å‡½æ•°func generateParenthesis(n int) []string { res := make([]string, 0) recursionGenerate(&amp;res, &quot;&quot;, n, n) return res}// é€’å½’ç”Ÿæˆfunc recursionGenerate(res *[]string, tmp string, left, right int) { if left == 0 &amp;&amp; right == 0 { *res = append(*res, tmp) return } // ç”±äºå·¦æ‹¬å·å¯ä»¥ç›´æ¥æ”¾åˆ°ç»“æœä¸Šï¼Œå› æ­¤å·¦æ‹¬å·ä¸ç”¨åˆ¤æ–­å…¶ä»–çš„ if left &gt; 0 { recursionGenerate(res, tmp+&quot;(&quot;, left-1, right) } // è€Œæœ‰æ‹¬å·éœ€è¦è·Ÿå·¦æ‹¬å·åŒ¹é…ï¼Œæ‰€ä»¥æœ‰æ‹¬å·éå†çš„æ—¶å€™ å¿…é¡»å·²ç»æœ‰å·¦æ‹¬å·è¢«æ”¾åˆ°äº†ç»“æœä¸­ // æ‰€ä»¥éœ€è¦åˆ¤æ–­ä¸€ä¸‹ right &gt; left if right &gt; left { recursionGenerate(res, tmp+&quot;)&quot;, left, right-1) }} 12345678910111213141516171819public List&lt;String&gt; generateParenthesis(int n) { List&lt;String&gt; res = new ArrayList&lt;&gt;(); recursion(res, n, n, &quot;&quot;); return res;}public void recursion(List&lt;String&gt; res, int left, int right, String tmp) { if (left == 0 &amp;&amp; right == 0) { res.add(tmp); return; } if (left &gt; 0) { recursion(res, left - 1, right, tmp + &quot;(&quot;); } if (right &gt; left) { recursion(res, left, right - 1, tmp + &quot;)&quot;); }} æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…è¿™é“é¢˜å¯ä»¥ç”¨é€’å½’çš„æ€æƒ³å»åšï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨ dp çš„æ–¹æ³•ã€‚å®é™…ä¸Šé€’å½’å°±æ˜¯ä»ä¸Šå‘ä¸‹çš„ dp 12345678910111213141516171819202122232425262728293031func isMatch(s string, p string) bool { return recursionIsMatch(s, p, 0, 0)}func recursionIsMatch(s, p string, sIndex, pIndex int) bool { // å®Œå…¨åŒ¹é… if sIndex == len(s) &amp;&amp; pIndex == len(p) { return true } // è¶Šç•Œ pattern åŒ¹é…å®Œäº†ä¸€å®šæœ‰é—®é¢˜ if pIndex == len(p) &amp;&amp; sIndex != len(s) { return false } if pIndex &lt; len(p)-1 &amp;&amp; p[pIndex+1] == '*' { // åŒ¹é… if pIndex &lt; len(p) &amp;&amp; sIndex &lt; len(s) &amp;&amp; (p[pIndex] == s[sIndex] || p[pIndex] == '.') { return recursionIsMatch(s, p, sIndex, pIndex+2) || // åŒ¹é…0æ¬¡ å› ä¸º * ä»£è¡¨ 0 -&gt; å¤šæ¬¡ recursionIsMatch(s, p, sIndex+1, pIndex+2) || // åŒ¹é…1æ¬¡ recursionIsMatch(s, p, sIndex+1, pIndex) // åŒ¹é…å¤šæ¬¡ } else { // å¦‚æœä¸åŒ¹é… åˆ™è·³è¿‡ return recursionIsMatch(s, p, sIndex, pIndex+2) } } // ç°åœ¨çš„å­—ç¬¦æ˜¯åŒ¹é…çš„ if pIndex &lt; len(p) &amp;&amp; sIndex &lt; len(s) &amp;&amp; (p[pIndex] == s[sIndex] || p[pIndex] == '.') { return recursionIsMatch(s, p, sIndex+1, pIndex+1) } return false} 123456789101112131415161718192021222324252627public boolean isMatch(String s, String p) { return recursion(s, p, 0, 0);}public boolean recursion(String s, String p, int sIndex, int pIndex) { if (pIndex == p.length() &amp;&amp; sIndex != s.length()) { return false; } if (sIndex == s.length() &amp;&amp; pIndex == p.length()) { return true; } if (pIndex &lt; p.length() - 1 &amp;&amp; p.charAt(pIndex + 1) == '*') { if (sIndex &lt; s.length() &amp;&amp; (p.charAt(pIndex) == '.' || p.charAt(pIndex) == s.charAt(sIndex))) { return recursion(s, p, sIndex, pIndex + 2) || // åŒ¹é…0æ¬¡ recursion(s, p, sIndex + 1, pIndex + 2) || // åŒ¹é…1æ¬¡ recursion(s, p, sIndex + 1, pIndex); // åŒ¹é…å¤šæ¬¡ } else { return recursion(s, p, sIndex, pIndex + 2); } } if (sIndex &lt; s.length() &amp;&amp; pIndex &lt; p.length() &amp;&amp; (p.charAt(pIndex) == '.' || p.charAt(pIndex) == s.charAt(sIndex))) { return recursion(s, p, sIndex + 1, pIndex + 1); } return false;} æ•°æ®ç»“æ„æ ˆå’Œé˜Ÿåˆ—é˜Ÿåˆ—-æ»‘åŠ¨çª—å£çš„æœ€å¤§å€¼æœ€å¤§ queue çš„é˜Ÿåˆ— 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960type MaxQueue struct { stack1 MaxStack stack2 MaxStack}func (queue *MaxQueue) Push(val int) { queue.stack1.Push(val)}func (queue *MaxQueue) shift() int { if queue.stack2.Len() == 0 { for queue.stack1.Len() &gt; 0 { queue.stack2.Push(queue.stack1.Pop()) } } return queue.stack2.Pop()}func (queue *MaxQueue) Max() int { if queue.stack1.Len() == 0 { return queue.stack2.Max() } else if queue.stack2.Len() == 0 { return queue.stack1.Max() } return max(queue.stack2.Max(), queue.stack1.Max())}func (queue *MaxQueue) Len() int { return queue.stack1.Len() + queue.stack2.Len()}type MaxStack struct { // è¿™ä¸¤ä¸ªä¸ç”¨ slice ç”¨ list ä¹‹ç±»çš„é“¾è¡¨ å¯èƒ½ä¼šå¿«ä¸€ç‚¹å„¿ data []int maxes []int}func (ms *MaxStack) Push(val int) { ms.data = append(ms.data, val) if len(ms.maxes) &gt; 0 { ms.maxes = append(ms.maxes, max(ms.maxes[len(ms.maxes)-1], val)) } else { ms.maxes = append(ms.maxes, val) }}func (ms *MaxStack) Pop() int { res := ms.data[len(ms.data)-1] ms.data = ms.data[:len(ms.data)-1] ms.maxes = ms.maxes[:len(ms.maxes)-1] return res}func (ms *MaxStack) Max() int { return ms.maxes[len(ms.maxes)-1]}func (ms *MaxStack) Len() int { return len(ms.data)} ä½¿ç”¨ä»£ç  123456789101112131415161718func maxSlidingWindow(nums []int, k int) []int { queue := MaxQueue{ stack1: MaxStack{}, stack2: MaxStack{}, } for i := 0; i &lt; k; i++ { queue.Push(nums[i]) } res := make([]int, 0) for i := k; i &lt; len(nums); i++ { res = append(res, queue.Max()) queue.shift() queue.Push(nums[i]) } res = append(res, queue.Max()) return res} æ ˆ-è®¡ç®—å™¨ä¸­å€¼è¡¨è¾¾å¼è½¬æ³¢å…°è¡¨è¾¾å¼ï¼ˆå®é™…ä¸Šæ˜¯ï¼‰ é“¾è¡¨åˆ é™¤å€’æ•°çš„ç¬¬ N ä¸ªèŠ‚ç‚¹1234567891011121314151617181920212223func removeNthFromEnd(head *ListNode, n int) *ListNode { // å› ä¸ºå¯èƒ½åˆ é™¤å¤´ç»“ç‚¹ æ‰€æœ‰åŠ äº†ä¸€ä¸ª newHead := new(ListNode) newHead.Next = head // fast æ˜¯å…ˆèµ°çš„ä¸€ä¸ªèŠ‚ç‚¹ pre æ˜¯åèµ°çš„ pre, fast := newHead, head for n &gt; 0 { // æœ‰é—®é¢˜ æ•°é‡ä¸å¤Ÿ if fast == nil { return nil } fast = fast.Next n-- } // ä¸¤ä¸ªæŒ‡é’ˆå¼€å§‹èµ° for fast != nil { fast = fast.Next pre = pre.Next } pre.Next = pre.Next.Next return newHead.Next} åˆå¹¶ k ä¸ªå·²ç»æ’åºçš„é“¾è¡¨ç±»ä¼¼å½’å¹¶æ’åº 1234567891011121314151617181920212223242526272829303132333435363738394041package classic// mergeKLists åˆå¹¶kä¸ªå·²ç»æŒ‰ç…§å‡åºæ’åˆ—çš„æ•°ç»„func mergeKLists(lists []*ListNode) *ListNode { return merge(lists,0, len(lists) - 1)}func merge(lists []*ListNode, start, end int) *ListNode { if start &gt; end { return nil } if start == end { return lists[start] } mid := (start + end) / 2 left, right := merge(lists, start, mid), merge(lists, mid + 1, end) return mergeTwoList(left, right)}func mergeTwoList(list1 *ListNode, list2 *ListNode) *ListNode { res := new(ListNode) rem := res for list1 != nil &amp;&amp; list2 != nil { if list1.Val &gt; list2.Val { res.Next = list2 list2 = list2.Next } else { res.Next = list1 list1 = list1.Next } res = res.Next } if list1 != nil { res.Next = list1 } if list2 != nil { res.Next = list2 } return rem.Next} ç¿»è½¬é“¾è¡¨ä¸€ç³»åˆ—åè½¬é“¾è¡¨æœ€ç®€å•çš„åè½¬é“¾è¡¨çš„æ€è·¯è‚¯å®šæ˜¯ç›´æ¥ç”¨ä¸€ä¸ª stackï¼ŒFILO çš„æœºåˆ¶æ¥åè½¬ï¼Œè€Œä¸é‡‡ç”¨é¢å¤–çš„ç©ºé—´å¯ä»¥ç”¨ä¸€ä¸‹çš„æ–¹æ³• 12345678910111213141516func reverseList(head *ListNode) *ListNode { // åè½¬åçš„å¤´èŠ‚ç‚¹ var pre *ListNode = nil for head != nil { // ç”¨ä¸€ä¸ª å±€éƒ¨å˜é‡ æ¥ä¿å­˜ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ next := head.Next // åè½¬å½“å‰éå†çš„ head èŠ‚ç‚¹ï¼ŒæŒ‡å‘å·²ç»åè½¬å®Œæ¯•çš„å¤´ç»“ç‚¹ head.Next = pre pre = head // é‡æ–°è®¾ç½® head å¤´ head = next } return pre} åè½¬é“¾è¡¨ IIåè½¬é“¾è¡¨ II æ˜¯åè½¬é“¾è¡¨ä¸‹è¡¨ä» m -&gt; n çš„ä¸€ä¸ªé“¾è¡¨ï¼Œå®é™…ä¸Šé‡‡ç”¨ä¸Šè¿°çš„åè½¬çš„æ“ä½œï¼Œå³å¯åè½¬ m -&gt; n ä¹‹é—´çš„èŠ‚ç‚¹ 1234567891011121314151617181920212223242526272829303132333435363738// ä¸»å‡½æ•°func reverseBetween(head *ListNode, m int, n int) *ListNode { // æ·»åŠ ä¸€ä¸ªæ–°çš„å¤´ç»“ç‚¹ï¼Œä¿éšœåŸæ¥çš„å¤´ç»“ç‚¹è¢«åè½¬æ—¶çš„ç»“æœ newHead := new(ListNode) newHead.Next = head cp := newHead // åˆ†åˆ«ä¿å­˜éœ€è¦åè½¬çš„èŠ‚ç‚¹ä¹‹å‰çš„ä¸€ä¸ªèŠ‚ç‚¹ä»¥åŠæœ€åéœ€è¦åè½¬çš„ä¸€ä¸ªèŠ‚ç‚¹ var preStartNode, endNode *ListNode = nil, nil for i := 0; cp != nil; cp, i = cp.Next, i + 1 { if i == m - 1 { preStartNode = cp } if i == n { endNode = cp } } // ä¿å­˜åè½¬å®Œæ¯•åçš„é“¾è¡¨éœ€è¦è¿æ¥åˆ°çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ afterEndNode := endNode.Next reverseHead, reverseEnd := reverseBetweenNodes(preStartNode.Next, afterEndNode) preStartNode.Next = reverseHead reverseEnd.Next = afterEndNode return newHead.Next}// reverseBetweenNodes reverseä¸¤ä¸ªnodeä¹‹é—´çš„é“¾è¡¨// å…¶ä¸­ startNode ä¸ºå¼€å§‹ç¿»è½¬çš„èŠ‚ç‚¹ endNodeNext ä¸ºç»“æŸç¿»è½¬çš„èŠ‚ç‚¹çš„åä¸€ä¸ªèŠ‚ç‚¹func reverseBetweenNodes(startNode, endNodeNext *ListNode) (*ListNode, *ListNode) { var newHead *ListNode = nil newEndNode := startNode for startNode != endNode { next := startNode.Next startNode.Next = newHead newHead = startNode startNode = next } return newHead, newEndNode} reverse K groupreverse K group çš„æ›´è¿›ä¸€æ­¥ï¼Œåœ¨ä¸Šé¢ä¸€é¢˜çš„åŸºç¡€ä¸Šï¼Œæ¯ K ä¸ªèŠ‚ç‚¹åè½¬ä¸€æ¬¡ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// reverseKGroup kä¸ªä¸€ç»„ç¿»è½¬func reverseKGroup(head *ListNode, k int) *ListNode { newHead := new(ListNode) newHead.Next = head var preStartNode, endNode *ListNode = newHead, nil counter := 0 mov := newHead for mov != nil { if counter == k { endNode = mov afterEnd := endNode.Next // è°ƒç”¨äºŒé¢˜ä¸­æ‰€è¿°çš„å‡½æ•°è¿›è¡Œåè½¬ reverseHead, reverseEnd := reverseBetweenNodes(preStartNode.Next, endNode.Next) preStartNode.Next = reverseHead reverseEnd.Next = afterEnd // å› ä¸ºåè½¬ä¹‹åè¦é‡æ–°è®°å½• preStartNode counter = 0 // åè½¬ä¹‹åçš„éœ€è¦å†æ¬¡åè½¬çš„å¤´æ˜¯ä¸Šæ¬¡åè½¬çš„å°¾ç»“ç‚¹ preStartNode = reverseEnd // é‡æ–°å®šä½ç§»æ ‡ mov = reverseEnd } mov = mov.Next counter++ } return newHead.Next}// reverseBetweenNodes reverseä¸¤ä¸ªnodeä¹‹é—´çš„é“¾è¡¨// å…¶ä¸­ startNode ä¸ºå¼€å§‹ç¿»è½¬çš„èŠ‚ç‚¹ endNodeNext ä¸ºç»“æŸç¿»è½¬çš„èŠ‚ç‚¹çš„åä¸€ä¸ªèŠ‚ç‚¹func reverseBetweenNodes(startNode, endNodeNext *ListNode) (*ListNode, *ListNode) { var newHead *ListNode = nil newEndNode := startNode for startNode != endNodeNext { next := startNode.Next startNode.Next = newHead newHead = startNode startNode = next } return newHead, newEndNode} æ ‘æ ‘çš„éå†ä¸­åºéå†123456789101112131415161718func inorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := list.New() for root != nil || stack.Len() != 0 { for root != nil { stack.PushBack(root) root = root.Left } if stack.Len() &gt; 0 { root = stack.Remove(stack.Back()).(*TreeNode) res = append(res, root.Val) root = root.Right } } return res} å‰åºéå†12345678910111213141516171819202122package classicimport &quot;container/list&quot;func preorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := list.New() for root != nil || stack.Len() &gt; 0 { for root != nil { res = append(res, root.Val) stack.PushBack(root) root = root.Left } if stack.Len() &gt; 0 { root = stack.Remove(stack.Back()).(*TreeNode) root = root.Right } } return res} ååºéå†12345678910111213141516171819202122232425262728293031func postorderTraversal(root *TreeNode) []int { res := make([]int, 0) stack := list.New() // æ ‡è¯†è¿™ä¸ªnodeæ˜¯ä¸æ˜¯ç¬¬äºŒæ¬¡è®¿é—® stackForFlag := list.New() for root != nil || stack.Len() &gt; 0 { for root != nil { stack.PushBack(root) stackForFlag.PushBack(false) root = root.Left } if stack.Len() &gt; 0 { root = stack.Remove(stack.Back()).(*TreeNode) flag := stackForFlag.Remove(stackForFlag.Back()).(bool) // è¯´æ˜æ˜¯ç¬¬äºŒæ¬¡è®¿é—® è¿™ä¸ªæ—¶å€™è¦è®¿é—®çˆ¶äº²èŠ‚ç‚¹ if flag { res = append(res, root.Val) root = nil } else { // ç¬¬ä¸€æ¬¡è®¿é—® stack.PushBack(root) stackForFlag.PushBack(true) root = root.Right } } } return res} å±‚æ¬¡éå† æ™®é€šå±‚æ¬¡éå† 123456789101112131415161718192021222324252627282930313233func levelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } tmp := make([]int, 0) queue := list.New() queue.PushBack(root) queue.PushBack(nil) for queue.Len() &gt; 0 { node := queue.Remove(queue.Front()) if node == nil { cp := make([]int, len(tmp)) copy(cp, tmp) res = append(res, cp) if queue.Len() == 0 { break } queue.PushBack(nil) tmp = make([]int, 0) continue } top := node.(*TreeNode) if top.Left != nil { queue.PushBack(top.Left) } if top.Right != nil { queue.PushBack(top.Right) } tmp = append(tmp, top.Val) } return res} zigzag çš„å±‚æ¬¡éå† 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package classicimport &quot;container/list&quot;func zigzagLevelOrder(root *TreeNode) [][]int { res := make([][]int, 0) if root == nil { return res } isLeft := true tmp := make([]int, 0) queue := list.New() queue.PushBack(root) queue.PushBack(nil) for queue.Len() &gt; 0 { top := queue.Remove(queue.Front()) if top == nil { cp := make([]int, len(tmp)) copy(cp, tmp) res = append(res, cp) if queue.Len() == 0 { break } isLeft = !isLeft tmp = make([]int, 0) queue.PushBack(nil) continue } node := top.(*TreeNode) if node.Left != nil { queue.PushBack(node.Left) } if node.Right != nil { queue.PushBack(node.Right) } // è¿™ä¸ªåœ°æ–¹å¯ä»¥è¿™æ ·åŠ å…¥ å°±ä¸ç”¨å† top == nil ä¸­é‡æ–°åè½¬æ•°ç»„ if isLeft { tmp = append(tmp, node.Val) } else { tmp = append([]int{node.Val}, tmp...) } } return res} å‰ç¼€æ ‘å®ç°ç”¨å­—ç¬¦ä¸²çš„å‰ç¼€æ¥ç´¢å¼•çš„ç»“æ„æ ‘ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// Trie ä¹‹é—´é€šè¿‡ å­—ç¬¦ å…³è” ä¸Šä¸€ä¸ª trie ä¼šé€šè¿‡å­—ç¬¦ä½œä¸ºè¾¹è¿æ¥ä¸‹ä¸€ä¸ªèŠ‚ç‚¹type Trie struct { data []*Trie // å­˜å‚¨ç´¢å¼•ç»“æ„çš„æ•° å› ä¸ºåªåŒ…å« a-z çš„å­—æ¯ ç´¢å¼•ç›´æ¥æ•°ç»„å³å¯ ä¸ç„¶ç”¨ map ä¼šæ›´å¥½ isEnd bool // æ˜¯å¦ç»“æŸèŠ‚ç‚¹}/** Initialize your data structure here. */func Constructor() Trie { return Trie{ data: make([]*Trie, 26), isEnd: false, }}/** Inserts a word into the trie. */func (this *Trie) Insert(word string) { tmp := this for _, char := range word { if tmp.data[char-'a'] == nil { tmp.data[char-'a'] = &amp;Trie{ data: make([]*Trie, 26), isEnd: false, } } tmp = tmp.data[char-'a'] } tmp.isEnd = true}/** Returns if the word is in the trie. */func (this *Trie) Search(word string) bool { tmp := this for _, char := range word { if tmp.data[char-'a'] == nil { return false } tmp = tmp.data[char-'a'] } return tmp.isEnd}/** Returns if there is any word in the trie that starts with the given prefix. */func (this *Trie) StartsWith(prefix string) bool { tmp := this for _, char := range prefix { if tmp.data[char-'a'] == nil { return false } tmp = tmp.data[char-'a'] } return true} å›¾å¹¶æŸ¥é›†çš„æ•°æ®ç»“æ„å¹¶æŸ¥é›†ï¼Œè¡¨ç¤ºçš„æ˜¯ä¸€ä¸ªæ ‘å½¢çš„ç»“æ„ å¦‚å›¾æ‰€ç¤ºï¼Œé’ˆå¯¹å›¾çš„ä¸€ä¸ªæå¤§è¿é€šåˆ†é‡ï¼Œä¼šå½¢æˆä¸€ä¸ªå¯¹åº”çš„æ ‘ç»“æ„ï¼ˆå¹¶æŸ¥é›†åªå…³æ³¨ä¸€ä¸ªè¿é€šåˆ†é‡æœ‰å¤šå°‘è¿æ¥ç‚¹ï¼Œä¸å…³æ³¨å†…éƒ¨çš„å…¶ä»–çš„ç»†èŠ‚ï¼‰ æ‰€ä»¥é’ˆå¯¹æŸ¥æ‰¾è¿é€šåˆ†é‡æœ‰å“ªäº›ï¼Œä»¥åŠè¿åŒé‡é—´çš„å…³ç³»æœ‰ä½œç”¨ å¹¶æŸ¥é›†å­˜å‚¨æ•°æ®çš„ç»“æ„123type Union struct { parents []int // å­˜å‚¨æ ‘çš„æ•°æ®ç»“æ„ parents[i] è¡¨ç¤ºè¿æ¥åˆ°è¯¥èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹çš„ç´¢å¼• å¦‚æœä¸èƒ½ç”¨ int æ¥è¡¨ç¤º å¯ä»¥è€ƒè™‘ map ç±»çš„æ•°æ®ç»“æ„} å¹¶æŸ¥é›†çš„æ“ä½œ union (è”åˆï¼Œå…³è”ä¸¤ä¸ªç‚¹) find (æŸ¥æ‰¾ï¼Œæ‰¾åˆ°å½“å‰ç‚¹çš„æœ€ç»ˆçš„çˆ¶èŠ‚ç‚¹) æ‰€ä»¥ï¼Œå®é™…ä¸Š å¦‚æœ r1 r2 ä¹‹é—´æœ‰è¿æ¥çº¿çš„è¯ï¼Œè¦å…³è” r1 r2 çš„æ“ä½œå°±æ˜¯ã€‚ å°±æ˜¯é€šè¿‡ find æ‰¾åˆ°åˆ†åˆ«çš„æ ¹èŠ‚ç‚¹ r1Root r2Root åœ¨é€šè¿‡ union æ–¹æ³•å…³è”ä¸¤ä¸ªæ ¹èŠ‚ç‚¹ï¼Œå®é™…ä¸Šå°±æ˜¯å°† r2Root ä½œä¸ºä¸€ä¸ªå­èŠ‚ç‚¹ï¼ŒæŒ‚è½½åˆ° r1Root ä¸‹ æ‰€ä»¥æ•´ä½“çš„æ•°æ®ç»“æ„ä¸º 12345678910111213141516171819202122232425262728293031323334353637type unionFind struct { Parents []int Count int // è¡¨ç¤ºè¿é€šåˆ†é‡çš„å¤šå°‘}func NewUnionFind(size int) *unionFind { res := &amp;unionFind{ Parents: make([]int, size), Count: size, } // åˆå§‹åŒ–å¹¶æŸ¥é›†ä¸­çš„æ¯ä¸ªå…ƒç´ çš„çˆ¶èŠ‚ç‚¹éƒ½æ˜¯è‡ªå·± for i := 0; i &lt; size; i++ { res.Parents[i] = i } return res}func (u *unionFind) union(i, j int) { iRoot := u.find(i) jRoot := u.find(j) if iRoot != jRoot { u.Parents[jRoot] = iRoot // æ¯æ¬¡è¿æ¥ä¸€ä¸ªä¹‹å æœ€å¤§è¿é€šåˆ†é‡å°±è¦ -- u.Count-- }}func (u *unionFind) find(i int) int { if u.Parents[i] == i { return i } return u.find(u.Parents[i])}func (u *unionFind) GetCount() int { return u.Count} æ‰§è¡Œäº¤æ¢æ“ä½œåçš„æœ€å°æ±‰æ˜è·ç¦»è¿™é“é¢˜å®é™…ä¸Šæ˜¯æ‰¾è¿é€šåˆ†é‡ï¼Œå¯¹æ¯”ä¸¤ä¸ªæ•°ç»„ä¸­ç›¸åº”çš„è¿é€šåŒºåŸŸä¸ç­‰çš„éƒ¨åˆ†ï¼Œæ‰€ä»¥å¯ä»¥ç”¨æ— å‘å›¾è¿é€šåˆ†é‡ dfs or å¹¶æŸ¥é›† å¾—åˆ°è¿é€šåˆ†é‡åè¿›è¡Œå¤„ç†ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.util.Arrays;import java.util.HashMap;import java.util.Map;public class MinimumHammingDistance_1722 { public void union(int[] union, int i, int j) { int x = getParent(union, i); int y = getParent(union, j); if (x != y) { union[y] = x; } } public int getParent(int[] union, int i) { if (union[i] == -1) return i; return getParent(union, union[i]); } public void changeUnion(int[] union) { boolean[] memo = new boolean[union.length]; for (int i = 0; i &lt; union.length; i++) { if (!memo[i]) { recursion(union, memo, i); } } } // æ›´è¯¥ union åˆ°root public int recursion(int[] union, boolean[] memo, int i) { if (memo[i]) return union[i]; memo[i] = true; if (union[i] == -1 || union[i] == i) { union[i] = i; return i; } int root = recursion(union, memo, union[i]); union[i] = root; return root; } // è¿é€šå›¾é—®é¢˜ åœ¨è¿é€šåˆ†é‡é‡Œé¢æ‰¾åˆ°ä¸ç­‰çš„æ•°å­— // æ— å‘å›¾çš„è¿é€šåˆ†é‡ // å¯ä»¥ä½¿ç”¨ dfs å¾—åˆ°æ— å‘å›¾çš„è¿é€šåˆ†é‡ or ä½¿ç”¨ union çš„ç®—æ³•å¾—åˆ°è¿é€šåˆ†é‡ // ä½†æ˜¯ union ç®—æ³•å¦‚æœç›´æ¥åœ¨ç®—æ³•æ‰§è¡Œå›¾ä¸­å»æ›´æ”¹æ‰€æœ‰çš„ root å€¼ ä¼šæ…¢ä¸€ç‚¹å„¿ æ‰€ä»¥åœ¨æ‰§è¡Œå®Œæ¯•åå»æ›´æ”¹ public int minimumHammingDistance(int[] source, int[] target, int[][] allowedSwaps) { int[] union = new int[source.length]; Arrays.fill(union, -1); for (int[] allowSwap : allowedSwaps) { union(union, allowSwap[0], allowSwap[1]); } // ä¿®æ”¹è¿é€šåˆ†é‡æ ‡è¯† åˆ°æ ¹èŠ‚ç‚¹ changeUnion(union); // ç°åœ¨æ¯ä¸ªä¸­å¯¹åº”çš„éƒ½æ˜¯ä¸€ä¸ªè¿é€šåˆ†é‡çš„æ ¹èŠ‚ç‚¹çš„ä¸‹æ ‡ï¼Œé‚£ä¹ˆå°±éœ€è¦çŸ¥é“ ä¸€ä¸ªè¿é€šåˆ†é‡é‡Œé¢æœ‰å¤šå°‘ä¸ªä¸ç­‰çš„ // ä¿å­˜rootä¸­çš„æ•°å­—æ¯ä¸ªå‡ºç°äº†å‡ æ¬¡ Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; sMap = new HashMap&lt;&gt;(); for (int i = 0; i &lt; union.length; i++) { int root = union[i]; if (!sMap.containsKey(root)) sMap.put(root, new HashMap&lt;&gt;()); Map&lt;Integer, Integer&gt; tmp = sMap.get(root); tmp.put(source[i], tmp.getOrDefault(source[i], 0) + 1); } int res = 0; for (int i = 0; i &lt; union.length; i++) { int root = union[i]; Map&lt;Integer, Integer&gt; tmp = sMap.get(root); if (!tmp.containsKey(target[i]) || tmp.get(target[i]) == 0) { res++; } else { tmp.put(target[i], tmp.get(target[i]) - 1); } } return res; } public static void main(String[] args) { System.out.println(new MinimumHammingDistance_1722().minimumHammingDistance(new int[]{49, 21, 79, 79, 6, 67, 78, 9, 91, 39, 49, 32, 53, 29, 97, 50, 82, 55, 13, 83, 63, 99, 41, 6, 51, 46, 31, 26, 58, 18, 32, 51, 44, 66, 40, 35, 96, 20, 35, 43, 64, 96, 99, 76, 11, 35, 86, 96, 10, 19, 70, 29, 19, 47}, new int[]{33, 22, 32, 71, 66, 90, 78, 67, 74, 76, 84, 32, 25, 100, 57, 7, 90, 95, 33, 79, 54, 99, 42, 6, 32, 55, 31, 14, 58, 67, 48, 59, 7, 50, 5, 22, 11, 97, 94, 14, 53, 75, 3, 9, 82, 74, 86, 27, 21, 77, 70, 29, 65, 15}, new int[][]{{40, 41}, {41, 35}, {18, 19}, {9, 51}, {48, 2}, {45, 13}, {27, 45}, {16, 22}, {23, 25}, {2, 6}, {5, 11}, {37, 38}, {22, 48}, {13, 48}, {51, 37}, {24, 19}, {2, 32}, {38, 23}, {33, 34}, {37, 44}, {31, 8}, {4, 26}, {34, 35}, {37, 28}, {48, 34}, {27, 0}, {23, 37}, {17, 29}, {38, 7}, {37, 31}, {34, 42}, {26, 20}, {22, 45}, {26, 29}, {40, 42}, {48, 30}, {46, 49}, {12, 52}, {49, 28}, {39, 14}, {23, 34}, {6, 30}, {18, 12}, {52, 49}, {21, 18}, {11, 4}, {2, 7}, {4, 17}, {19, 27}, {33, 5}, {44, 28}, {38, 9}, {34, 7}, {7, 47}, {37, 13}, {51, 12}, {42, 53}, {42, 21}, {18, 9}, {21, 39}, {4, 33}, {29, 39}, {47, 41}, {25, 13}, {50, 0}, {21, 48}, {32, 27}, {33, 53}, {39, 5}, {12, 25}, {52, 6}, {17, 44}, {16, 52}, {0, 34}, {14, 29}, {0, 19}, {13, 7}, {29, 21}, {9, 22}, {28, 45}, {1, 29}, {37, 17}, {38, 36}, {4, 23}, {38, 21}, {35, 5}, {2, 16}, {34, 30}, {37, 16}, {40, 53}, {51, 47}, {20, 32}, {7, 9}, {12, 15}, {26, 0}, {14, 44}, {53, 11}, {48, 17}})); }} è¿é€šç½‘ç»œçš„æ“ä½œæ¬¡æ•°é¢˜ç›®æ‰€è¿°ï¼Œç»™å®šä¸€ä¸ªå›¾ï¼Œæ‰¾åˆ°å°†å…¶æ‰€æœ‰æœ€å¤§è¿é€šåˆ†é‡è¿é€šæ‰€éœ€æ›´æ”¹çš„æœ€å°‘çš„è¾¹çš„æ•°é‡ä¸ºå¤šå°‘ã€‚ å›¾çš„æ‰€æœ‰æœ€å°è¿é€šä¸ºä¸€ä¸ªæ ‘ï¼Œå³éœ€è¦ n ä¸ªèŠ‚ç‚¹æœ‰ n - 1 æ¡è¾¹ã€‚ æ‰€ä»¥é¢˜ç›®å…¶å®æ˜¯è¦æ‰¾åˆ°è¿™ä¸ªå›¾é‡Œé¢æœ‰å¤šå°‘ç‹¬ç«‹çš„è¿é€šåˆ†é‡ï¼Œç„¶ååˆ¤æ–­å…¶æ˜¯å¦å¯ä»¥è¿æ¥ ç¬¬ä¸€ç§æ€è·¯å°±æ˜¯ç›´æ¥ dfs éå†ï¼Œæ‰¾åˆ°æ‰€æœ‰çš„è¿é€šåˆ†é‡ã€‚é¦–å…ˆåˆ¤æ–­è¾¹çš„æ•°é‡æ˜¯å¦è¶³å¤Ÿ n - 1 è¿™ä¸ªæ—¶å€™ï¼Œå¦‚æœæœ‰å¤šä¸ªè¿é€šåˆ†é‡ï¼Œè¯´æ˜æŸä¸ªè¿é€šåˆ†é‡ä¸€å®šæœ‰å¤šçš„è¾¹ï¼Œéšæ„é€‰å–å…¶ä¸­çš„è¾¹å³å¯ 123456789101112131415161718192021222324252627282930313233343536373839404142434445package classic// makeConnected æ–¹æ³•æŸ¥çœ‹func makeConnected(n int, connections [][]int) int { // æœ€çŸ­çš„è¯è‚¯å®šæ˜¯å½¢æˆä¸€æ£µæ ‘ æ‰èƒ½è”é€šæ‰€æœ‰ // æ‰€ä»¥ è¾¹ è‡³å°‘è¦è¾¾åˆ° n - 1 çš„æ•°é‡ // è¿™ä¸ªæ—¶å€™ä¸èƒ½è¿é€š if len(connections) &lt; n-1 { return -1 } // map çš„é‚»æ¥è¡¨è¡¨ç¤º cMap := make(map[int][]int) for _, connection := range connections { if _, ok := cMap[connection[0]]; !ok { cMap[connection[0]] = make([]int, 0) } cMap[connection[0]] = append(cMap[connection[0]], connection[1]) if _, ok := cMap[connection[1]]; !ok { cMap[connection[1]] = make([]int, 0) } cMap[connection[1]] = append(cMap[connection[1]], connection[0]) } // åˆ°è¿™é‡Œçš„æ—¶å€™ ç”±äºè¾¹çš„æ•°é‡å¤Ÿ æ‰€ä»¥ä¸€å®šæ˜¯å¯ä»¥è¿é€šçš„ // è¿™ä¸ªæ—¶å€™ åªéœ€è¦çŸ¥é“æœ‰ m å—æ˜¯ä¸ç›¸è¿çš„ ç„¶åå°±çŸ¥é“éœ€è¦è¿æ¥çš„æ¬¡æ•°å°±ä¸º m - 1 memo := make([]bool, n) res := 0 for i := 0; i &lt; n; i++ { if !memo[i] { res++ dfs(memo, cMap, i) } } return res - 1}func dfs(memo []bool, cMap map[int][]int, start int) { memo[start] = true for _, next := range cMap[start] { if !memo[next] { dfs(memo, cMap, next) } }} å¹¶æŸ¥é›†ï¼Œæ‰¾åˆ°æ¯ä¸ªç¾¤ç»„çš„æ•°æ®çš„ä¸€ä¸ªä»£è¡¨ç‚¹ 12345678910111213141516171819202122232425262728293031323334353637383940414243// findRoot æ‰¾åˆ°æ ¹èŠ‚ç‚¹func findRoot(parents []int, index int) int { if parents[index] == -1 { return index } return findRoot(parents, parents[index])}// makeConnected å¹¶æŸ¥é›†func makeConnected(n int, connections [][]int) int { if len(connections) &lt; n - 1 { return -1 } // å¹¶æŸ¥é›†çš„ parents æ•°ç»„ï¼Œæ ‡è¯† å½“å‰ç´¢å¼•çš„ èŠ‚ç‚¹çš„çˆ¶èŠ‚ç‚¹çš„ç´¢å¼•æ˜¯è° // ç›¸åŒçš„æ•°æœ€åå‡èƒ½æ‰¾åˆ°åŒæ ·çš„çˆ¶èŠ‚ç‚¹ parents := make([]int, n) // åˆå§‹åŒ–æ‰€æœ‰çš„ä¸º -1 for i := 0; i &lt; n; i++ { parents[i] = -1 } // æ‰§è¡Œ union çš„æ“ä½œ for _, connection := range connections { sRoot := findRoot(parents, connection[0]) eRoot := findRoot(parents, connection[1]) // ä¸¤ä¸ªç‚¹ä¸Šæœ‰è¿æ¥çº¿ ä½†æ˜¯ç°åœ¨è¿˜æ²¡æœ‰è¿æ¥èµ·æ¥ // è®©å…¶æ ¹èŠ‚ç‚¹ç›¸è¿ if sRoot != eRoot { // å°† e èŠ‚ç‚¹è¿æ¥åˆ° s ä¸Š parents[eRoot] = sRoot } } // å‰©ä¸‹çš„è¿˜æ˜¯ -1 çš„å°±ä¸€å®šæ˜¯æ•´ä¸ªç¾¤é‡Œé¢çš„ä»£è¡¨èŠ‚ç‚¹ res := 0 for _, val := range parents { if val == -1 { res++ } } return res - 1} ç”±æ–œæ åˆ’åˆ†åŒºåŸŸé‡‡ç”¨å¹¶æŸ¥é›†ï¼Œä½†æ˜¯è¿™é“é¢˜æœ‰ç‰¹æ®Šçš„åœ°æ–¹ã€‚ é¢˜ç›®ä¸­æ‰€ç¤ºï¼Œé’ˆå¯¹ä¸€ä¸ªæ–¹æ ¼æœ‰ / å’Œ \\ ä¸¤ç§ï¼Œå¦‚ä¸‹ ---- ---- |\\ | | /| | \\| |/ | ---- ---- æ€»ä¹‹ï¼Œé’ˆå¯¹ä¸€ä¸ª æ–¹æ ¼ ï¼Œå¯ä»¥æŠŠä»–çœ‹æˆå››ä¸ªéƒ¨åˆ† é‚£ä¹ˆï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œ å¦‚æœå½“å‰ char == â€˜ â€˜ è¡¨ç¤º 0 1 2 3 éƒ½æ˜¯è”é€šçš„ å¦‚æœ char == â€˜\\â€˜ è¡¨ç¤º 01 23 åˆ†åˆ«è¿é€š char == â€˜/â€˜ è¡¨ç¤º 03 12 åˆ†åˆ«è¿é€š å†…éƒ¨çš„è¿é€šå®Œæ¯•åï¼Œ è¿˜å¯ä»¥çŸ¥é“ 1 ä¸€å®šè·Ÿä¸‹ä¸€ä¸ª 3 è¿é€š 2 ä¸€å®šè·Ÿä¸‹ä¸€è¡Œçš„ 0 è¿é€š 1234567891011121314151617181920212223242526272829303132333435363738394041424344// regionsBySlashes é€šè¿‡æ–œæ åˆ’åˆ†func regionsBySlashes(grid []string) int { // n * n çš„çŸ©é˜µçš„é•¿åº¦ length := len(grid) // ä¸ºäº†ä½¿ç”¨ å¹¶æŸ¥é›† å°†ä¸€ä¸ª1*1 çš„æ­£æ–¹å½¢ï¼Œå³ ä¸€ä¸ª grid[i] æ ‡è¯†çš„åŒºåŸŸåˆ†æˆ å››ä¸ªåœ°æ–¹ // ç„¶åå†æ ¹æ® / \\\\ ä¸¤ä¸ªç¬¦å·çš„ä½ç½®è¿›è¡Œåˆå¹¶ æœ€åçœ‹æœ‰å‡ ä¸ªèŠ‚ç‚¹ unionSize := 4 * length * length u := NewUnionFind(unionSize) for i, str := range grid { for j, char := range str { // 0 å·ä½ç½® uIndex := 4 * (i*length + j) // åŒä¸€ä¸ªå•å…ƒæ ¼é‡Œé¢çš„è¿æ¥èµ·æ¥ switch char { // 0 1 2 3 éƒ½è¦è¿æ¥èµ·æ¥ case ' ': u.union(uIndex, uIndex + 1) u.union(uIndex + 1, uIndex + 2) u.union(uIndex + 2, uIndex + 3) case '\\\\': // åæ–œæ çš„è¯ 01 23 åˆ†åˆ«è¿æ¥ u.union(uIndex, uIndex + 1) u.union(uIndex + 2, uIndex + 3) case '/': // æ–œæ çš„è¯ 03 12 åˆ†è´è¿æ¥ u.union(uIndex, uIndex + 3) u.union(uIndex + 1, uIndex + 2) } // å•å…ƒæ ¼å¤–é¢çš„è¿æ¥èµ·æ¥ // ä¸ç®¡æ˜¯ \\\\ è¿˜æ˜¯ / è¿™ä¸ªåŒºåŸŸçš„1ä¸€å®šå¯ä»¥å’Œå³è¾¹ä¸‹ä¸€ä¸ªåŒºåŸŸ( j+ 1)çš„ 3 è¿æ¥ // è¿™ä¸ªåŒºåŸŸçš„ 2 ä¸€å®šå¯ä»¥å’Œä¸‹è¾¹(i + 1)ä¸‹ä¸€ä¸ªåŒºåŸŸçš„ 0 è¿æ¥ if j + 1 &lt; length { u.union(uIndex+1, 4*(i*length+j+1)+3) } if i + 1 &lt; length { u.union(uIndex+2, 4*((i+1)*length+j)) } } } return u.GetCount()} æ°´ä½ä¸Šå‡çš„æ³³æ± ä¸­æ¸¸æ³³è¿™é“é¢˜æ²¡æƒ³æ˜ç™½æœ€å¼€å§‹ï¼Œè‚¯å®šæ˜¯æ˜ç™½è¦çŸ¥é“åˆ°ä»€ä¹ˆæ—¶å€™ [0,0] è·Ÿ [n - 1, n - 1] çš„å³ä¸‹è§’ç›¸è¿ ç›¸è¿çš„åˆ¤æ–­å¯ä»¥é€šè¿‡å¹¶æŸ¥é›†å®ç° é‚£ä¹ˆå°±è¦è§£å†³å‡ ä¸ªé—®é¢˜ï¼š æ€ä¹ˆéå† å¹¶æŸ¥é›†è¿æ¥çš„æ¡ä»¶æ˜¯ä»€ä¹ˆ æ€ä¹ˆæŠŠäºŒç»´æ•°ç»„çš„ä½ç½®æŠ½è±¡åˆ°ä¸€ç»´ ä»ä»¥ä¸‹å‡ ä¸ªæ–¹é¢å…¥æ‰‹ é¢˜ç›®ä¸­æ‰€è¿° grid ä¸­çš„æ•°å€¼ä» [0, nn-1] çš„å”¯ä¸€æ•°å€¼ï¼Œä¹Ÿå°±æ˜¯è¯´æ¯ä¸ªæ ¼å­çš„é«˜åº¦éƒ½æ˜¯ç‹¬ç«‹çš„ï¼Œå› æ­¤åªéœ€è¦éå†é«˜åº¦ï¼Œåœ¨éå†é«˜åº¦ä¸­å¦‚æœ [0, nn-1] ç›¸è¿ï¼Œå³å®Œæˆè¿æ¥ ç”±äºé¢˜ç›®ä¸­ å½“éå†çš„ä½ç½®è¾¾åˆ°ä¸€ä¸ªé«˜åº¦çš„æ—¶å€™ï¼Œä»–å¯ä»¥ç›´æ¥å’Œä¸Šä¸‹å·¦å³ä¸Šçš„ç›¸è¿ï¼Œä¹Ÿå°±æ˜¯è¯´éå†åˆ°é«˜åº¦æ›´é«˜çš„åœ°æ–¹èƒ½å¤Ÿç›´æ¥æ¯”é«˜åº¦æ›´ä½çš„åœ°æ–¹è¿æ¥ è€Œé¢˜ç›®ä¸­çš„ grid çš„æ£‹ç›˜çš„äºŒç»´æ•°ç»„å¯ä»¥é€šè¿‡ç®€å•çš„ n*x+y æŠ½è±¡åˆ°ä¸€ç»´ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465package classicfunc union(parents []int, i, j int) { iRoot, jRoot := findRootOfParents(parents, i), findRootOfParents(parents, j) if iRoot != jRoot { parents[jRoot] = iRoot }}func findRootOfParents(parents []int, i int) int { if parents[i] == i { return i } return findRootOfParents(parents, parents[i])}func isConnectedParents(parents []int, i, j int) bool { return findRootOfParents(parents, i) == findRootOfParents(parents, j)}var ( // è¡¨ç¤ºä¸Šä¸‹å·¦å³å››ä¸ªæ–¹å‘ DIRECTIONS = [][]int{{0, 1}, {0, -1}, {1, 0}, {-1, 0}})func swimInWater(grid [][]int) int { if grid == nil { return -1 } n := len(grid) index := make([]int, n*n) for i := 0; i &lt; n; i++ { for j := 0; j &lt; n; j++ { // å› ä¸ºé¢˜ç›®ä¸­æ‰€è¿°ï¼Œgrid é‡Œé¢çš„æ•°å€¼ä» 0 -&gt; n * n - 1 // æ‰€ä»¥è®©é«˜åº¦ä½œä¸ºä¸‹æ ‡ç´¢å¼• æ–¹ä¾¿ä¸‹é¢éå† index[grid[i][j]] = n*i + j } } // grid çš„äºŒä½æ•°ç»„ å¯ä»¥è½¬ä¸º n * i + j çš„ä¸€ç»´åæ ‡ parents := make([]int, n*n) for i := 0; i &lt; n*n; i++ { parents[i] = i } for i := 0; i &lt; n*n; i++ { x, y := index[i]/n, index[i]%n for _, direction := range DIRECTIONS { newX, newY := x+direction[0], y+direction[1] // å› ä¸ºè¿™ä¸ªæ˜¯ä»é«˜åº¦ç›¸è·åªæœ‰1çš„åœ°æ–¹å¼€å§‹çš„ æ‰€ä»¥å¯ä»¥ç›´æ¥å…³è” // è¿™æ ·å½“ 0 n - 1 è¿æ¥åˆ°ä¸€èµ·çš„æ—¶å€™ è¯´æ˜å·²ç»è¾¾åˆ°çš„æœ€å°çš„é«˜åº¦ // åªæœ‰æ–°çš„èŠ‚ç‚¹çš„é«˜åº¦ å°äº å½“å‰çš„é«˜åº¦ æ‰æ˜¯å¯ä»¥æ¸¸è¿‡å»çš„ï¼ï¼ï¼ if !(newX &lt; 0 || newX &gt;= n || newY &lt; 0 || newY &gt;= n) &amp;&amp; grid[newX][newY] &lt;= i { // index çš„ç´¢å¼•ç”¨åœ¨è¿™ä¸ªåœ°æ–¹ union(parents, index[i], newX*n+newY) } if isConnectedParents(parents, 0, n*n-1) { return i } } } return -1} æ‹“æ‰‘æ’åº é€†åç»­æ’åˆ— éå†å‡ºåº¦ä¸º 0 çš„ç‚¹ è¯¾ç¨‹è¡¨è¿™é“é¢˜æœ¬è´¨ä¸Šå°±æ˜¯æ‹“æ‰‘æ’åº ç®€å•çš„åšæ³•å°±æ˜¯ç”¨ dfs å»åˆ¤æ–­æ˜¯å¦æˆç¯ 1234567891011121314151617181920212223242526272829303132333435363738394041func canFinish(numCourses int, prerequisites [][]int) bool { // æœ‰å‘å›¾ mapOfCourses := make([][]int, numCourses) for i := 0; i &lt; numCourses; i++ { mapOfCourses[i] = make([]int, 0) } for _, prerequisite := range prerequisites { mapOfCourses[prerequisite[1]] = append(mapOfCourses[prerequisite[1]], prerequisite[0]) } // ä¿å­˜å·²ç»è®¿é—®è¿‡çš„èŠ‚ç‚¹ è¿™æ ·å¯ä»¥é¿å…é‡å¤è®¿é—® totalMemo := make([]bool, numCourses) for i := 0; i &lt; numCourses; i++ { if !dfsCanFinish(mapOfCourses, make([]bool, numCourses), totalMemo, i) { return false } } return true}// é€šè¿‡ dfs çš„æ–¹æ³•åˆ¤æ–­æ˜¯å¦æˆç¯// ç”¨ memo æ¥è®°å½•ä¸€æ¬¡å¾ªç¯ä¸­è®¿é—®çš„èŠ‚ç‚¹func dfsCanFinish(mapOfCourses [][]int, memo, totalMemo []bool, start int) bool { if totalMemo[start] { return true } totalMemo[start] = true memo[start] = true for _, adj := range mapOfCourses[start] { if !memo[adj] { // æˆªæ–­ æœ‰ç¯ç›´æ¥è¿”å› if !dfsCanFinish(mapOfCourses, memo, totalMemo, adj) { return false } } else { // è¿™ä¸ªåœ°æ–¹å°±æ˜¯æ‰¾åˆ°äº†ç¯ return false } } memo[start] = false return true} æ‹“æ‰‘æ’åº éå†å…¥åº¦ä¸º 0 çš„ç‚¹ 1234567891011121314151617181920212223242526272829303132333435363738func canFinish(numCourses int, prerequisites [][]int) bool { // å…¥åº¦ä¸º 0 çš„ç‚¹ä¸ºèµ·ç‚¹ inDegree := make([]int, numCourses) for _, prerequisite := range prerequisites { // è®©æœ‰å‘å›¾çš„æ¥å—çº¿çš„ä¸€ç«¯ å…¥åº¦++ inDegree[prerequisite[0]]++ } // ä¿å­˜å…¥åº¦ä¸º 0 çš„ç‚¹ inDegreeEqualZero := list.New() for i, in := range inDegree { if in == 0 { inDegreeEqualZero.PushBack(i) } } // éå†å…¥åº¦ä¸º 0 çš„ç‚¹ // æ¯æ¬¡åˆ é™¤ä¸€æ¡è¾¹ åˆ¤æ–­ä¸‹ä¸€ä¸ªç‚¹ æ˜¯å¦å…¥åº¦ä¸º0 å…¥åº¦ä¸º 0 åŠ å…¥åˆ° map ä¸­ ä¸åœçš„éå† ç›´åˆ°æ²¡æœ‰ç‚¹ for inDegreeEqualZero.Len() &gt; 0 { node := inDegreeEqualZero.Remove(inDegreeEqualZero.Front()).(int) for _, prerequisite := range prerequisites { if node == prerequisite[1] { inDegree[prerequisite[0]]-- if inDegree[prerequisite[0]] == 0 { inDegreeEqualZero.PushBack(prerequisite[0]) } } } } for i := 0; i &lt; numCourses; i++ { // è¿™ä¸ªåœ°æ–¹è¯´æ˜è¿˜æœ‰ç‚¹ç›¸è¿ï¼Œå› æ­¤æ˜¯æ— æ³•å®Œæˆçš„ if inDegree[i] != 0 { return false } } return true} æœ€çŸ­è·¯å¾„åœ°å›¾åˆ†ææ‰¾åˆ°å¤šæºæœ€çŸ­è·¯ï¼Œæ”¹é€ äº†ä¸€ä¸‹ dijkstra ç®—æ³• 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public int maxDistance(int[][] grid) { // è€ƒè™‘ä½¿ç”¨ dijkstra ç®—æ³• // dijkstra ç®—æ³•æ˜¯æ‰¾å•æºæœ€çŸ­è·¯ç»çš„ // å› æ­¤åœ¨è¿™å„¿è¦æ”¹é€ ä¸€ä¸‹ // è™šæ‹Ÿå‡ºä¸€ä¸ªè¶…çº§èŠ‚ç‚¹ è¿æ¥æ‰€æœ‰çš„èµ·å§‹èŠ‚ç‚¹ é‚£æ ·å°±å¯ä»¥æ‰¾å‡ºä»è¿™ä¸ªè¶…çº§èŠ‚ç‚¹åˆ° å¦å¤–ä¸€ä¸ªé›†åˆçš„æœ€çŸ­è·ç¦» int n = grid.length; int[][] dst = new int[n][n]; // æ— å‘å›¾ ä¸ºäº†é˜²æ­¢é‡å¤è®¿é—® éœ€è¦ memo boolean[][] memo = new boolean[n][n]; PriorityQueue&lt;Node&gt; pq = new PriorityQueue&lt;&gt;(); for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { dst[i][j] = Integer.MAX_VALUE; // è¿æ¥åˆ°è¶…çº§èŠ‚ç‚¹çš„ dst ä¸º 0 // ä» å²¸å¼€å§‹éå† é‚£ä¹ˆ å²¸åˆ°ä»»æ„ä¸€ä¸ªæµ·çš„æœ€çŸ­è·ç¦»å°±ä¼šä¿å­˜åˆ° æµ·èŠ‚ç‚¹ä¸Š if (grid[i][j] == 1) { dst[i][j] = 0; pq.add(new Node(i, j, 0)); } } } // è¿™æ ·å°±å¯ä»¥å§æ—¶é—´å¤æ‚åº¦é™ä¸‹æ¥ while (!pq.isEmpty()) { Node top = pq.poll(); memo[top.x][top.y] = true; for (int[] direction : directions) { int newX = top.x + direction[0], newY = top.y + direction[1]; // è¶Šç•Œ if (newX &gt;= n || newX &lt; 0 || newY &gt;= n || newY &lt; 0) continue; if (memo[newX][newY]) continue; // relax if (dst[newX][newY] &gt; dst[top.x][top.y] + 1) { dst[newX][newY] = dst[top.x][top.y] + 1; // æ›´æ–° pq é‡Œé¢çš„æœ€çŸ­è·ç¦» pq.removeIf((node) -&gt; node.x == newX &amp;&amp; node.y == newY); pq.add(new Node(newX, newY, dst[newX][newY])); } } } int res = -1; for (int i = 0; i &lt; n; i++) { for (int j = 0; j &lt; n; j++) { // å› ä¸ºç»“æœä¿å­˜åœ¨ æµ·æ´‹å•å…ƒæ ¼å†… if (grid[i][j] == 0) res = Math.max(res, dst[i][j]); } } return res == Integer.MAX_VALUE ? -1 : res;}private static class Node implements Comparable&lt;Node&gt; { int x, y; int dst; public Node(int x, int y) { this.x = x; this.y = y; // è¿˜æ²¡æœ‰æ‰¾åˆ° this.dst = Integer.MAX_VALUE; } public Node(int x, int y, int dst) { this.x = x; this.y = y; this.dst = dst; } @Override public int compareTo(Node o) { return this.dst - o.dst; }}private static int[][] directions = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}}; 1786. ä»ç¬¬ä¸€ä¸ªèŠ‚ç‚¹å‡ºå‘åˆ°æœ€åä¸€ä¸ªèŠ‚ç‚¹çš„å—é™è·¯å¾„æ•°è¯´å®è¯ æˆ‘æ˜¯çœ‹ä¸æ‡‚å—é™è·¯å¾„åˆ°åº•æ˜¯ä»€ä¹ˆæ„æ€ï¼Œæ‰€ä»¥çœ‹äº†ä¸‹ä»–ä»¬çš„æ€è·¯ï¼Œè‡ªå·±å®ç°äº†ä¸€ä¸‹ã€‚ç°åœ¨è´´ä¸ŠåŸé¢˜ ç°æœ‰ä¸€ä¸ªåŠ æƒæ— å‘è¿é€šå›¾ã€‚ç»™ä½ ä¸€ä¸ªæ­£æ•´æ•° n ï¼Œè¡¨ç¤ºå›¾ä¸­æœ‰ n ä¸ªèŠ‚ç‚¹ï¼Œå¹¶æŒ‰ä» 1 åˆ° n ç»™èŠ‚ç‚¹ç¼–å·ï¼›å¦ç»™ä½ ä¸€ä¸ªæ•°ç»„ edges ï¼Œå…¶ä¸­æ¯ä¸ª edges[i] = [ui, vi, weighti] è¡¨ç¤ºå­˜åœ¨ä¸€æ¡ä½äºèŠ‚ç‚¹ ui å’Œ vi ä¹‹é—´çš„è¾¹ï¼Œè¿™æ¡è¾¹çš„æƒé‡ä¸º weighti ã€‚ä»èŠ‚ç‚¹ start å‡ºå‘åˆ°èŠ‚ç‚¹ end çš„è·¯å¾„æ˜¯ä¸€ä¸ªå½¢å¦‚ [z0, z1, z2, â€¦, zk] çš„èŠ‚ç‚¹åºåˆ—ï¼Œæ»¡è¶³ z0 = start ã€zk = end ä¸”åœ¨æ‰€æœ‰ç¬¦åˆ 0 &lt;= i &lt;= k-1 çš„èŠ‚ç‚¹ zi å’Œ zi+1 ä¹‹é—´å­˜åœ¨ä¸€æ¡è¾¹ã€‚è·¯å¾„çš„è·ç¦»å®šä¹‰ä¸ºè¿™æ¡è·¯å¾„ä¸Šæ‰€æœ‰è¾¹çš„æƒé‡æ€»å’Œã€‚ç”¨ distanceToLastNode(x) è¡¨ç¤ºèŠ‚ç‚¹ n å’Œ x ä¹‹é—´è·¯å¾„çš„æœ€çŸ­è·ç¦»ã€‚å—é™è·¯å¾„ ä¸ºæ»¡è¶³ distanceToLastNode(zi) &gt; distanceToLastNode(zi+1) çš„ä¸€æ¡è·¯å¾„ï¼Œå…¶ä¸­ 0 &lt;= i &lt;= k-1 ã€‚è¿”å›ä»èŠ‚ç‚¹ 1 å‡ºå‘åˆ°èŠ‚ç‚¹ n çš„ å—é™è·¯å¾„æ•° ã€‚ç”±äºæ•°å­—å¯èƒ½å¾ˆå¤§ï¼Œè¯·è¿”å›å¯¹ 109 + 7 å–ä½™ çš„ç»“æœã€‚ å‚è€ƒçš„è§£æ³• æ¨¡ä»¿çš„è§£æ³• è¶…æ—¶ï¼Œæ€€ç–‘æ˜¯ æ„å»ºå›¾ èŠ±è´¹å¤ªå¤šæ—¶é—´ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148import microsoft.PlusOne;import java.util.*;public class CountRestrictedPaths_1786 { private static class Edge { int from, to; int weight; public Edge(int from, int to, int weight) { this.from = from; this.to = to; this.weight = weight; } public int getOther(int node) { if (node == from) return to; return from; } } private static class Map { List&lt;List&lt;Edge&gt;&gt; map; public int capacity; public Map(int capacity) { this.capacity = capacity; this.map = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; this.capacity; i++) { this.map.add(new ArrayList&lt;&gt;()); } } public void addEdge(int from, int to, int weight) { Edge e = new Edge(from, to, weight); this.map.get(from).add(e); this.map.get(to).add(e); } public List&lt;Edge&gt; adj(int node) { return this.map.get(node); } } private static class Pair implements Comparable&lt;Pair&gt; { int node; int weight; public Pair(int node, int weight) { this.node = node; this.weight = weight; } @Override public int compareTo(Pair o) { return weight - o.weight; } } // è¿”å› dp ç»“æœ // è¿™ä¸ªé¢˜ç›®è¯´çš„æ„æ€æ˜¯ åªè¦ä»å°¾ç»“ç‚¹å¼€å§‹éå† å¹¶ä¸”åˆ°ä¸‹ä¸€ä¸ªç‚¹çš„è·ç¦» å¤§äº å½“å‰ç‚¹çš„è·ç¦» å°±æ˜¯é€†åºçš„ // æŒ‰ç…§é¢˜è§£çš„æè¿° // è¿™æ¡è·¯å¾„çš„æœç´¢è¿‡ç¨‹å¯ä»¥çœ‹åšï¼Œä»ç»“å°¾ï¼ˆç¬¬ 5 ä¸ªç‚¹ï¼‰å‡ºå‘ï¼Œé€†ç€èµ°ï¼Œæ¯æ¬¡é€‰æ‹©ä¸€ä¸ªç‚¹ï¼ˆä¾‹å¦‚ aï¼‰ä¹‹åï¼Œ // å†é€‰æ‹©ä¸‹ä¸€ä¸ªç‚¹ï¼ˆä¾‹å¦‚ bï¼‰æ—¶å°±å¿…é¡»æ»¡è¶³æœ€çŸ­è·¯è·ç¦»æ¯”ä¸Šä¸€ä¸ªç‚¹ï¼ˆç‚¹ aï¼‰è¦è¿œï¼Œå¦‚æœæœ€ç»ˆèƒ½é€‰åˆ°èµ·ç‚¹ï¼ˆç¬¬ä¸€ä¸ªç‚¹ï¼‰ï¼Œè¯´æ˜ç»Ÿè®¡å‡ºä¸€æ¡æœ‰æ•ˆè·¯å¾„ã€‚ public int[] dijkstra(Map map, int start) { int[] dstTo = new int[map.capacity]; Arrays.fill(dstTo, Integer.MAX_VALUE); dstTo[start] = 0; PriorityQueue&lt;Pair&gt; queue = new PriorityQueue&lt;&gt;(); queue.add(new Pair(start, 0)); // æ— å‘å›¾ é˜²æ­¢é‡å¤ boolean[] memo = new boolean[map.capacity]; while (!queue.isEmpty()) { Pair top = queue.poll(); memo[top.node] = true; for (Edge e : map.adj(top.node)) { int other = e.getOther(top.node); if (!memo[other] &amp;&amp; dstTo[other] &gt; dstTo[top.node] + e.weight) { dstTo[other] = dstTo[top.node] + e.weight; queue.removeIf((p) -&gt; p.node == other); queue.add(new Pair(other, dstTo[other])); } } } return dstTo; } public int countRestrictedPaths(int n, int[][] edges) { Map map = new Map(n + 1); for (int[] edge : edges) { map.addEdge(edge[0], edge[1], edge[2]); } // è¿”å›èŠ‚ç‚¹çš„æ•°æ® int[] dstTo = dijkstra(map, n); // å¾—åˆ°äº†distæ•°ç»„ï¼Œå¯ä»¥å¾—åˆ°é€’æ¨å…³ç³»ï¼Œdp[u] += dp[v], when v links to v and dist[u] &gt; dist[v] // å› æ­¤å…ˆç®—distå°çš„ï¼Œæ‰å¯ä»¥ç®—dpï¼Œéœ€è¦distä»å°åˆ°å¤§æ’åº, ç„¶åä¾æ¬¡è®¡ç®—ã€‚ // ä¿å­˜åˆ°æŸä¸ªç‚¹ ä»¥åŠå¯¹åº”çš„ dst è·ç¦» List&lt;int[]&gt; pairs = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; dstTo.length; i++) { pairs.add(new int[]{i, dstTo[i]}); } pairs.sort(Comparator.comparingInt(a -&gt; a[1])); int[] dp = new int[n + 1]; dp[n] = 1; int mod = 1000000007; for (int[] p : pairs) { int node = p[0], cur = p[1]; for (Edge adj : map.adj(node)) { int other = adj.getOther(node); if (cur &gt; dstTo[other]) { dp[node] = (dp[node] + dp[other]) % mod; } } } return dp[1]; } public static void main(String[] args) { System.out.println(new CountRestrictedPaths_1786().countRestrictedPaths(5, new int[][]{ {1, 2, 3}, {1, 3, 3}, {2, 3, 1}, {1, 4, 2}, {5, 2, 2}, {3, 5, 1}, {5, 4, 10} })); System.out.println(new CountRestrictedPaths_1786().countRestrictedPaths(7, new int[][]{ {1, 3, 1}, {4, 1, 2}, {7, 3, 4}, {2, 5, 3}, {5, 6, 1}, {6, 7, 2}, {7, 5, 3}, {2, 6, 4} })); }} åšå¼ˆé—®é¢˜é¢„æµ‹èµ¢å®¶åˆ†åˆ«ä»æ•°ç»„çš„ä¸¤ç«¯å–å€¼ï¼Œé—®æœ€åè°è·èƒœã€‚ æ¨¡æ‹Ÿå–å€¼çš„è¿‡ç¨‹å³å¯ 123456789101112131415161718public boolean PredictTheWinner(int[] nums) { int[][] memo = new int[nums.length][nums.length]; for (int[] ints : memo) { Arrays.fill(ints, -1); } return recursionMemo(nums, 0, nums.length - 1, memo) &gt;= 0;}public int recursionMemo(int[] nums, int i, int j, int[][] memo) { if (i &gt; j) return 0; if (i == j) return nums[i]; if (memo[i][j] != -1) return memo[i][j]; // åˆ†åˆ«é€‰å–å·¦è¾¹å’Œå³è¾¹çš„å€¼è¿›è¡Œæ¯”è¾ƒ int left = nums[i] - recursionMemo(nums, i + 1, j, memo); int right = nums[j] - recursionMemo(nums, i, j - 1, memo); memo[i][j] = Math.max(left, right); return memo[i][j];} çŸ³å­æ¸¸æˆçŸ³å­æ¸¸æˆ VIIæ‚é¢˜é€’å¢çš„ä¸‰å…ƒå­åºåˆ— é¦–å…ˆæƒ³åˆ°å˜›ï¼Œç”¨ä¸¤ä¸ªæ•°ç»„åˆ†åˆ«å­˜å‚¨ä»å·¦åˆ°å³çš„æœ€å°å€¼å’Œæœ€å³åˆ°å·¦çš„æœ€å¤§å€¼ï¼Œé‚£ä¹ˆå¦‚æœ nums ä¸­ä¸€ä¸ªæ•° num å¤§äºè¿™ä¸ªæœ€å°å€¼å°äºè¿™ä¸ªæœ€å¤§å€¼ï¼Œæ˜¯ä¸€å®šå¯ä»¥çš„ 123456789101112131415161718192021222324252627282930313233343536func increasingTriplet(nums []int) bool { if len(nums) == 0 { return false } mins, maxes := make([]int, len(nums)), make([]int, len(nums)) mins[0] = nums[0] for i := 1; i &lt; len(nums); i++ { mins[i] = min(mins[i-1], nums[i]) } maxes[len(nums)-1] = nums[len(nums)-1] for i := len(nums) - 2; i &gt;= 0; i-- { maxes[i] = max(maxes[i+1], nums[i]) } for i, num := range nums { if num &gt; mins[i] &amp;&amp; num &lt; maxes[i] { return true } } return false}func max(a, b int) int { if a &gt; b { return a } return b}func min(a, b int) int { if a &lt; b { return a } return b} è¿˜å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ– ä»–å®é™…ä¸Šæ˜¯æ‰¾è¿™ä¹ˆä¸€ç»„ 3 ä¸ªæ•° num1 &lt; num2 &lt; num3 é‚£ä¹ˆå¦‚æœæˆ‘åœ¨ num3 ä¹‹å‰æ‰¾åˆ°äº†è¿™ä¸¤ä¸ªæ•°å­— num1 num2 å³å¯ æ‰€ä»¥ç”¨ ä¸€ä¸ª min mid æ¥è®°å½•ä¹‹å‰æ‰¾åˆ°çš„ num1 num2ã€‚ å…¶ä¸­ min ä¿å­˜ä¹‹å‰é‡åˆ°çš„æœ€å°å€¼, mid ä¿å­˜ä¹‹å‰ å¤§äº min çš„æœ€å°å€¼ï¼Œé‚£ä¹ˆ å¦‚æœç¢°åˆ° åŒæ—¶å¤§äº minã€mid çš„æ•° å°±å¯ä»¥ç›´æ¥è¿”å› true äº†ã€‚ ä½†æ˜¯å¯èƒ½é‡åˆ°è¿™ç§æƒ…å†µï¼Œåœ¨è®¿é—®æ‰¾åˆ° num3 çš„æ—¶å€™ï¼Œmin å¯¹åº”çš„æ•°å­—çš„ä¸‹æ ‡åœ¨ mid ä¹‹åã€‚ ä½†æ˜¯è€ƒè™‘è¿™ç§æƒ…å†µçš„è¯ï¼Œä¸€å®šæœ‰ä¸€ä¸ªå°äº mid çš„ å†å² min å€¼åœ¨ mid ä¹‹å‰ï¼Œæ‰€ä»¥å…¶å®è¿˜æ˜¯ä¸€ä¸ªå®Œæ•´çš„ä¸‰å…ƒç»„ã€‚ 12345678910111213141516class Solution { public boolean increasingTriplet(int[] nums) { if (nums == null || nums.length &lt; 3) return false; int min = Integer.MAX_VALUE, mid = Integer.MAX_VALUE; for (int num : nums) { if (num &lt;= min) { min = num; } else if (num &lt;= mid) { mid = num; } else { return true; } } return false; }} äºŒåˆ†è¢‹å­é‡Œæœ€å°‘æ•°ç›®çš„çƒ ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ nums ï¼Œå…¶ä¸­ nums[i] è¡¨ç¤ºç¬¬ i ä¸ªè¢‹å­é‡Œçƒçš„æ•°ç›®ã€‚åŒæ—¶ç»™ä½ ä¸€ä¸ªæ•´æ•° maxOperations ã€‚ä½ å¯ä»¥è¿›è¡Œå¦‚ä¸‹æ“ä½œè‡³å¤š maxOperations æ¬¡ï¼šé€‰æ‹©ä»»æ„ä¸€ä¸ªè¢‹å­ï¼Œå¹¶å°†è¢‹å­é‡Œçš„çƒåˆ†åˆ° 2 ä¸ªæ–°çš„è¢‹å­ä¸­ï¼Œæ¯ä¸ªè¢‹å­é‡Œéƒ½æœ‰ æ­£æ•´æ•° ä¸ªçƒã€‚æ¯”æ–¹è¯´ï¼Œä¸€ä¸ªè¢‹å­é‡Œæœ‰ 5 ä¸ªçƒï¼Œä½ å¯ä»¥æŠŠå®ƒä»¬åˆ†åˆ°ä¸¤ä¸ªæ–°è¢‹å­é‡Œï¼Œåˆ†åˆ«æœ‰ 1 ä¸ªå’Œ 4 ä¸ªçƒï¼Œæˆ–è€…åˆ†åˆ«æœ‰ 2 ä¸ªå’Œ 3 ä¸ªçƒã€‚ä½ çš„å¼€é”€æ˜¯å•ä¸ªè¢‹å­é‡Œçƒæ•°ç›®çš„ æœ€å¤§å€¼ ï¼Œä½ æƒ³è¦ æœ€å°åŒ– å¼€é”€ã€‚è¯·ä½ è¿”å›è¿›è¡Œä¸Šè¿°æ“ä½œåçš„æœ€å°å¼€é”€ã€‚ bruteforce ç›´æ¥çš„åšæ³•å°±æ˜¯ä¸åœçš„æ‰¾åˆ°æ•°ç»„ä¸­æœ€å¤§çš„æ•°ï¼Œç„¶ååœ¨ maxOperations çš„æ¬¡æ•°é™åˆ¶å†…è¿›è¡Œåˆ†éš”ï¼Œæ‰¾åˆ°åˆ†éš”ä¸­æœ€å°çš„æ•°æ®ã€‚ ä¸ºäº† o(1) çš„æ‰¾åˆ°æœ€å¤§çš„æ•°ï¼Œæ‰€ä»¥ä½¿ç”¨çš„ pq æ¥ä¿å­˜ä¸­é—´æ•°æ® 12345678910111213141516171819202122232425// bruteforce æ¨¡æ‹Ÿçš„æ–¹æ³• é€šè¿‡å¯¹é€’å½’çš„æ–¹æ³•å¯¹æœ€å¤§æ•°è¿›è¡Œä¸åœçš„åˆ†éš” å¾—åˆ°æœ€åçš„ç»“æœpublic int minimumSizeBruteForce(int[] nums, int maxOperations) { PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a, b) -&gt; b - a); for (int num : nums) { pq.add(num); } return recursion(pq, maxOperations);}public int recursion(PriorityQueue&lt;Integer&gt; pq, int operations) { assert !pq.isEmpty(); if (operations == 0) return pq.peek(); int max = pq.poll(); int res = Integer.MAX_VALUE; for (int i = 1; i &lt;= max / 2; i++) { int other = max - i; pq.add(i); pq.add(other); res = Math.min(res, recursion(pq, operations - 1)); pq.remove(i); pq.remove(other); } pq.add(max); return res;} äºŒåˆ†æŸ¥æ‰¾ äºŒåˆ†æŸ¥æ‰¾å¯ä»¥ç”¨äºæŸ¥æ‰¾æœ€å°çš„æœ€å¤§å€¼ï¼Œæœ€å¤§çš„æœ€å°å€¼ç­‰æƒ…å†µã€‚ é‚£ä¹ˆå¯ä»¥ä»¥ç»“æœä½œä¸ºåŒºé—´ï¼Œæ¯æ¬¡åˆ¤æ–­è¿™ä¸ªæœ€å°å¼€é”€æ˜¯å¦èƒ½å¤Ÿå®ç°ï¼Œå°±å¯ä»¥å»ç¼©çŸ­éå†çš„èŒƒå›´ã€‚ ä½†æ˜¯éœ€è¦çŸ¥é“å¦‚ä½•æ‰¾åˆ°èƒ½å¦å®ç°è¿™ä¸ªå‡½æ•°ï¼š å½“ç”¨ mid å»è§„å®šæœ€å°å¼€é”€çš„æ—¶å€™ï¼Œæ„å‘³ç€æ‰€æœ‰å¤§äº mid çš„æ•°å­—éƒ½éœ€è¦è¢«æ‹†åˆ†åˆ°æœ€å°å¼€é”€ä¸­ æ‹†åˆ†çš„æ—¶å€™ï¼Œå¦‚ num = 8, mid = 4, é‚£ä¹ˆåªéœ€è¦æ‹†åˆ†ä¸€æ¬¡å³å¯ï¼Œå¦‚ num = 17, mid = 7ï¼Œé‚£ä¹ˆéœ€è¦æ‹†åˆ†æˆ[7,7,3] éœ€è¦æ‹†åˆ†ä¸¤æ¬¡ã€‚æ‰€ä»¥æ‹†åˆ†çš„ä»£ä»·æ˜¯ num / midï¼Œåœ¨ num % mid == 0 æ—¶è¦å‡ä¸€ 123456789101112131415161718192021222324252627282930// äºŒåˆ†æŸ¥æ‰¾ äºŒåˆ†çš„èŒƒå›´æ˜¯è¿”å›çš„æœ€å°ç»“æœ// å³æœ€å°ä»£ä»·public int minimumSize(int[] nums, int maxOperations) { // nums ä¸­æœ€å¤§çš„æ•°ä¸º j çš„å¤§å° int i = 1, j = 1000000000; int res = 0; while (i &lt;= j) { int mid = i + (j - i) / 2; if (check(nums, mid, maxOperations)) { j = mid - 1; res = mid; } else { i = mid + 1; } } return res;}// æ£€æŸ¥å½“å‰éå†åˆ°çš„ mid çš„çŠ¶æ€ èƒ½ä¸èƒ½åœ¨ maxOperations çš„é™åˆ¶ä¸‹è¾¾åˆ°public boolean check(int[] nums, int mid, int maxOperations) { int res = 0; for (int num : nums) { if (num % mid == 0) { res += num / mid - 1; } else { res += num / mid; } } return res &lt;= maxOperations;} æ‰¾å‡ºç¬¬ k å°çš„è·ç¦»å¯¹è·ç¦»å·®å®šä¹‰ä¸º æ•°ç»„ä¸­ ä»»æ„ä¸€å¯¹æ•°ä¹‹é—´çš„å·®çš„ç»å¯¹å€¼ å› æ­¤æ‰¾åˆ°ç¬¬ K ä¸ªæœ€å°è·ç¦»ï¼Œä¸€ä¸ªç›´è§‚çš„è§£æ³•å°±æ˜¯ï¼Œéå†æ‰€æœ‰çš„å·®ï¼Œæ”¾å…¥åˆ°åªæœ‰ k ä¸ªæ•°çš„å¤§é¡¶å †ä¸­ï¼Œé‚£ä¹ˆå †é¡¶éƒ½æ˜¯ç»“æœã€‚ï¼ˆmemory çˆ†äº†ï¼‰ 12345678910111213141516171819202122232425262728293031323334353637type IntHeap []intfunc (h IntHeap) Len() int { return len(h) }func (h IntHeap) Less(i, j int) bool { return h[i] &gt; h[j] }func (h IntHeap) Swap(i, j int) { h[i], h[j] = h[j], h[i] }func (h *IntHeap) Push(x interface{}) { // Push and Pop use pointer receivers because they modify the slice's length, // not just its contents. *h = append(*h, x.(int))}func (h *IntHeap) Pop() interface{} { old := *h n := len(old) x := old[n-1] *h = old[0 : n-1] return x}// æ‰¾åˆ° nums ä¸­ç¬¬kå°ä¸€å¯¹æ•°ä¹‹é—´çš„æœ€çŸ­è·ç¦»ï¼ˆè·ç¦»ä¸ºä¸¤æ•°ä¹‹å·®ï¼‰// heap outOfMemoryfunc smallestDistancePairWithHeap(nums []int, k int) int { hp := &amp;IntHeap{} heap.Init(hp) for i := 0; i &lt; len(nums); i++ { for j := i + 1; j &lt; len(nums); j++ { heap.Push(hp, int(math.Abs(float64(nums[i]-nums[j])))) if hp.Len() &gt; k { heap.Pop(hp) } } } return (*hp)[0]} å¦å¤–ä¸€ä¸ªæƒ³æ³•å°±æ˜¯äºŒåˆ† äºŒåˆ†çš„èŒƒå›´æ˜¯ä»å·®å€¼çš„èŒƒå›´å‡ºå‘ï¼Œå³ 0 -&gt; max(nums) - min(nums)ï¼Œé‚£ä¹ˆ max min å¯ä»¥ç›´æ¥æ’åºå–é¦–å°¾å³å¯ ä½†æ˜¯å¦‚ä½•ç»Ÿè®¡ï¼ŒäºŒåˆ†ä¸­å°äº mid çš„å·®å€¼çš„æ•°é‡ ä»¥ [1,2,2,3,4] ä¸ºä¾‹ï¼Œå›ºå®šå³è¾¹ç•Œä¸º 4 çš„æ—¶å€™ 1 -&gt; 4 ä¸­é—´å¯èƒ½å°äº k çš„æ•°å­—ç»„åˆä¸º [1,4] [2,4] [2,4] [3,4] å…¶ç»“æœä¸º j - i = 4 - 0 (4 çš„ä¸‹æ ‡ 4 1 çš„ä¸‹æ ‡ 1) 12345678910111213141516171819202122232425262728293031323334353637383940func smallestDistancePair(nums []int, k int) int { if len(nums) == 0 { return -1 } sort.Ints(nums) // i, j è¡¨ç¤ºçš„æ˜¯ nums ä¸­çš„ æ•°æ®å·® çš„èŒƒå›´ i, j := 0, nums[len(nums)-1] - nums[0] for i &lt; j { // mid è¡¨ç¤ºçš„æ˜¯ä¸­é—´çš„å·®å€¼ mid := i + (j - i) / 2 // æ‰¾åˆ°å°äºç­‰äº mid çš„æ•°å€¼å·®çš„æ•°é‡ count := findDistancePair(nums, mid) if count &gt; k { j = mid - 1 } else if count &lt; k { i = mid + 1 } else { // å› ä¸ºæ˜¯å°äºç­‰äº æ‰€ä»¥å¯èƒ½ mid æ˜¯è§£ ä¹Ÿå¯ä»¥æ˜¯åœ¨å·¦è¾¹ j = mid } } return i}func findDistancePair(nums []int, distance int) int { res := 0 // å›ºå®šå³è¾¹ç•Œ i, j := 0, 0 for j &lt; len(nums) { // ç»Ÿè®¡å‡ºæ¥çš„æ˜¯å°äºç­‰äº distance çš„æ•°é‡ for i &lt; j &amp;&amp; nums[j] - nums[i] &gt; distance { i++ } // å› ä¸ºæ˜¯é€’å¢çš„ å¦‚æœè¿™ä¸ªæ—¶å€™ 1,2,2,3,4 ç›¸å½“äºå›ºå®šå³è¾¹ç•Œ é‚£ä¹ˆæ’åºå®Œçš„æ•°ç»„ å·¦è¾¹èƒ½å¤Ÿå½¢æˆçš„æ»¡è¶³æ¡ä»¶çš„æ•°å¯¹ åº”è¯¥æ˜¯ j - i ä¸ª res += j - i j++ } return res} å­—å…¸æ ‘çŒœå­—è°œæš´åŠ›è§£æ³•ï¼Œç”¨ word å»åŒ¹é… puzzle çš„ set è¶…æ—¶äº†ã€‚ è€ŒåŸé¢˜ç›®ä¸­ words çš„æ•°é‡æ¯” puzzles çš„æ•°é‡é«˜ä¸€ä¸ªæ•°é‡çº§ï¼Œå› æ­¤å¯ä»¥ä½¿ç”¨ å­—å…¸æ ‘ å‹ç¼© word çš„æ•°é‡ï¼Œç”¨ puzzle è¿›è¡Œæ¯”è¾ƒ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788private class TrieTree { int currency; TrieTree[] child; public TrieTree() { this.currency = 0; // å› ä¸ºåªåŒ…å«å°å†™å­—æ¯ this.child = new TrieTree[26]; } public void add(char[] word) { TrieTree cur = this; for (char c : word) { if (cur.child[c - 'a'] == null) { cur.child[c - 'a'] = new TrieTree(); } cur = cur.child[c - 'a']; } // currency è¡¨ç¤ºæœ‰ä¸€ä¸ª word åˆ°è¾¾äº†è¿™ä¸ªåº• cur.currency++; }}public List&lt;Integer&gt; findNumOfValidWords(String[] words, String[] puzzles) { // å› ä¸ºå®é™…ä¸Šå¹¶ä¸åœ¨æ„ word çš„é¡ºåº è€Œä¸”æ ¹æ®é¢˜ç›®è¦æ±‚ word ä¸å®šé•¿ è€Œä¸”æ¯” puzzle å¤§ å› ä¸º puzzle æ˜¯ 7 ä¸ºå›ºå®šé•¿åº¦ // æ‰€ä»¥å›ºå®š word ä¸º å­—ç¬¦æ ‘ TrieTree root = new TrieTree(); // åŠ å…¥å­—å…¸æ ‘ä¸­ç›¸å½“äº å‹ç¼©äº† words for (String word : words) { // æ’åºå»é‡åŠ å…¥ å› ä¸ºè¿™æ ·æ‰èƒ½ç»Ÿè®¡ currency å¹¶è¿›è¡Œå‹ç¼© root.add(getCharArray(word)); } List&lt;Integer&gt; res = new ArrayList&lt;&gt;(puzzles.length); for (int i = 0; i &lt; puzzles.length; i++) { res.add(0); } // æ¯”è¾ƒ puzzle ä¸ å­—å…¸æ ‘ // puzzle æœ€å¤§æ·±åº¦ä¸º 7 // æœ€ååªéœ€è¦åŠ ä¸Š currency å³å¯ for (int i = 0; i &lt; puzzles.length; i++) { char[] puzzleArray = getCharArray(puzzles[i]); char required = puzzles[i].charAt(0); res.set(i, recursionSearch(root, puzzleArray, 0, required)); } return res;}// puzzle å»åŒ¹é…å­—å…¸æ ‘ æ‰¾åˆ°ä¸€ä¸ª èŠ‚ç‚¹ è¿”å›å…¶ currency å³å¯¹åº”çš„ word æ•°é‡public int recursionSearch(TrieTree node, char[] puzzleArray, int pos, char required) { if (node == null) { return 0; } // puzzle æœ€æ·±å°±æ‰“åˆ°è¿™å„¿ if (pos == puzzleArray.length) { return node.currency; } // å¯ä»¥é€‰æ‹©ç”¨å½“å‰ pos è¿™ä¸ªä½ç½®æ¥åŒ¹é… ç„¶åéƒ½ ++ int res = recursionSearch(node.child[puzzleArray[pos] - 'a'], puzzleArray, pos + 1, required); // å› ä¸ºå»é‡äº† æ‰€ä»¥ required ç­‰äºçš„æ—¶å€™ ä¸€å®šè¦åŒ¹é… // ä¸ç­‰äºçš„æ—¶å€™ï¼Œå¯ä»¥ç»´æŒ node å¼•ç”¨ ç„¶åä¸åŒ¹é… è·³è¿‡ puzzle çš„è¿™ä¸ªå­—ç¬¦ ç»§ç»­å¾€ä¸‹èµ° if (puzzleArray[pos] != required) { // + æ˜¯å› ä¸º å¯ä»¥ç”¨å¤šæ¡è·¯èµ° å®é™…ä¸Šå°±æ˜¯è¦æˆ–è€…ä¸è¦ res += recursionSearch(node, puzzleArray, pos + 1, required); } return res;}public char[] getCharArray(String word) { char[] tmp = word.toCharArray(); Arrays.sort(tmp); int newIndex = 0; int l = 0, r = 0; while (r &lt; tmp.length) { while (r &lt; tmp.length &amp;&amp; tmp[r] == tmp[l]) { r++; } tmp[newIndex++] = tmp[l]; l = r; } char[] res = new char[newIndex]; System.arraycopy(tmp, 0, res, 0, newIndex); return res;} è®¡ç®—å™¨åŸºæœ¬è®¡ç®—å™¨å…¶æœ¬è´¨æ˜¯ä¸€ä¸ª ä¸­å€¼è¡¨è¾¾å¼ æ±‚å€¼ã€‚å®é™…ä¸Šåªéœ€è¦æ³¨æ„ ç¬¦å·çš„ ä¼˜å…ˆçº§å³å¯ã€‚ï¼ˆPSï¼šÂ·Â· å¥½å¤šç»†èŠ‚æ²¡æ³¨æ„åˆ° å°±ä¼š ggï¼‰ TODO: ä¸­å€¼è¡¨è¾¾å¼ è½¬æˆ é€†æ³¢å…°è¡¨è¾¾å¼ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import java.util.Deque;import java.util.LinkedList;public class BasicCalculator_224 { private int operate(char operator, int n1, int n2) { switch (operator) { case '+' -&gt; { return n1 + n2; } case '-' -&gt; { return n2 - n1; } } return 0; } // å­—ç¬¦çš„ä¼˜å…ˆçº§ï¼ï¼ï¼ TODO: ä¸­å€¼è¡¨è¾¾å¼ è½¬ é€†æ³¢å…°è¡¨è¾¾å¼ // ä¸­ç¼€è½¬åç¼€ public int calculate(String s) { // åªæœ‰ æ•°å­— + - ( ) Deque&lt;Integer&gt; number = new LinkedList&lt;&gt;(); Deque&lt;Character&gt; operators = new LinkedList&lt;&gt;(); if (s.length() &gt; 0 &amp;&amp; s.charAt(0) == '-') { s = '0' + s; } s = s.replaceAll(&quot;\\\\(\\\\+&quot;, &quot;(0+&quot;); s = s.replaceAll(&quot;\\\\(-&quot;, &quot;(0-&quot;); for (int i = 0; i &lt; s.length(); ) { char c = s.charAt(i); if (c == ' ') { i++; } else if (c == '+') { // éœ€è¦å¼¹å‡ºæ ˆ ç›´åˆ°ä¼˜å…ˆçº§ç›¸ç­‰ å› ä¸ºåªæœ‰ - + æ‰€ä»¥éœ€è¦ä¸€ç›´å¼¹å‡ºåˆ° - while (operators.size() &gt; 0 &amp;&amp; operators.peekLast() != '+' &amp;&amp; operators.peekLast() != '(') { int first = number.removeLast(); int second = 0; if (!number.isEmpty()) second = number.removeLast(); number.add(operate(operators.removeLast(), first, second)); } operators.add(c); i++; } else if (c == '-') { while (operators.size() &gt; 0 &amp;&amp; operators.peekLast() == '-' &amp;&amp; operators.peekLast() != '(') { int first = number.removeLast(); int second = 0; if (!number.isEmpty()) second = number.removeLast(); number.add(operate(operators.removeLast(), first, second)); } operators.add(c); i++; } else if (c == '(') { operators.add(c); i++; } else if (c == ')') { // å¼¹æ ˆ while (operators.size() &gt; 0 &amp;&amp; operators.peekLast() != '(') { int first = number.removeLast(); int second = 0; if (!number.isEmpty()) second = number.removeLast(); number.add(operate(operators.removeLast(), first, second)); } // å»æ‰ ( operators.removeLast(); i++; } else { int num = 0; // æ•°å­— while (i &lt; s.length() &amp;&amp; s.charAt(i) &gt;= '0' &amp;&amp; s.charAt(i) &lt;= '9') { num = num * 10 + s.charAt(i) - '0'; i++; } number.add(num); } } while (!operators.isEmpty()) { int first = number.removeLast(); int second = 0; if (!number.isEmpty()) second = number.removeLast(); number.add(operate(operators.removeLast(), first, second)); } return number.getLast(); } public static void main(String[] args) { System.out.println(new BasicCalculator_224().calculate( &quot;(6)-(8)-(7)+(1+(6))&quot;)); System.out.println(new BasicCalculator_224().calculate( &quot;1 + 1&quot;)); System.out.println(new BasicCalculator_224().calculate( &quot; 2-1 + 2 &quot;)); System.out.println(new BasicCalculator_224().calculate( &quot;(1+(4+5+2)-3)+(6+8)&quot;)); }} æ•°å­¦é—®é¢˜1802. æœ‰ç•Œæ•°ç»„ä¸­æŒ‡å®šä¸‹æ ‡å¤„çš„æœ€å¤§å€¼ ç»™ä½ ä¸‰ä¸ªæ­£æ•´æ•° nã€index å’Œ maxSum ã€‚ä½ éœ€è¦æ„é€ ä¸€ä¸ªåŒæ—¶æ»¡è¶³ä¸‹è¿°æ‰€æœ‰æ¡ä»¶çš„æ•°ç»„ numsï¼ˆä¸‹æ ‡ ä» 0 å¼€å§‹ è®¡æ•°ï¼‰ï¼šnums.length == nnums[i] æ˜¯ æ­£æ•´æ•° ï¼Œå…¶ä¸­ 0 &lt;= i &lt; nabs(nums[i] - nums[i+1]) &lt;= 1 ï¼Œå…¶ä¸­ 0 &lt;= i &lt; n-1nums ä¸­æ‰€æœ‰å…ƒç´ ä¹‹å’Œä¸è¶…è¿‡ maxSumnums[index] çš„å€¼è¢« æœ€å¤§åŒ–è¿”å›ä½ æ‰€æ„é€ çš„æ•°ç»„ä¸­çš„ nums[index] ã€‚ è¿™ä¸ªé—®é¢˜å°±æ˜¯è¯´æ„å»ºä¸€ä¸ªåªæœ‰æ­£æ•´æ•°çš„æ•°ç»„ï¼Œä¸”ç›¸é‚»æ•°å­—ä¹‹é—´å·®å€¼ä¸èƒ½è¶…è¿‡ 1ï¼Œé—® å¦‚ä½•æ„å»ºæ‰èƒ½ä½¿ index ä¸‹æ ‡ä½ç½®çš„æ•°æœ€å¤§ã€‚ å…¶å®åå‘äºè´ªå¿ƒçš„ç­–ç•¥ï¼Œæ—¢ç„¶è¦ index æœ€å¤§ï¼Œé‚£ä¹ˆæ¯æ¬¡éå†çš„æ—¶å€™ï¼Œæˆ‘éƒ½åœ¨ index ä¸Š +1ï¼Œçœ‹åœ¨æ²¡æœ‰æ‰“åˆ° maxSum çš„æ—¶å€™èƒ½å¤Ÿç»™è¿™ä¸ªåœ°æ–¹æ·»åŠ å‡ æ¬¡ã€‚æœ€åå…¶å®é™…çš„ç”Ÿé•¿è¿‡ç¨‹å¯ä»¥çœ‹åšä¸‹é¢çš„ä¸€ä¸ªè¿‡ç¨‹ã€‚ ä¾‹è¾“å…¥ï¼šn = 4, index = 2, maxSum = 6 æ„å»ºåŸºç¡€æ•°ç»„ï¼Œå› ä¸ºè¦æ±‚æ¯ä¸ªæ•°å­—éƒ½ä¸ºæ­£æ•´æ•°ï¼Œå› æ­¤æœ€å°ä¸º 1 1 1 1 1 _ | index ä» index å¼€å§‹ç”Ÿé•¿ 2 1 1 1 1 _ | index è¿™ä¸ªæ—¶å€™ å·²ç»ä¸èƒ½å†åŠ  1 äº† æ‰€ä»¥ç›´æ¥è¿”å› 2 æ‰€ä»¥å…¶å®å°±æ˜¯æ„å»ºä¸€ä¸ªé¢˜å‹çš„å°çŠ¶ç»“æ„ï¼Œæ¯å±‚æ¯”ä¸‹ä¸€å±‚åªä¼šé«˜ 1 ä¸ªï¼Œæœ€ååˆ° index çš„ä½ç½®æœ€é«˜å³å¯ã€‚ 123456789101112131415161718192021222324252627282930class Solution { public int maxValue(int n, int index, int maxSum) { // å› ä¸ºæ˜¯æ­£æ•´æ•° æ‰€ä»¥ç›¸å½“äºæ¯ä¸ªæ•°å­—è‡³å°‘è¦å¡«ä¸Š1 int remain = maxSum - n; // ç°åœ¨ index ä½ç½®å¡«å…¥çš„æ˜¯ 1 int res = 1; // ç„¶åæ ¹æ®å‰©ä¸‹çš„æ•°å­— ä» index å¼€å§‹å¢åŠ  int l = index, r = index; while (l &gt; 0 || r &lt; n - 1) { // åœ¨ l åˆ° r ä¹‹é—´çš„æ•°å­— åŠ  1 int len = r - l + 1; if (remain &gt;= len) { // index å¯¹åº”ä½ç½®çš„æ•°å­— ä¸€å®šæ˜¯åœ¨ l,r ä¹‹é—´çš„ res += 1; // å› ä¸ºç›¸é‚»ä¸èƒ½ç›¸å·® 1 æ‰€ä»¥ æ¯æ¬¡ lã€r å‘å¤–å¢åŠ  1 ä½é•¿åº¦ l = Math.max(0, l - 1); r = Math.min(r + 1, n - 1); remain -= len; } else { break; } } // è¿˜å‰©ä¸‹ å…¨éƒ¨åŠ ä¸€ res += remain / n; return res; }} 132 æ¨¡å¼åœ¨ä¸€ä¸ªæ•°ç»„ä¸­æ‰¾åˆ°ä¸‹æ ‡ i &lt; j &lt; k æ»¡è¶³ nums[i] &lt; nums[k] &lt; nums[j] ä¹Ÿå°±æ˜¯è¯´ j å¯¹åº”çš„æ•°å€¼ æ˜¯ä¸‰ä¸ªä¸­æœ€å¤§çš„ k æ¬¡ä¹‹ï¼Œæœ€å°çš„æ˜¯ i é‚£ä¹ˆå¾ˆå®¹æ˜“çŸ¥é“ i çš„å€¼å…¶å®éœ€è¦è¶Šå°è¶Šå¥½ï¼Œè¶Šå°çš„è¯ï¼Œåé¢ kã€j çš„æ¡ä»¶å°±æœ€å¥½æ»¡è¶³ï¼Œå› æ­¤ç¬¬ä¸€æ­¥å°±æ˜¯æ±‚å‡ºä»å·¦å‘å³çš„æœ€å°å€¼æ•°ç»„ brute force çš„æ–¹æ³•(o(n^2)) æ—¢ç„¶å·²ç»çŸ¥é“ i å–ä»å·¦å‘å³çš„æœ€å°å€¼ï¼Œé‚£ä¹ˆåªæƒ³å°±éœ€è¦ç¡®å®š j &lt; k ä¸” nums[i] &lt; nums[k] &lt; nums[j]ï¼Œä¹Ÿå°±æ˜¯åœ¨åç»­çš„æ•°ç»„ä¸­æ‰¾åˆ°ä¸€å¯¹é€†åºçš„æ•°ç»„ï¼Œé‚£ä¹ˆ o(n^2) çš„ç®—æ³•å°±å¾ˆå¥½å†™äº† 123456789101112131415161718192021222324// æ‰¾åˆ° 1 3 2 æ¨¡å¼// bruteforce çš„æ–¹æ³• å› ä¸ºè¦æ‰¾åˆ° i &lt; j &lt; k æ»¡è¶³ nums[i] &lt; nums[k] &lt; nums[j] çš„æ ¼å¼// å³ä¸­é—´çš„æ•°æ˜¯æœ€å¤§ é‚£ä¹ˆ nums[i] ä¸€å®šæ˜¯æœ€å° æ‰€ä»¥å…ˆç»´æŠ¤ä¸€ä¸ª leftMin è¡¨ç¤ºä»å·¦ä¾§å¼€å§‹çš„æœ€å°å€¼// ç„¶åå¼€å§‹éå†æ•°ç»„ æ‰¾åˆ°ä¸€ä¸ª é€†åºæ•°å¯¹ ä¸”é€†åºæ•°å¯¹ä¸­çš„æœ€å°å€¼ å¤§äº leftMin çš„å€¼ å³å¯æ‰¾åˆ°// æ‰€ä»¥æ˜¯ o(n^2)public boolean find132patternBruteForce(int[] nums) { if (nums == null || nums.length &lt; 3) return false; int[] leftMin = new int[nums.length]; leftMin[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) { leftMin[i] = Math.min(leftMin[i - 1], nums[i]); } // å…ˆå›ºå®šä¸€ä¸ªæœ€å°å€¼ // ç„¶ååœ¨æ‰¾åˆ°ä¸€ä¸ªé€†åºçš„ç‚¹ for (int i = 1; i &lt; nums.length - 1; i++) { for (int j = i + 1; j &lt; nums.length; j++) { if (nums[j] &gt; leftMin[i] &amp;&amp; nums[i] &gt; nums[j]) return true; } } return false;} ä¼˜åŒ–çš„ç®—æ³•ï¼ˆo(n)ï¼‰ ä¹‹å‰çš„ç®—æ³•å¯»æ‰¾é€†åºçš„æ—¶å€™ï¼Œæ˜¯åœ¨ç¡®å®šäº† j å€¼ çš„æƒ…å†µä¸‹ä»å‰å‘åå¯»æ‰¾ k å€¼ï¼Œå¦‚æœèƒ½å¤ŸçŸ¥é“ä¹‹å‰è®¿é—®çš„è¿‡çš„ j å€¼ï¼Œä½œä¸ºå½“å‰ k å€¼ï¼Œé‚£ä¹ˆå°±å¯ä»¥è¿›ä¸€æ­¥çš„é™ä½å¤æ‚åº¦ã€‚ å› ä¸ºï¼Œåœ¨æ»¡è¶³ nums[j] &gt; leftMin[j] (å³ nums[i]) æ—¶ï¼Œå¦‚æœ k å€¼æ­£å¥½å–åˆ°å°äº nums[j] çš„å€¼ ä¸” å¤§äº nums[i] æ—¶æ»¡è¶³æ¡ä»¶ã€‚æ‰€ä»¥ nums[k] çš„å€¼ åœ¨å–å°äº nums[j] çš„å€¼çš„æ—¶å€™ è¶Šå¤§è¶Šå¥½ï¼Œå› ä¸ºè¿™æ ·æ‰å¯èƒ½æ›´å¤§ç¨‹åº¦çš„æ»¡è¶³ nums[k] &gt; nums[i] çš„æ¡ä»¶ã€‚ æ‰€ä»¥ä½¿ç”¨ä¸€ä¸ªå•è°ƒæ ˆæ¥ä¿å­˜ j ä¹‹åéå†çš„å†å²æƒ…å†µï¼Œè¶Šé è¿‘æ ˆåº•çš„å€¼è¶Šå¤§ï¼Œåªéœ€è¦å–åˆ°æ ˆä¸­éœ€è¦çš„æ»¡è¶³å°äº nums[j] çš„æœ€å¤§å€¼å³å¯ã€‚ è¿™æ · æ ˆä¸­è¿˜ä¿å­˜ç€è¾ƒå¤§çš„å€¼ï¼Œä¹‹åå†éå†çš„æ—¶å€™ï¼Œè¿˜ä»¥ç”¨è¿™ä¸ªæ¯” nums[j] å¤§çš„å€¼ï¼Œä¸ j ä¹‹å‰æ›´å¤§çš„å€¼åŒ¹é…æˆ 132 ç»„åˆã€‚ è€Œ j ä¹‹åçš„è¾ƒå°å€¼ï¼Œå¦‚ä½•æ»¡è¶³é¢˜è®¾æ¡ä»¶ï¼Œä¼šåœ¨ç¬¬ä¸€æ¬¡è®¿é—®çš„æ—¶å€™å°±è¿”å›äº†ï¼Œæ‰€ä»¥ä¹Ÿä¸ä¼šå­˜åœ¨æ¼çš„ç»“æœã€‚ 12345678910111213141516171819202122232425262728public boolean find132pattern(int[] nums) { if (nums == null || nums.length &lt; 3) return false; int[] leftMin = new int[nums.length]; leftMin[0] = nums[0]; for (int i = 1; i &lt; nums.length; i++) { leftMin[i] = Math.min(leftMin[i - 1], nums[i]); } Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;(); // ä»åå‘å‰æ‰¾ å› ä¸ºè¦æ‰¾çš„æ˜¯ j &lt; k nums[j] &gt; nums[k] çš„ç»“æœ // é‚£ä¹ˆåªéœ€è¦ä¿å­˜éå†çš„ j ä¹‹åçš„æ¯” nums[j] å° ä¸”æ¯” leftMin å¤§çš„æœ€å¤§å€¼ è¿™æ ·å°±å¯ä»¥æ»¡è¶³è¦æ±‚äº† // æ‰€ä»¥ stack ä¸­ä¿å­˜çš„æ˜¯ j ä¹‹åçš„ è¾ƒå¤§çš„å€¼ å¦‚æœèƒ½å¤Ÿåœ¨å…¶ä¸­æ‰¾åˆ°ä¸€ä¸ªå°äº nums[j] çš„å€¼ å°±è¯æ˜å¯è¡Œ for (int j = nums.length - 1; j &gt;= 0; j--) { // å¿…é¡»è¦æ¯”å·¦ä¾§æœ€å°çš„å¤§ æ‰èƒ½æ¯”è¾ƒ if (nums[j] &gt; leftMin[j]) { // å› ä¸ºè¦åœ¨ j å³è¾¹æ‰¾ä¸€ä¸ªæ›´å°çš„ nums[k] æ‰€ä»¥ æ¯” nums[j] å°çš„ éƒ½å‡ºæ ˆ // æ¯”è¾ƒå…¶ä¸­çš„æœ€å¤§å€¼ä¸ leftMin çš„å¤§å°æ—¢å¯ä»¥çŸ¥é“ int remove = Integer.MIN_VALUE; while (!stack.isEmpty() &amp;&amp; stack.peekLast() &lt; nums[j]) { remove = stack.removeLast(); } if (remove &gt; leftMin[j]) return true; stack.addLast(nums[j]); } } return false;} æœ€å¤§å­åºå’Œç®€å•çš„é¢˜å‹ç®€å•çš„é¢˜å‹å¦‚ å‰‘æŒ‡offer ä¸Šæ‰€è¿°ï¼Œåªéœ€è¦ç”¨ä¸€ä¸ªæ•°ç»„ä¿å­˜ä»¥å½“å‰ç»“å°¾çš„æœ€å¤§å­åºå’Œå³å¯ã€‚è½¬ç§»çš„æ—¶å€™ï¼Œå¦‚æœä¹‹å‰çš„æœ€å¤§å­åºå’Œå°äº 0ï¼Œè¯´æ˜åº”è¯¥é‡æ–°å¼€å§‹è®¡æ•°ã€‚ 123456789101112131415class Solution { public int maxSubArray(int[] nums) { int[] dp = new int[nums.length]; int res = Integer.MIN_VALUE; for (int i = 0; i &lt; nums.length; i++) { if (i == 0 || dp[i - 1] &lt; 0) { dp[i] = nums[i]; } else { dp[i] = dp[i - 1] + nums[i]; } res = Math.max(res, dp[i]); } return res; }} åˆ é™¤ä¸€æ¬¡å¾—åˆ°å­æ•°ç»„æœ€å¤§å’Œ ç›´è§‰æƒ³æ³• æ‹¿åˆ°è¿™ä¸ªé¢˜ç›®çš„ç¬¬ä¸€ä¸ªç›´è§‰å°±æ˜¯è·Ÿä¸Šé¢é‚£ä¸ªåŸºæœ¬ä¸€è‡´ï¼Œä½†æ˜¯éœ€è¦åˆ é™¤ä¸€ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆåˆ é™¤çš„è¿™ä¸ªæ•°å­—ä¸€å®šå­˜åœ¨è¿™æ ·çš„æ€§è´¨ã€‚ åˆ é™¤è¿™ä¸ªæ•°å­—åï¼Œæœ‰å¯èƒ½å·¦å³çš„æœ€å¤§å­åºå’ŒåŠ èµ·æ¥æ›´å¤§ï¼Œæ‰€ä»¥è¿™ä¸ªæ•°å­—ä¸€å®šæ˜¯è´Ÿæ•°ã€‚ é‚£ä¹ˆï¼Œåªéœ€è¦çŸ¥é“è¿™ä¸ªæ•°å­—å·¦è¾¹å’Œå³è¾¹çš„åˆ†åˆ«çš„æœ€å¤§å­åºå’Œå³å¯ï¼Œé‚£ä¹ˆå°±å¯ä»¥ç”¨ä¸¤æ¬¡ä¸Šé¢çš„ç®—æ³•ï¼Œå¾—åˆ°ä»¥ i ç»“å°¾çš„ä»å·¦å‘å³æœ€å¤§å­åºå’Œ å’Œ ä»¥ i ç»“å°¾çš„ä»å³æƒ³å·¦çš„æœ€å¤§å­åºå’Œå³å¯ 123456789101112131415161718192021222324252627282930313233343536373839// æœ€å¤§å­åºå’Œçš„å˜ç§ å¦‚æœä¸­é—´å¯ä»¥åˆ é™¤ä¸€ä¸ªæ•°å­— é—®èƒ½å¤Ÿå½¢æˆçš„æœ€å¤§å­åºå’Œä¸ºå¤šå°‘public int maximumSumWithTwoDirection(int[] arr) { if (arr == null || arr.length == 0) return 0; if (arr.length == 1) return arr[0]; // å› æ­¤è¦åˆ é™¤ä¸€ä¸ªçš„è¯ åªéœ€è¦éå†è¢«åˆ é™¤çš„é¡¹å³å¯ï¼Œç„¶åå°†ä»¥ arr[i] ç»“å°¾çš„å·¦å³çš„æœ€å¤§å­åºå’Œç´¯åŠ èµ·æ¥å³å¯ int[] left = new int[arr.length + 1]; int[] right = new int[arr.length + 1]; for (int i = 0; i &lt; arr.length; i++) { if (left[i] &lt; 0) left[i + 1] = arr[i]; else left[i + 1] = left[i] + arr[i]; } for (int j = arr.length - 1; j &gt;= 0; j--) { if (right[j + 1] &lt; 0) right[j] = arr[j]; else right[j] = right[j + 1] + arr[j]; } int res = Math.max(left[arr.length], right[0]); // éå†éœ€è¦åˆ é™¤çš„è´Ÿæ•°ç‚¹ å› ä¸ºåªæœ‰è´Ÿæ•°æ‰éœ€è¦åˆ é™¤ åˆ é™¤åæ‰å¯èƒ½è¾¾åˆ°éœ€è¦çš„è¿ç»­ä¸¤ä¸ªæ®µçš„æœ€å¤§å€¼ for (int i = 0; i &lt; arr.length; i++) { // åªæœ‰å°äº 0 æ‰éœ€è¦åˆ†éš” if (arr[i] &lt; 0) { // æ³¨æ„çš„æ˜¯éœ€è¦åˆ†ç¦»å¼€ i == 0 i == arr.length - 1 å› ä¸º é»˜è®¤æ˜¯0 ä¼šå½±å“ res ä¸ºè´Ÿæ•°çš„æƒ…å†µ if (i == 0) { res = Collections.max(Arrays.asList(right[i + 1], res)); } else if (i == arr.length - 1) { res = Collections.max(Arrays.asList(left[i], res)); } else { // å¹³æ—¶çš„è¯ å»æ‰è¿™ä¸ªå€¼ åªéœ€è¦åœ¨ä¸‰éƒ¨åˆ†ä¸­å–è¾ƒå¤§å€¼ä¸ res æ¯”è¾ƒå³å¯ res = Collections.max(Arrays.asList(left[i] + right[i + 1], left[i], right[i + 1], res)); } } } // æ²¡æœ‰å°äº 0 çš„è¯ è¯´æ˜å…¨æ˜¯æ­£æ•° // è¿”å›å’Œå³å¯ return res;} ä¸¤ä¸ª dp æ•°ç»„ä¿å­˜çŠ¶æ€ é‚£ä¹ˆå¯ä»¥ä½¿ç”¨ä¸€ä¸ªå¾ªç¯å¾—åˆ°ç»“æœã€‚ ä»ç„¶éœ€è¦ä¸€ä¸ªæ•°ç»„ä¿å­˜ä»¥ arr[i] ç»“å°¾æ—¶çš„æœ€å¤§å­åºå’Œ éœ€è¦ä¸€ä¸ªæ•°ç»„ä¿å­˜ä»¥ arr[i] ç»“å°¾æ—¶åˆ é™¤ä¸€ä¸ªæ•°å­—çš„æœ€å¤§å­åºå’Œ é‚£ä¹ˆåˆ é™¤çš„è¿™ä¸ªæ•°å­—å¯èƒ½æ˜¯éå†çš„ arr[i] æˆ–è€… ä¹‹å‰å°±å·²ç»åˆ é™¤äº†ä¸€ä¸ªæ•°å­—ï¼Œarr[i] ä¸èƒ½è¢«åˆ é™¤ã€‚æ‰€ä»¥ç¬¬2ä¸ªæ•°ç»„çš„æ›´æ–°ç­–ç•¥å³deleteOne[i] = Math.max(deleteOne[i - 1] + arr[i], dp[i - 1])ã€‚ å³ä¿ç•™å½“å‰çš„ arr[i] é‚£ä¹ˆåªèƒ½å–ä¹‹å‰åˆ é™¤äº†ä¸€æ¬¡çš„æœ€å¤§å­åºå’Œ å’Œ åˆ é™¤å½“å‰çš„ arr[i]ï¼Œé‚£ä¹ˆå°±è¦å»ä¹‹å‰æ²¡æœ‰åˆ é™¤æ•°å­—çš„æœ€å¤§å­åºå’Œ dp[i - 1]ã€‚ 12345678910111213141516171819public int maximumSum(int[] arr) { if (arr == null || arr.length == 0) return 0; int[] dp = new int[arr.length]; // ä¿å­˜åˆ é™¤ä¸€ä¸ªçš„ç»“æœ int[] deleteOne = new int[arr.length]; dp[0] = arr[0]; // æœ€å°å€¼åˆ°è¾¾ -10^ (4) deleteOne[0] = -100000; int res = Math.max(dp[0], deleteOne[0]); for (int i = 1; i &lt; arr.length; i++) { dp[i] = Math.max(arr[i], dp[i - 1] + arr[i]); // è¦åˆ é™¤ä¸€ä¸ªæ•°çš„è¯ è¦ä¹ˆä¿ç•™å½“å‰æ•° å’Œ ä¹‹å‰åˆ é™¤ä¸€ä¸ªæ•°å½¢æˆçš„æœ€å¤§å€¼æ¯”è¾ƒ è¦ä¹ˆåˆ é™¤å½“å‰è¿™ä¸ªæ•° ä¸ä¹‹å‰ä¿å­˜çš„æœ€å¤§å€¼æ¯”è¾ƒ deleteOne[i] = Math.max(deleteOne[i - 1] + arr[i], dp[i - 1]); res = Math.max(res, Math.max(dp[i], deleteOne[i])); } return res;}","link":"/2021/01/18/leetcode/"}],"tags":[{"name":"code","slug":"code","link":"/tags/code/"},{"name":"æ±‚èŒ","slug":"æ±‚èŒ","link":"/tags/%E6%B1%82%E8%81%8C/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"summary","slug":"summary","link":"/tags/summary/"},{"name":"hash","slug":"hash","link":"/tags/hash/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"hello world","slug":"hello-world","link":"/tags/hello-world/"},{"name":"ç¬”è¯•","slug":"ç¬”è¯•","link":"/tags/%E7%AC%94%E8%AF%95/"},{"name":"concurrent","slug":"concurrent","link":"/tags/concurrent/"},{"name":"kmp","slug":"kmp","link":"/tags/kmp/"},{"name":"string","slug":"string","link":"/tags/string/"},{"name":"qrcode","slug":"qrcode","link":"/tags/qrcode/"},{"name":"åæ§½","slug":"åæ§½","link":"/tags/%E5%90%90%E6%A7%BD/"},{"name":"sort","slug":"sort","link":"/tags/sort/"},{"name":"å›¾ç®—æ³•","slug":"å›¾ç®—æ³•","link":"/tags/%E5%9B%BE%E7%AE%97%E6%B3%95/"},{"name":"è®¾è®¡æ¨¡å¼","slug":"è®¾è®¡æ¨¡å¼","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"}],"categories":[{"name":"life","slug":"life","link":"/categories/life/"},{"name":"code","slug":"code","link":"/categories/code/"},{"name":"tutorial","slug":"tutorial","link":"/categories/tutorial/"},{"name":"algorithm","slug":"algorithm","link":"/categories/algorithm/"},{"name":"ç®—æ³•","slug":"ç®—æ³•","link":"/categories/%E7%AE%97%E6%B3%95/"}]}
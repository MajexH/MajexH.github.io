---
title: network
category:
  - interview
tags:
  - 计网
toc: true
---

简单记录下从五层模型出发的计算机网络的每层结构以及运行在其上的简单协议。

<!-- more -->

## 五层模型

### 物理层

物理层传输电气信号，比如说光电转换之类的、调制解调之类的。光纤、双绞线等。

### 数据链路层

数据链路层使用的的信道包括:

- 点对点的信道。
- 广播信道。

#### 基本问题

##### 封装成帧

<pre>
| 帧首部 |  传输的数据  | 帧尾部 |
    |         |          |
    | <= MTU(最大传输单元) |
    |____使用其来定界______|
</pre>

帧定界符：首部和尾部，用来识别收到的帧是否完整。

##### 透明传输

使用了帧定界符，有可能**传输的数据**与定界符相同，因此为了防止错误的识别定界符，在数据中与定界符相同的字符前会添加**转义符**

<pre>
| 首部 |         数据         | 尾部 |
| 转换为
| 首部 |   [转义符]首部  (数据) | 尾部 |
</pre>

##### 差错检测

由于传输中，可能存在**比特差错**(即传输中二进制 0 变为 1，1 变为 0 的错误)，因此需要差错检测，检测到差错后，丢弃该帧以重新发送。

现在广泛使用的是 CRC（循环冗余检测），即在数据后添加 n 位作为冗余的校验位，以实现**无比特差错的传输**。

CRC 运行过程:

- 协商使用的长度为 (n + 1) 位的**除数**
- 在发送的数据后添加 n 位 0 作为**被除数**
- 将 **除数** 与 **被除数** 进行亦或
- 得到 `余数`，作为 FCS 的冗余码添加在数据后面

> 如 <br/>
> 数据 = 101001<br/>
> 除数 = 1101 (n = 3)<br/>
> 那么就是用 101001<span style="color: red">000</span> 使用除法亦或 1101，得到余数 001<br/>
> 传输的数据为 101001<span style="color: red">001</span><br/>
> 接收方在接受后会根据写张的除数校验后几位数据

#### ppp 协议(点对点)

点对点协议，完成点对点的链路。一般使用在与 ISP 进行沟通的

<pre>
|      首部              |  数据   |    尾部             |

| F(7E) | A(FF) | C(03) | 信息部分 | FCS(校验码) | F(7E) |
</pre>

- 帧定界符
  - F(0x7E)
- 首部
  - F: 定界符
  - A、C: 无意义字段
- 数据
  - 包裹的上层数据
- 尾部
  - FCS: 使用 CRC 的冗余校验码
  - F: 定界符

#### 广播信道

##### CSMA/CD 协议

采用总线形接入的局域网（一般这种都应用在局域网内），使用广播的方式传递数据，并监听载波，在冲突发生的时候进行回退重发。

其运行流程为

- 在某一个时刻 a，A 站监测到信道空闲，发送数据
- 在之后的某一时刻 b，B 站也监测到信道空闲，发送数据
- 那么， a、b 在一端时间后都会监测到碰撞
- 使用截断二进制指数退避
  - 由于最长的传播时间为 2t = 2 * s / v （即单端的传输距离 * 2 / 传输速度），因此规定其为争用期。
  - 从离散的正数集合 [0, 1, …… , 2 ^ k - 1] 中选取一个回退指数 m (k = min(重传次数, 10))，回退 m * 2t (m 个争用期)在发送数据
  - 由于需要在帧发送途中监听到碰撞，所以规定了最小帧长 64 字节（不够的需要添加数据），因为如果数据过短，那么在监听到碰撞其就已经发送完毕了。

##### mac 地址

添加在网卡固件中的全球唯一的地址！！作为硬件地址存在

在以太网传输的过程中，数据链路层也会封装 mac 帧，网卡（适配器）根据 mac 帧的目标地址选择的接受传输的消息。

- mac 帧

<pre>
|      首部              |  数据   |    尾部      |

| 目的地址 | 源地址 | 类型 | 信息部分 | FCS(校验码)  |
</pre>

- 首部
  - 目的地址、源地址
  - 类型：表示上层使用的协议
- 数据
- 尾部： FCS

在实际交给网卡传输的时候，还会在其帧前添加**前同步码**、**帧开始定界符**（由硬件实现）。

### 网络层

网络层向上提供无连接的、尽力交付的数据报服务。将数据进行分组转发。

#### IP 协议 

与 IP 协议一起搭配使用的还有
- ARP 协议(IP 地址 -> mac 地址) 
- RARP 与上相反
- ICMP （网际控制）
- IGMP (网际组管理)

##### IP 地址分类

以下都是 IPV4 的协议，使用 32 位的长度来编码

- A 类地址

<pre>
| 0  网络号(7位长度)  |    主机号   |
| --     8 位     -- | -- 24 位 -- |
</pre>

因此 A 类地址的从 0.0.0.0 -> 127.255.255.255

其中 **127.X.X.X 地址作为本地的回环地址使用**

- B 类地址

<pre>
| 10  网络号(14位长度)  |    主机号   |
| --     16 位     -- | -- 16 位 -- |
</pre>

因此 B 类地址从 128.0.0.0 -> 191.255.255.255

- C 类地址

<pre>
| 110  网络号(21位长度)  |    主机号   |
| --     24 位     -- | -- 8 位 -- |
</pre>

因此 C 类地址从 192.0.0.0 -> 255.255.255.255


##### arp 协议

ip 地址是针对 网络层 以及在此基础上的协议和层次使用的，那么实际上，网络层还需要使用 arp 协议将 ip 地址转换成 mac 地址，交给数据链路层进行数据转发。

<pre>
| | |
| | |

</pre>

##### ip 数据报字段

主要介绍其首部包含的字段

#### 子网和超网

#### 路由选择算法

下一跳的路由选择的算法
### 传输层



TCP\UDP 协议

#### tcp （面向连接的可靠传输协议）

三次握手

1. client 发送以个 SYN = 1 seq = x 的一个消息
2. server 发送一个 SYN = 1 ACK = x+1 seq = Y 的一个消息
3. client 确认 seq = x + 1 ack = Y + 1

四次挥手

1. client 发送 finish=1 seq

### 应用层

http 协议等

## socket IO

read() 全堵塞的

select() 选择一个 fd 监听

pselect() 监听多个，让 代码去 select 多有的 fd 监听

IO 的话 因为调用的都是系统提供的堵塞操作，所以相当于一个使用时 bind listen recv 之后的 socket fd，在文件中找到沟通的消息

BIO 为了提高效率，就是在 recv 之后，启动一个新的线程处理 对应的 socket fd，进行 read，提高效率

NIO 给我的感觉就是轮训忙等待，维护一个接受的 client，然后再 select read 返回非 -1 时 进行处理。因此 系统调用会比较多。而且是通过单线程执行，因此在高并发下，处理比较慢一点儿。

所以会有 select、pselect 允许监听多个 fd，在有数据时进行通知（相当于钩子函数）
